# # 非递归版扩展欧几里得算法（适配超大整数，无递归深度限制）
# def extended_gcd(a, b):
#     """
#     非递归实现扩展欧几里得算法
#     返回 (gcd, x, y)，满足 a*x + b*y = gcd(a, b)
#     """
#     old_r, r = a, b
#     old_s, s = 1, 0
#     old_t, t = 0, 1

#     while r != 0:
#         quotient = old_r // r
#         # 迭代更新 r, s, t
#         old_r, r = r, old_r - quotient * r
#         old_s, s = s, old_s - quotient * s
#         old_t, t = t, old_t - quotient * t

#     # old_r是gcd，old_s和old_t是对应的系数
#     return (old_r, old_s, old_t)

# def modinv(a, mod):
#     """非递归版模逆运算，无递归深度限制"""
#     g, x, y = extended_gcd(a, mod)
#     if g != 1:
#         raise Exception('模逆不存在（本题e1/e2互质，不会触发）')
#     else:
#         return x % mod

# # 题目给定参数（原样保留）
# n = 22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801
# c1 = 22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361
# e1 = 11187289
# c2 = 18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397
# e2 = 9647291

# # 1. 计算e1和e2的线性组合系数x,y（满足e1*x + e2*y = 1）
# g, x, y = extended_gcd(e1, e2)
# print(f"验证e1和e2互质：gcd(e1,e2) = {g} (应为1)")

# # 2. 处理负数次幂，计算c1^x * c2^y mod n
# if x < 0:
#     c1_inv = modinv(c1, n)
#     term1 = pow(c1_inv, -x, n)  # 等价于c1^x mod n（x为负）
# else:
#     term1 = pow(c1, x, n)

# if y < 0:
#     c2_inv = modinv(c2, n)
#     term2 = pow(c2_inv, -y, n)  # 等价于c2^y mod n（y为负）
# else:
#     term2 = pow(c2, y, n)

# # 3. 计算明文m
# m = (term1 * term2) % n

# # 4. 整数转可读字符串（CTF明文常用编码）
# def int_to_text(num):
#     try:
#         # 大端序转字节，再转UTF-8/ASCII
#         byte_len = (num.bit_length() + 7) // 8
#         bytes_data = num.to_bytes(byte_len, byteorder='big')
#         return bytes_data.decode('utf-8')
#     except UnicodeDecodeError:
#         # 若UTF-8失败，返回16进制（便于手动转换）
#         return f"十六进制明文: {hex(num)}"

# # 输出最终结果
# print("="*60)
# print(f"明文整数m = {m}")
# print("="*60)
# print(f"解密后的明文: {int_to_text(m)}")

# 极简版RSA共模攻击（无递归、无多余依赖）
def extended_gcd(a, b):
    old_r, r = a, b
    old_s, s = 1, 0
    while r != 0:
        quotient = old_r // r
        old_r, r = r, old_r - quotient * r
        old_s, s = s, old_s - quotient * s
    return (old_r, old_s)

def modinv(a, mod):
    g, x = extended_gcd(a, mod)
    return x % mod

# 仅保留核心参数
n = 22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801
c1 = 22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361
e1 = 11187289
c2 = 18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397
e2 = 9647291

# 核心计算（共模攻击核心逻辑）
g, x = extended_gcd(e1, e2)
if x < 0:
    c1_inv = modinv(c1, n)
    term1 = pow(c1_inv, -x, n)
else:
    term1 = pow(c1, x, n)

y = (1 - e1 * x) // e2
if y < 0:
    c2_inv = modinv(c2, n)
    term2 = pow(c2_inv, -y, n)
else:
    term2 = pow(c2, y, n)

m = (term1 * term2) % n

# 最简输出（直接转字符串）
try:
    print("解密结果：", m.to_bytes((m.bit_length()+7)//8, 'big').decode())
except:
    print("十六进制结果：", hex(m))


